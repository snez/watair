(function () {





// Copyright (c) 2009-2011 Turbulenz Limited

//
// AABBTree
//
function AABBTree() {}
AABBTree.prototype =
{
    version : 1,
    numNodesLeaf : 4,

    add : function addFn(externalNode, extents)
    {
        var endNode = this.endNode;
        externalNode.aabbTreeIndex = endNode;
        this.nodes[endNode] = {
            leaf : true,
            escapeNodeOffset : 1,
            externalNode : externalNode,
            extents : extents.slice()
        };
        this.endNode = (endNode + 1);
        this.needsRebuild = 1;
        this.numAdds += 1;
        this.numExternalNodes += 1;
    },

    remove : function removeFn(externalNode)
    {
        var index = externalNode.aabbTreeIndex;
        if (index !== undefined)
        {
            if (this.numExternalNodes > 1)
            {
                var nodes = this.nodes;
                var maxNumber = Number.MAX_VALUE;
                nodes[index] = {
                    escapeNodeOffset : 1,
                    extents : [ maxNumber,  maxNumber,  maxNumber,
                               -maxNumber, -maxNumber, -maxNumber]
                };
                var endNode = this.endNode;
                if ((index + 1) >= endNode)
                {
                    while (!nodes[endNode - 1].leaf)
                    {
                        endNode -= 1;
                    }
                    this.endNode = endNode;
                }
                else
                {
                    this.needsRebuild = 1;
                }
                this.numExternalNodes -= 1;
            }
            else
            {
                this.clear();
            }

            delete externalNode.aabbTreeIndex;
        }
    },

    findParent : function findParentFn(nodeIndex)
    {
        var nodes = this.nodes;
        var parentIndex = nodeIndex;
        var nodeDist = 0;
        var parent;
        do
        {
            parentIndex -= 1;
            nodeDist += 1;
            parent = nodes[parentIndex];
        }
        while (parent.escapeNodeOffset <= nodeDist);
        return parent;
    },

    update : function aabbTreeUpdateFn(externalNode, extents)
    {
        var index = externalNode.aabbTreeIndex;
        if (index !== undefined)
        {
            var min0 = extents[0];
            var min1 = extents[1];
            var min2 = extents[2];
            var max0 = extents[3];
            var max1 = extents[4];
            var max2 = extents[5];

            var needsRebuild = this.needsRebuild;
            var needsRebound = this.needsRebound;
            var nodes = this.nodes;
            var node = nodes[index];
            var nodeExtents = node.extents;

            if (needsRebuild ||
                needsRebound ||
                nodeExtents[0] > min0 ||
                nodeExtents[1] > min1 ||
                nodeExtents[2] > min2 ||
                nodeExtents[3] < max0 ||
                nodeExtents[4] < max1 ||
                nodeExtents[5] < max2)
            {
                nodeExtents[0] = min0;
                nodeExtents[1] = min1;
                nodeExtents[2] = min2;
                nodeExtents[3] = max0;
                nodeExtents[4] = max1;
                nodeExtents[5] = max2;

                if (!needsRebuild && 1 < nodes.length)
                {
                    this.numUpdates += 1;
                    if (this.startUpdate > index)
                    {
                        this.startUpdate = index;
                    }
                    if (this.endUpdate < index)
                    {
                        this.endUpdate = index;
                    }
                    if (!needsRebound)
                    {
                        // force a rebound when things change too much
                        if ((2 * this.numUpdates) > this.numExternalNodes)
                        {
                            this.needsRebound = 1;
                        }
                        else
                        {
                            var parent = this.findParent(index);
                            var parentExtents = parent.extents;
                            if (parentExtents[0] > min0 ||
                                parentExtents[1] > min1 ||
                                parentExtents[2] > min2 ||
                                parentExtents[3] < max0 ||
                                parentExtents[4] < max1 ||
                                parentExtents[5] < max2)
                            {
                                this.needsRebound = 1;
                            }
                        }
                    }
                    else
                    {
                        // force a rebuild when things change too much
                        if (this.numUpdates > (3 * this.numExternalNodes))
                        {
                            this.needsRebuild = 1;
                            this.numAdds = this.numUpdates;
                        }
                    }
                }
            }
        }
        else
        {
            this.add(externalNode, extents);
        }
    },

    needsFinalize : function needsFinalizeFn()
    {
        return (this.needsRebuild || this.needsRebound);
    },

    finalize : function finalizeFn()
    {
        if (this.needsRebuild)
        {
            this.rebuild();
        }
        else if (this.needsRebound)
        {
            this.rebound();
        }
    },

    rebound : function reboundFn()
    {
        var nodes = this.nodes;
        if (nodes.length > 1)
        {
            var startUpdateNodeIndex = this.startUpdate;
            var endUpdateNodeIndex   = this.endUpdate;

            var nodesStack = [];
            var numNodesStack = 0;
            var topNodeIndex = 0;
            for (;;)
            {
                var topNode = nodes[topNodeIndex];
                var currentNodeIndex = topNodeIndex;
                var currentEscapeNodeIndex = (topNodeIndex + topNode.escapeNodeOffset);
                var nodeIndex = (topNodeIndex + 1); // First child
                var node;
                do
                {
                    node = nodes[nodeIndex];
                    var escapeNodeIndex = (nodeIndex + node.escapeNodeOffset);
                    if (nodeIndex < endUpdateNodeIndex)
                    {
                        if (!node.leaf)
                        {
                            if (escapeNodeIndex > startUpdateNodeIndex)
                            {
                                nodesStack[numNodesStack] = topNodeIndex;
                                numNodesStack += 1;
                                topNodeIndex = nodeIndex;
                            }
                        }
                    }
                    else
                    {
                        break;
                    }
                    nodeIndex = escapeNodeIndex;
                }
                while (nodeIndex < currentEscapeNodeIndex);

                if (topNodeIndex === currentNodeIndex)
                {
                    nodeIndex = (topNodeIndex + 1); // First child
                    node = nodes[nodeIndex];

                    var extents = node.extents;
                    var minX = extents[0];
                    var minY = extents[1];
                    var minZ = extents[2];
                    var maxX = extents[3];
                    var maxY = extents[4];
                    var maxZ = extents[5];

                    nodeIndex = (nodeIndex + node.escapeNodeOffset);
                    while (nodeIndex < currentEscapeNodeIndex)
                    {
                        node = nodes[nodeIndex];
                        extents = node.extents;
                        /*jslint white: false*/
                        if (minX > extents[0]) { minX = extents[0]; }
                        if (minY > extents[1]) { minY = extents[1]; }
                        if (minZ > extents[2]) { minZ = extents[2]; }
                        if (maxX < extents[3]) { maxX = extents[3]; }
                        if (maxY < extents[4]) { maxY = extents[4]; }
                        if (maxZ < extents[5]) { maxZ = extents[5]; }
                        /*jslint white: true*/
                        nodeIndex = (nodeIndex + node.escapeNodeOffset);
                    }

                    extents = topNode.extents;
                    extents[0] = minX;
                    extents[1] = minY;
                    extents[2] = minZ;
                    extents[3] = maxX;
                    extents[4] = maxY;
                    extents[5] = maxZ;

                    endUpdateNodeIndex = topNodeIndex;

                    if (0 < numNodesStack)
                    {
                        numNodesStack -= 1;
                        topNodeIndex = nodesStack[numNodesStack];
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }

        this.needsRebuild = false;
        this.needsRebound = false;
        this.numAdds = 0;
        //this.numUpdates = 0;
        this.startUpdate = Number.MAX_VALUE;
        this.endUpdate = -Number.MAX_VALUE;
    },

    rebuild : function rebuildFn()
    {
        if (this.numExternalNodes > 0)
        {
            var nodes = this.nodes;

            var buildNodes, numBuildNodes;

            if (this.numExternalNodes === nodes.length)
            {
                buildNodes = nodes;
                numBuildNodes = nodes.length;
                nodes = [];
                this.nodes = nodes;
            }
            else
            {
                buildNodes = [];
                buildNodes.length = this.numExternalNodes;
                numBuildNodes = 0;
                var endNodeIndex = this.endNode;
                for (var n = 0; n < endNodeIndex; n += 1)
                {
                    var currentNode = nodes[n];
                    if (currentNode.leaf)
                    {
                        buildNodes[numBuildNodes] = currentNode;
                        numBuildNodes += 1;
                    }
                }
                if (buildNodes.length > numBuildNodes)
                {
                    buildNodes.length = numBuildNodes;
                }
                nodes.length = 0;
            }

            var rootNode;
            if (numBuildNodes > 1)
            {
                if (numBuildNodes > this.numNodesLeaf &&
                    this.numAdds > 0)
                {
                    if (this.highQuality)
                    {
                        this.sortNodesHighQuality(buildNodes);
                    }
                    else if (this.ignoreY)
                    {
                        this.sortNodesNoY(buildNodes);
                    }
                    else
                    {
                        this.sortNodes(buildNodes);
                    }
                }

                this.recursiveBuild(buildNodes, 0, numBuildNodes, 0);
                this.endNode = nodes.length;

                // Check if we should take into account the Y coordinate
                rootNode = nodes[0];
                var extents = rootNode.extents;
                var deltaX = (extents[3] - extents[0]);
                var deltaY = (extents[4] - extents[1]);
                var deltaZ = (extents[5] - extents[2]);
                this.ignoreY = ((4 * deltaY) < (deltaX <= deltaZ ? deltaX : deltaZ));
            }
            else
            {
                rootNode = buildNodes[0];
                rootNode.externalNode.aabbTreeIndex = 0;
                nodes[0] = rootNode;
                this.endNode = 1;
            }
            buildNodes = null;
        }

        this.needsRebuild = false;
        this.needsRebound = false;
        this.numAdds = 0;
        this.numUpdates = 0;
        this.startUpdate = Number.MAX_VALUE;
        this.endUpdate = -Number.MAX_VALUE;
    },

    sortNodes : function sortNodesFn(nodes)
    {
        var numNodesLeaf = this.numNodesLeaf;
        var numNodes = nodes.length;
        var endNodeIndex = numNodes;

        function getkeyXfn(node)
        {
            var extents = node.extents;
            return (extents[0] + extents[3]);
        }

        function getkeyYfn(node)
        {
            var extents = node.extents;
            return (extents[1] + extents[4]);
        }

        function getkeyZfn(node)
        {
            var extents = node.extents;
            return (extents[2] + extents[5]);
        }

        function getreversekeyXfn(node)
        {
            var extents = node.extents;
            return -(extents[0] + extents[3]);
        }

        function getreversekeyYfn(node)
        {
            var extents = node.extents;
            return -(extents[1] + extents[4]);
        }

        function getreversekeyZfn(node)
        {
            var extents = node.extents;
            return -(extents[2] + extents[5]);
        }

        var nthElement = this.nthElement;
        var axis = 0;
        do
        {
            var nodeIndex = 0;
            var reverse = false;
            do
            {
                var endSplitNodeIndex = ((nodeIndex + numNodes) < endNodeIndex ? (nodeIndex + numNodes) : endNodeIndex);
                var splitNodeIndex    = parseInt(((nodeIndex + endSplitNodeIndex) / 2), 10);

                if (axis === 0)
                {
                    if (reverse)
                    {
                        nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getreversekeyXfn);
                    }
                    else
                    {
                        nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getkeyXfn);
                    }
                }
                else if (axis === 2)
                {
                    if (reverse)
                    {
                        nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getreversekeyZfn);
                    }
                    else
                    {
                        nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getkeyZfn);
                    }
                }
                else //if (axis === 1)
                {
                    if (reverse)
                    {
                        nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getreversekeyYfn);
                    }
                    else
                    {
                        nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getkeyYfn);
                    }
                }
                nodeIndex = endSplitNodeIndex;
                reverse = !reverse;
            }
            while ((nodeIndex + numNodesLeaf) < endNodeIndex);

            if (axis === 0)
            {
                axis = 2;
            }
            else if (axis === 2)
            {
                axis = 1;
            }
            else //if (axis === 1)
            {
                axis = 0;
            }

            numNodes = parseInt((numNodes / 2), 10);
        }
        while (numNodes > numNodesLeaf);
    },

    sortNodesNoY : function sortNodesNoYFn(nodes)
    {
        var numNodesLeaf = this.numNodesLeaf;
        var numNodes = nodes.length;
        var endNodeIndex = numNodes;

        function getkeyXfn(node)
        {
            var extents = node.extents;
            return (extents[0] + extents[3]);
        }

        function getkeyZfn(node)
        {
            var extents = node.extents;
            return (extents[2] + extents[5]);
        }

        function getreversekeyXfn(node)
        {
            var extents = node.extents;
            return -(extents[0] + extents[3]);
        }

        function getreversekeyZfn(node)
        {
            var extents = node.extents;
            return -(extents[2] + extents[5]);
        }

        var nthElement = this.nthElement;
        var axis = 0;
        do
        {
            var nodeIndex = 0;
            var reverse = false;
            do
            {
                var endSplitNodeIndex = ((nodeIndex + numNodes) < endNodeIndex ? (nodeIndex + numNodes) : endNodeIndex);
                var splitNodeIndex    = parseInt(((nodeIndex + endSplitNodeIndex) / 2), 10);

                if (axis === 0)
                {
                    if (reverse)
                    {
                        nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getreversekeyXfn);
                    }
                    else
                    {
                        nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getkeyXfn);
                    }
                }
                else //if (axis === 2)
                {
                    if (reverse)
                    {
                        nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getreversekeyZfn);
                    }
                    else
                    {
                        nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getkeyZfn);
                    }
                }
                nodeIndex = endSplitNodeIndex;
                reverse = !reverse;
            }
            while ((nodeIndex + numNodesLeaf) < endNodeIndex);

            if (axis === 0)
            {
                axis = 2;
            }
            else //if (axis === 2)
            {
                axis = 0;
            }

            numNodes = parseInt((numNodes / 2), 10);
        }
        while (numNodes > numNodesLeaf);
    },

    sortNodesHighQuality : function sortNodesHighQualityFn(nodes)
    {
        var numNodesLeaf = this.numNodesLeaf;
        var numNodes = nodes.length;
        var endNodeIndex = numNodes;

        function getkeyXfn(node)
        {
            var extents = node.extents;
            return (extents[0] + extents[3]);
        }

        function getkeyYfn(node)
        {
            var extents = node.extents;
            return (extents[1] + extents[4]);
        }

        function getkeyZfn(node)
        {
            var extents = node.extents;
            return (extents[2] + extents[5]);
        }

        function getkeyXZfn(node)
        {
            var extents = node.extents;
            return (extents[0] + extents[2] + extents[3] + extents[5]);
        }

        function getkeyZXfn(node)
        {
            var extents = node.extents;
            return (extents[0] - extents[2] + extents[3] - extents[5]);
        }

        function getreversekeyXfn(node)
        {
            var extents = node.extents;
            return -(extents[0] + extents[3]);
        }

        function getreversekeyYfn(node)
        {
            var extents = node.extents;
            return -(extents[1] + extents[4]);
        }

        function getreversekeyZfn(node)
        {
            var extents = node.extents;
            return -(extents[2] + extents[5]);
        }

        function getreversekeyXZfn(node)
        {
            var extents = node.extents;
            return -(extents[0] + extents[2] + extents[3] + extents[5]);
        }

        function getreversekeyZXfn(node)
        {
            var extents = node.extents;
            return -(extents[0] - extents[2] + extents[3] - extents[5]);
        }

        var nthElement = this.nthElement;
        var calculateSAH = this.calculateSAH;
        do
        {
            var nodeIndex = 0;
            var reverse = false;
            do
            {
                var endSplitNodeIndex = ((nodeIndex + numNodes) < endNodeIndex ? (nodeIndex + numNodes) : endNodeIndex);
                var splitNodeIndex    = parseInt(((nodeIndex + endSplitNodeIndex) / 2), 10);

                nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getkeyXfn);
                var sahX = (calculateSAH(nodes, nodeIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endSplitNodeIndex));

                nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getkeyYfn);
                var sahY = (calculateSAH(nodes, nodeIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endSplitNodeIndex));

                nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getkeyZfn);
                var sahZ = (calculateSAH(nodes, nodeIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endSplitNodeIndex));

                nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getkeyXZfn);
                var sahXZ = (calculateSAH(nodes, nodeIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endSplitNodeIndex));

                nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getkeyZXfn);
                var sahZX = (calculateSAH(nodes, nodeIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endSplitNodeIndex));

                if (sahX <= sahY &&
                    sahX <= sahZ &&
                    sahX <= sahXZ &&
                    sahX <= sahZX)
                {
                    if (reverse)
                    {
                        nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getreversekeyXfn);
                    }
                    else
                    {
                        nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getkeyXfn);
                    }
                }
                else if (sahZ <= sahY &&
                         sahZ <= sahXZ &&
                         sahZ <= sahZX)
                {
                    if (reverse)
                    {
                        nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getreversekeyZfn);
                    }
                    else
                    {
                        nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getkeyZfn);
                    }
                }
                else if (sahY <= sahXZ &&
                         sahY <= sahZX)
                {
                    if (reverse)
                    {
                        nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getreversekeyYfn);
                    }
                    else
                    {
                        nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getkeyYfn);
                    }
                }
                else if (sahXZ <= sahZX)
                {
                    if (reverse)
                    {
                        nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getreversekeyXZfn);
                    }
                    else
                    {
                        nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getkeyXZfn);
                    }
                }
                else //if (sahZX <= sahXZ)
                {
                    if (reverse)
                    {
                        nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getreversekeyZXfn);
                    }
                    else
                    {
                        nthElement(nodes, nodeIndex, splitNodeIndex, endSplitNodeIndex, getkeyZXfn);
                    }
                }

                nodeIndex = endSplitNodeIndex;
                reverse = !reverse;
            }
            while ((nodeIndex + numNodesLeaf) < endNodeIndex);

            numNodes = parseInt((numNodes / 2), 10);
        }
        while (numNodes > numNodesLeaf);
    },

    calculateSAH : function calculateSAHFn(buildNodes, startIndex, endIndex)
    {
        var buildNode, extents, minX, minY, minZ, maxX, maxY, maxZ;

        buildNode = buildNodes[startIndex];
        extents = buildNode.extents;
        minX = extents[0];
        minY = extents[1];
        minZ = extents[2];
        maxX = extents[3];
        maxY = extents[4];
        maxZ = extents[5];

        for (var n = (startIndex + 1); n < endIndex; n += 1)
        {
            buildNode = buildNodes[n];
            extents = buildNode.extents;
            /*jslint white: false*/
            if (minX > extents[0]) { minX = extents[0]; }
            if (minY > extents[1]) { minY = extents[1]; }
            if (minZ > extents[2]) { minZ = extents[2]; }
            if (maxX < extents[3]) { maxX = extents[3]; }
            if (maxY < extents[4]) { maxY = extents[4]; }
            if (maxZ < extents[5]) { maxZ = extents[5]; }
            /*jslint white: true*/
        }

        return ((maxX - minX) + (maxY - minY) + (maxZ - minZ));
    },

    nthElement : function nthElementFn(nodes, first, nth, last, getkey)
    {
        function medianFn(a, b, c)
        {
            if (a < b)
            {
                if (b < c)
                {
                    return b;
                }
                else if (a < c)
                {
                    return c;
                }
                else
                {
                    return a;
                }
            }
            else if (a < c)
            {
                return a;
            }
            else if (b < c)
            {
                return c;
            }
            return b;
        }

        function insertionSortFn(nodes, first, last, getkey)
        {
            var sorted = (first + 1);
            while (sorted !== last)
            {
                var tempNode = nodes[sorted];
                var tempKey = getkey(tempNode);

                var next = sorted;
                var current = (sorted - 1);

                while (next !== first && tempKey < getkey(nodes[current]))
                {
                    nodes[next] = nodes[current];
                    next -= 1;
                    current -= 1;
                }

                if (next !== sorted)
                {
                    nodes[next] = tempNode;
                }

                sorted += 1;
            }
        }

        while ((last - first) > 8)
        {
            var midValue = medianFn(getkey(nodes[first]),
                                    getkey(nodes[first + parseInt(((last - first) / 2), 10)]),
                                    getkey(nodes[last - 1]));

            var firstPos = first;
            var lastPos  = last;
            var midPos;
            for (; ; firstPos += 1)
            {
                while (getkey(nodes[firstPos]) < midValue)
                {
                    firstPos += 1;
                }

                do
                {
                    lastPos -= 1;
                }
                while (midValue < getkey(nodes[lastPos]));

                if (firstPos >= lastPos)
                {
                    midPos = firstPos;
                    break;
                }
                else
                {
                    var temp = nodes[firstPos];
                    nodes[firstPos] = nodes[lastPos];
                    nodes[lastPos]  = temp;
                }
            }

            if (midPos <= nth)
            {
                first = midPos;
            }
            else
            {
                last = midPos;
            }
        }

        insertionSortFn(nodes, first, last, getkey);
    },

    recursiveBuild : function recursiveBuildFn(buildNodes, startIndex, endIndex, lastNodeIndex)
    {
        var nodes = this.nodes;
        var nodeIndex = lastNodeIndex;
        lastNodeIndex += 1;

        var minX, minY, minZ, maxX, maxY, maxZ, extents;
        var buildNode, lastNode;

        if ((startIndex + this.numNodesLeaf) >= endIndex)
        {
            buildNode = buildNodes[startIndex];
            extents = buildNode.extents;
            minX = extents[0];
            minY = extents[1];
            minZ = extents[2];
            maxX = extents[3];
            maxY = extents[4];
            maxZ = extents[5];

            buildNode.externalNode.aabbTreeIndex = lastNodeIndex;
            nodes[lastNodeIndex] = buildNode;

            for (var n = (startIndex + 1); n < endIndex; n += 1)
            {
                buildNode = buildNodes[n];
                extents = buildNode.extents;
                /*jslint white: false*/
                if (minX > extents[0]) { minX = extents[0]; }
                if (minY > extents[1]) { minY = extents[1]; }
                if (minZ > extents[2]) { minZ = extents[2]; }
                if (maxX < extents[3]) { maxX = extents[3]; }
                if (maxY < extents[4]) { maxY = extents[4]; }
                if (maxZ < extents[5]) { maxZ = extents[5]; }
                /*jslint white: true*/
                lastNodeIndex += 1;
                buildNode.externalNode.aabbTreeIndex = lastNodeIndex;
                nodes[lastNodeIndex] = buildNode;
            }

            lastNode = nodes[lastNodeIndex];
        }
        else
        {
            var splitPosIndex = parseInt(((startIndex + endIndex) / 2), 10);

            if ((startIndex + 1) >= splitPosIndex)
            {
                buildNode = buildNodes[startIndex];
                buildNode.externalNode.aabbTreeIndex = lastNodeIndex;
                nodes[lastNodeIndex] = buildNode;
            }
            else
            {
                this.recursiveBuild(buildNodes, startIndex, splitPosIndex, lastNodeIndex);
            }

            lastNode = nodes[lastNodeIndex];
            extents = lastNode.extents;
            minX = extents[0];
            minY = extents[1];
            minZ = extents[2];
            maxX = extents[3];
            maxY = extents[4];
            maxZ = extents[5];

            lastNodeIndex = (lastNodeIndex + lastNode.escapeNodeOffset);

            if ((splitPosIndex + 1) >= endIndex)
            {
                buildNode = buildNodes[splitPosIndex];
                buildNode.externalNode.aabbTreeIndex = lastNodeIndex;
                nodes[lastNodeIndex] = buildNode;
            }
            else
            {
                this.recursiveBuild(buildNodes, splitPosIndex, endIndex, lastNodeIndex);
            }

            lastNode = nodes[lastNodeIndex];
            extents = lastNode.extents;
            /*jslint white: false*/
            if (minX > extents[0]) { minX = extents[0]; }
            if (minY > extents[1]) { minY = extents[1]; }
            if (minZ > extents[2]) { minZ = extents[2]; }
            if (maxX < extents[3]) { maxX = extents[3]; }
            if (maxY < extents[4]) { maxY = extents[4]; }
            if (maxZ < extents[5]) { maxZ = extents[5]; }
            /*jslint white: true*/
        }

        nodes[nodeIndex] = {
                escapeNodeOffset : (lastNodeIndex - nodeIndex + lastNode.escapeNodeOffset),
                extents : [minX, minY, minZ,
                           maxX, maxY, maxZ]
            };
    },

    getVisibleNodes : function getVisibleNodesFn(planes, visibleNodes)
    {
        if (this.numExternalNodes > 0)
        {
            var nodes = this.nodes;
            var endNodeIndex = this.endNode;
            var numPlanes = planes.length;
            var numVisibleNodes = visibleNodes.length;
            var node, extents, endChildren;
            var n0, n1, n2, p0, p1, p2;
            var isInside, n, plane, d0, d1, d2;
            var nodeIndex = 0;

            for (;;)
            {
                node = nodes[nodeIndex];
                extents = node.extents;
                n0 = extents[0];
                n1 = extents[1];
                n2 = extents[2];
                p0 = extents[3];
                p1 = extents[4];
                p2 = extents[5];
                //isInsidePlanesAABB
                isInside = true;
                n = 0;
                do
                {
                    plane = planes[n];
                    d0 = plane[0];
                    d1 = plane[1];
                    d2 = plane[2];
                    if ((d0 * (d0 < 0 ? n0 : p0) + d1 * (d1 < 0 ? n1 : p1) + d2 * (d2 < 0 ? n2 : p2)) < plane[3])
                    {
                        isInside = false;
                        break;
                    }
                    n += 1;
                }
                while (n < numPlanes);
                if (isInside)
                {
                    if (node.leaf)
                    {
                        visibleNodes[numVisibleNodes] = node.externalNode;
                        numVisibleNodes += 1;
                        nodeIndex += 1;
                        if (nodeIndex >= endNodeIndex)
                        {
                            break;
                        }
                    }
                    else
                    {
                        //isFullyInsidePlanesAABB
                        isInside = true;
                        n = 0;
                        do
                        {
                            plane = planes[n];
                            d0 = plane[0];
                            d1 = plane[1];
                            d2 = plane[2];
                            if ((d0 * (d0 > 0 ? n0 : p0) + d1 * (d1 > 0 ? n1 : p1) + d2 * (d2 > 0 ? n2 : p2)) < plane[3])
                            {
                                isInside = false;
                                break;
                            }
                            n += 1;
                        }
                        while (n < numPlanes);
                        if (isInside)
                        {
                            endChildren = (nodeIndex + node.escapeNodeOffset);
                            nodeIndex += 1;
                            do
                            {
                                node = nodes[nodeIndex];
                                if (node.leaf)
                                {
                                    visibleNodes[numVisibleNodes] = node.externalNode;
                                    numVisibleNodes += 1;
                                }
                                nodeIndex += 1;
                            }
                            while (nodeIndex < endChildren);
                            if (nodeIndex >= endNodeIndex)
                            {
                                break;
                            }
                        }
                        else
                        {
                            nodeIndex += 1;
                        }
                    }
                }
                else
                {
                    nodeIndex += node.escapeNodeOffset;
                    if (nodeIndex >= endNodeIndex)
                    {
                        break;
                    }
                }
            }
        }
    },

    getOverlappingNodes : function getOverlappingNodesFn(queryExtents, overlappingNodes)
    {
        if (this.numExternalNodes > 0)
        {
            var queryMinX = queryExtents[0];
            var queryMinY = queryExtents[1];
            var queryMinZ = queryExtents[2];
            var queryMaxX = queryExtents[3];
            var queryMaxY = queryExtents[4];
            var queryMaxZ = queryExtents[5];
            var nodes = this.nodes;
            var endNodeIndex = this.endNode;
            var node, extents, endChildren;
            var numOverlappingNodes = overlappingNodes.length;
            var nodeIndex = 0;
            for (;;)
            {
                node = nodes[nodeIndex];
                extents = node.extents;
                var minX = extents[0];
                var minY = extents[1];
                var minZ = extents[2];
                var maxX = extents[3];
                var maxY = extents[4];
                var maxZ = extents[5];
                if (queryMinX <= maxX &&
                    queryMinY <= maxY &&
                    queryMinZ <= maxZ &&
                    queryMaxX >= minX &&
                    queryMaxY >= minY &&
                    queryMaxZ >= minZ)
                {
                    if (node.leaf)
                    {
                        overlappingNodes[numOverlappingNodes] = node.externalNode;
                        numOverlappingNodes += 1;
                        nodeIndex += 1;
                        if (nodeIndex >= endNodeIndex)
                        {
                            break;
                        }
                    }
                    else
                    {
                        if (queryMaxX >= maxX &&
                            queryMaxY >= maxY &&
                            queryMaxZ >= maxZ &&
                            queryMinX <= minX &&
                            queryMinY <= minY &&
                            queryMinZ <= minZ)
                        {
                            endChildren = (nodeIndex + node.escapeNodeOffset);
                            nodeIndex += 1;
                            do
                            {
                                node = nodes[nodeIndex];
                                if (node.leaf)
                                {
                                    overlappingNodes[numOverlappingNodes] = node.externalNode;
                                    numOverlappingNodes += 1;
                                }
                                nodeIndex += 1;
                            }
                            while (nodeIndex < endChildren);
                            if (nodeIndex >= endNodeIndex)
                            {
                                break;
                            }
                        }
                        else
                        {
                            nodeIndex += 1;
                        }
                    }
                }
                else
                {
                    nodeIndex += node.escapeNodeOffset;
                    if (nodeIndex >= endNodeIndex)
                    {
                        break;
                    }
                }
            }
        }
    },

    getSphereOverlappingNodes : function getSphereOverlappingNodesFn(center, radius, overlappingNodes)
    {
        if (this.numExternalNodes > 0)
        {
            var radiusSquared = (radius * radius);
            var centerX = center[0];
            var centerY = center[1];
            var centerZ = center[2];
            var nodes = this.nodes;
            var endNodeIndex = this.endNode;
            var node, extents;
            var numOverlappingNodes = overlappingNodes.length;
            var nodeIndex = 0;
            for (;;)
            {
                node = nodes[nodeIndex];
                extents = node.extents;
                var minX = extents[0];
                var minY = extents[1];
                var minZ = extents[2];
                var maxX = extents[3];
                var maxY = extents[4];
                var maxZ = extents[5];
                var totalDistance = 0, sideDistance;
                if (centerX < minX)
                {
                    sideDistance = (minX - centerX);
                    totalDistance += (sideDistance * sideDistance);
                }
                else if (centerX > maxX)
                {
                    sideDistance = (centerX - maxX);
                    totalDistance += (sideDistance * sideDistance);
                }
                if (centerY < minY)
                {
                    sideDistance = (minY - centerY);
                    totalDistance += (sideDistance * sideDistance);
                }
                else if (centerY > maxY)
                {
                    sideDistance = (centerY - maxY);
                    totalDistance += (sideDistance * sideDistance);
                }
                if (centerZ < minZ)
                {
                    sideDistance = (minZ - centerZ);
                    totalDistance += (sideDistance * sideDistance);
                }
                else if (centerZ > maxZ)
                {
                    sideDistance = (centerZ - maxZ);
                    totalDistance += (sideDistance * sideDistance);
                }
                if (totalDistance <= radiusSquared)
                {
                    nodeIndex += 1;
                    if (node.leaf)
                    {
                        overlappingNodes[numOverlappingNodes] = node.externalNode;
                        numOverlappingNodes += 1;
                        if (nodeIndex >= endNodeIndex)
                        {
                            break;
                        }
                    }
                }
                else
                {
                    nodeIndex += node.escapeNodeOffset;
                    if (nodeIndex >= endNodeIndex)
                    {
                        break;
                    }
                }
            }
        }
    },

    getOverlappingPairs : function getOverlappingPairsFn(overlappingPairs)
    {
        if (this.numExternalNodes > 0)
        {
            var nodes = this.nodes;
            var endNodeIndex = this.endNode;
            var currentNode, currentExternalNode, node, extents;
            var numOverlappingPairs = overlappingPairs.length;
            var currentNodeIndex = 0, nodeIndex;
            for (;;)
            {
                currentNode = nodes[currentNodeIndex];
                while (!currentNode.leaf)
                {
                    currentNodeIndex += 1;
                    currentNode = nodes[currentNodeIndex];
                }

                currentNodeIndex += 1;
                if (currentNodeIndex < endNodeIndex)
                {
                    currentExternalNode = currentNode.externalNode;
                    extents = currentNode.extents;
                    var minX = extents[0];
                    var minY = extents[1];
                    var minZ = extents[2];
                    var maxX = extents[3];
                    var maxY = extents[4];
                    var maxZ = extents[5];

                    nodeIndex = currentNodeIndex;
                    for (;;)
                    {
                        node = nodes[nodeIndex];
                        extents = node.extents;
                        if (minX <= extents[3] &&
                            minY <= extents[4] &&
                            minZ <= extents[5] &&
                            maxX >= extents[0] &&
                            maxY >= extents[1] &&
                            maxZ >= extents[2])
                        {
                            nodeIndex += 1;
                            if (node.leaf)
                            {
                                overlappingPairs[numOverlappingPairs] = [currentExternalNode, node.externalNode];
                                numOverlappingPairs += 1;
                                if (nodeIndex >= endNodeIndex)
                                {
                                    break;
                                }
                            }
                        }
                        else
                        {
                            nodeIndex += node.escapeNodeOffset;
                            if (nodeIndex >= endNodeIndex)
                            {
                                break;
                            }
                        }
                    }
                }
                else
                {
                    break;
                }
            }
        }
    },

    getRootNode : function getRootNodeFn()
    {
        return this.nodes[0];
    },

    getNodes : function getNodesFn()
    {
        return this.nodes;
    },

    getEndNodeIndex : function getEndNodeIndexFn()
    {
        return this.endNode;
    },

    clear : function clearFn()
    {
        this.nodes = [];
        this.endNode = 0;
        this.needsRebuild = false;
        this.needsRebound = false;
        this.numAdds = 0;
        this.numUpdates = 0;
        this.numExternalNodes = 0;
        this.startUpdate = Number.MAX_VALUE;
        this.endUpdate = -Number.MAX_VALUE;
    }
};

// Constructor function
AABBTree.create = function aabbtreeCreateFn(highQuality)
{
    var t = new AABBTree();
    t.clear();
    if (highQuality)
    {
        t.highQuality = true;
    }
    return t;
};

// Copyright (c) 2009-2011 Turbulenz Limited

//
// Camera
//
function Camera() {}
Camera.prototype =
{
    version : 1,

    viewOffsetX : 0.0,
    viewOffsetY : 0.0,

    recipViewWindowX : 1.0 / 1.0,
    recipViewWindowY : 1.0 / 1.0,

    infinite : false,
    parallel : false,

    aspectRatio : 4.0 / 3.0,

    nearPlane : 1.0,
    farPlane  : 1000.0,

    lookAt : function lookAtFn(lookAt, up, eyePosition)
    {
        var md = this.md;
        var v3Normalize = md.v3Normalize;
        var v3Cross = md.v3Cross;
        var zaxis = md.v3Sub(eyePosition, lookAt);

        v3Normalize.call(md, zaxis, zaxis);
        var xaxis = v3Cross.call(md, v3Normalize.call(md, up, up), zaxis);
        v3Normalize.call(md, xaxis, xaxis);
        var yaxis = v3Cross.call(md, zaxis, xaxis);
        this.matrix = md.m43Build(xaxis, yaxis, zaxis, eyePosition, this.matrix);
    },

    updateProjectionMatrix : function updateProjectionMatrixFn()
    {
        var rcpvwX = this.recipViewWindowX;
        var rcpvwY = this.recipViewWindowY * this.aspectRatio;
        var shearX = rcpvwX * this.viewOffsetX;
        var shearY = rcpvwY * this.viewOffsetY;
        var far    = this.farPlane;
        var near   = this.nearPlane;

        var rcpfn;
        if (far !== near)
        {
            rcpfn = (1.0 / (far - near));
        }
        else
        {
            rcpfn = 0.0;
        }

        var z0, z1, w0, w1;
        if (this.parallel)
        {
            z0 = -2.0 * rcpfn;
            w0 = (-(far + near) * rcpfn);
            z1 = 0.0;
            w1 = 1.0;
        }
        else
        {
            if (this.infinite)
            {
                z0 = -1.0;
            }
            else
            {
                z0 = (-(far + near) * rcpfn);
                //z0 = (far * rcpfn);
            }

            w0 = -(2.0 * far * near * rcpfn);
            //w0 = (-z0 * near);

            z1 = -1.0;
            w1 = 0.0;
        }

        this.projectionMatrix = this.md.m44Build(rcpvwX,  0.0,     0.0, 0.0,
                                                 0.0,     rcpvwY,  0.0, 0.0,
                                                 -shearX, -shearY,  z0,  z1,
                                                 0.0,     0.0,      w0,  w1,
                                                 this.projectionMatrix);
    },

    updateViewMatrix : function updateViewMatrixFn()
    {
        var md = this.md;
        this.viewMatrix = md.m43InverseOrthonormal(this.matrix, this.viewMatrix);
    },

    updateViewProjectionMatrix : function updateViewProjectionMatrixFn()
    {
        var md = this.md;
        this.viewProjectionMatrix = md.m43MulM44(this.viewMatrix, this.projectionMatrix, this.viewProjectionMatrix);
    },

    extractFrustumPlanes : function extractFrustumPlanesFn(m, p)
    {
        var md = this.md;
        var m0  = m[0];
        var m1  = m[1];
        var m2  = m[2];
        var m3  = m[3];
        var m4  = m[4];
        var m5  = m[5];
        var m6  = m[6];
        var m7  = m[7];
        var m8  = m[8];
        var m9  = m[9];
        var m10 = m[10];
        var m11 = m[11];
        var m12 = m[12];
        var m13 = m[13];
        var m14 = m[14];
        var m15 = m[15];
        var planes = (p || []);

        // Negate 'd' here to avoid doing it on the isVisible functions
        var vec = md.v4Build((m3  + m0), (m7  + m4), (m11 + m8), -(m15 + m12));
        planes[0] = md.planeNormalize(vec); // left

        md.v4Build((m3  - m0), (m7  - m4), (m11 - m8), -(m15 - m12), vec);
        planes[1] = md.planeNormalize(vec); // right

        md.v4Build((m3  - m1), (m7  - m5), (m11 - m9),  -(m15 - m13), vec);
        planes[2] = md.planeNormalize(vec); // top

        md.v4Build((m3  + m1), (m7  + m5), (m11 + m9),  -(m15 + m13), vec);
        planes[3] = md.planeNormalize(vec); // bottom

        md.v4Build((m3  + m2), (m7  + m6), (m11 + m10), -(m15 + m14), vec);
        planes[4] = md.planeNormalize(vec);  // near

        md.v4Build((m3  - m2), (m7  - m6), (m11 - m10), -(m15 - m14), vec);
        planes[5] = md.planeNormalize(vec); // far

        return planes;
    },

    updateFrustumPlanes : function updateFrustumPlanesFn()
    {
        this.frustumPlanes = this.extractFrustumPlanes(this.viewProjectionMatrix, this.frustumPlanes);
    },

    isVisiblePoint : function isVisiblePointFn(p)
    {
        var md = this.md;
        return md.isInsidePlanesPoint(p, this.frustumPlanes);
    },

    isVisibleSphere : function isVisibleSphereFn(c, r)
    {
        var md = this.md;
        return md.isInsidePlanesSphere(c, r, this.frustumPlanes);
    },

    isVisibleBox : function isVisibleBoxFn(c, h)
    {
        var md = this.md;
        return md.isInsidePlanesBox(c, h, this.frustumPlanes);
    },

    isVisibleAABB : function isVisibleAABBFn(extents)
    {
        var md = this.md;
        return md.aabbIsInsidePlanes(extents, this.frustumPlanes);
    },

    isFullyInsideAABB : function isFullyInsideAABBFn(extents)
    {
        var md = this.md;
        return md.aabbIsFullyInsidePlanes(extents, this.frustumPlanes);
    },

    getFrustumPoints : function getFrustumPointsFn()
    {
        var viewOffsetX = this.viewOffsetX;
        var viewOffsetY = this.viewOffsetY;

        var viewWindowX = 1.0 / this.recipViewWindowX;
        var viewWindowY = 1.0 / (this.recipViewWindowY * this.aspectRatio);

        var transform = this.matrix;

        var farClip  = this.farPlane;
        var nearClip = this.nearPlane;

        var frustumPoints = [];

        if (!this.parallel)
        {
            var co0 = ((transform[0] * viewOffsetX) + (transform[3] * viewOffsetY));
            var co1 = ((transform[1] * viewOffsetX) + (transform[4] * viewOffsetY));
            var co2 = ((transform[2] * viewOffsetX) + (transform[5] * viewOffsetY));

            var right0 = (transform[0] * viewWindowX);
            var right1 = (transform[1] * viewWindowX);
            var right2 = (transform[2] * viewWindowX);
            var up0    = (transform[3] * viewWindowY);
            var up1    = (transform[4] * viewWindowY);
            var up2    = (transform[5] * viewWindowY);
            var at0    = (co0 - transform[6]);
            var at1    = (co1 - transform[7]);
            var at2    = (co2 - transform[8]);
            var pos0   = (transform[9]  + co0);
            var pos1   = (transform[10] + co1);
            var pos2   = (transform[11] + co2);

            var dirTR0 = (at0 + right0 + up0);
            var dirTR1 = (at1 + right1 + up1);
            var dirTR2 = (at2 + right2 + up2);
            var dirTL0 = (at0 - right0 + up0);
            var dirTL1 = (at1 - right1 + up1);
            var dirTL2 = (at2 - right2 + up2);
            var dirBL0 = (at0 - right0 - up0);
            var dirBL1 = (at1 - right1 - up1);
            var dirBL2 = (at2 - right2 - up2);
            var dirBR0 = (at0 + right0 - up0);
            var dirBR1 = (at1 + right1 - up1);
            var dirBR2 = (at2 + right2 - up2);

            frustumPoints[0] = [(pos0 + (dirTR0 * nearClip)), (pos1 + (dirTR1 * nearClip)), (pos2 + (dirTR2 * nearClip))];
            frustumPoints[4] = [(pos0 + (dirTR0 * farClip)),  (pos1 + (dirTR1 * farClip)),  (pos2 + (dirTR2 * farClip))];
            frustumPoints[1] = [(pos0 + (dirTL0 * nearClip)), (pos1 + (dirTL1 * nearClip)), (pos2 + (dirTL2 * nearClip))];
            frustumPoints[5] = [(pos0 + (dirTL0 * farClip)),  (pos1 + (dirTL1 * farClip)),  (pos2 + (dirTL2 * farClip))];
            frustumPoints[2] = [(pos0 + (dirBL0 * nearClip)), (pos1 + (dirBL1 * nearClip)), (pos2 + (dirBL2 * nearClip))];
            frustumPoints[6] = [(pos0 + (dirBL0 * farClip)),  (pos1 + (dirBL1 * farClip)),  (pos2 + (dirBL2 * farClip))];
            frustumPoints[3] = [(pos0 + (dirBR0 * nearClip)), (pos1 + (dirBR1 * nearClip)), (pos2 + (dirBR2 * nearClip))];
            frustumPoints[7] = [(pos0 + (dirBR0 * farClip)),  (pos1 + (dirBR1 * farClip)),  (pos2 + (dirBR2 * farClip))];
        }
        else
        {
            frustumPoints[0] = [];
            frustumPoints[4] = [];
            frustumPoints[1] = [];
            frustumPoints[5] = [];
            frustumPoints[2] = [];
            frustumPoints[6] = [];
            frustumPoints[3] = [];
            frustumPoints[7] = [];

            frustumPoints[0][2] = nearClip;
            frustumPoints[1][2] = nearClip;
            frustumPoints[2][2] = nearClip;
            frustumPoints[3][2] = nearClip;

            frustumPoints[4][2] = farClip;
            frustumPoints[5][2] = farClip;
            frustumPoints[6][2] = farClip;
            frustumPoints[7][2] = farClip;

            var offset = (1.0 - nearClip) * viewOffsetX;
            frustumPoints[0][0] = (viewWindowX + offset);
            frustumPoints[1][0] = (offset - viewWindowX);
            frustumPoints[2][0] = (offset - viewWindowX);
            frustumPoints[3][0] = (viewWindowX + offset);

            offset = (1.0 - farClip) * viewOffsetX;
            frustumPoints[4][0] = (viewWindowX + offset);
            frustumPoints[5][0] = (offset - viewWindowX);
            frustumPoints[6][0] = (offset - viewWindowX);
            frustumPoints[7][0] = (viewWindowX + offset);

            offset = (1.0 - nearClip) * viewOffsetY;
            frustumPoints[0][1] = (viewWindowY + offset);
            frustumPoints[1][1] = (viewWindowY + offset);
            frustumPoints[2][1] = (offset - viewWindowY);
            frustumPoints[3][1] = (offset - viewWindowY);

            offset = (1.0 - farClip) * viewOffsetY;
            frustumPoints[4][1] = (viewWindowY + offset);
            frustumPoints[5][1] = (viewWindowY + offset);
            frustumPoints[6][1] = (offset - viewWindowY);
            frustumPoints[7][1] = (offset - viewWindowY);

            var md = this.md;
            frustumPoints[0] = md.m43TransformPoint(transform, frustumPoints[0]);
            frustumPoints[1] = md.m43TransformPoint(transform, frustumPoints[1]);
            frustumPoints[2] = md.m43TransformPoint(transform, frustumPoints[2]);
            frustumPoints[3] = md.m43TransformPoint(transform, frustumPoints[3]);
            frustumPoints[4] = md.m43TransformPoint(transform, frustumPoints[4]);
            frustumPoints[5] = md.m43TransformPoint(transform, frustumPoints[5]);
            frustumPoints[6] = md.m43TransformPoint(transform, frustumPoints[6]);
            frustumPoints[7] = md.m43TransformPoint(transform, frustumPoints[7]);
        }

        return frustumPoints;
    },

    getFrustumFarPoints : function getFrustumFarPointsFn()
    {
        var viewOffsetX = this.viewOffsetX;
        var viewOffsetY = this.viewOffsetY;
        var viewWindowX = 1.0 / this.recipViewWindowX;
        var viewWindowY = 1.0 / (this.recipViewWindowY * this.aspectRatio);
        var transform   = this.matrix;
        var farClip     = this.farPlane;

        var frustumPoints;

        if (!this.parallel)
        {
            var t0  = transform[0];
            var t1  = transform[1];
            var t2  = transform[2];
            var t3  = transform[3];
            var t4  = transform[4];
            var t5  = transform[5];
            var t6  = transform[6];
            var t7  = transform[7];
            var t8  = transform[8];
            var t9  = transform[9];
            var t10 = transform[10];
            var t11 = transform[11];

            var co0 = ((t0 * viewOffsetX) + (t3 * viewOffsetY));
            var co1 = ((t1 * viewOffsetX) + (t4 * viewOffsetY));
            var co2 = ((t2 * viewOffsetX) + (t5 * viewOffsetY));

            var right0 = (t0  * viewWindowX);
            var right1 = (t1  * viewWindowX);
            var right2 = (t2  * viewWindowX);
            var up0    = (t3  * viewWindowY);
            var up1    = (t4  * viewWindowY);
            var up2    = (t5  * viewWindowY);
            var at0    = (co0 - t6);
            var at1    = (co1 - t7);
            var at2    = (co2 - t8);
            var pos0   = (t9  + co0);
            var pos1   = (t10 + co1);
            var pos2   = (t11 + co2);

            var dirTR0 = ((at0 + right0 + up0) * farClip);
            var dirTR1 = ((at1 + right1 + up1) * farClip);
            var dirTR2 = ((at2 + right2 + up2) * farClip);
            var dirTL0 = ((at0 - right0 + up0) * farClip);
            var dirTL1 = ((at1 - right1 + up1) * farClip);
            var dirTL2 = ((at2 - right2 + up2) * farClip);
            var dirBL0 = ((at0 - right0 - up0) * farClip);
            var dirBL1 = ((at1 - right1 - up1) * farClip);
            var dirBL2 = ((at2 - right2 - up2) * farClip);
            var dirBR0 = ((at0 + right0 - up0) * farClip);
            var dirBR1 = ((at1 + right1 - up1) * farClip);
            var dirBR2 = ((at2 + right2 - up2) * farClip);

            frustumPoints = [ [(pos0 + dirTR0), (pos1 + dirTR1), (pos2 + dirTR2)],
                              [(pos0 + dirTL0), (pos1 + dirTL1), (pos2 + dirTL2)],
                              [(pos0 + dirBL0), (pos1 + dirBL1), (pos2 + dirBL2)],
                              [(pos0 + dirBR0), (pos1 + dirBR1), (pos2 + dirBR2)] ];
        }
        else
        {
            var offsetX = (1.0 - farClip) * viewOffsetX;
            var offsetY = (1.0 - farClip) * viewOffsetY;
            var md = this.md;
            frustumPoints = [ md.m43TransformPoint(transform, [(viewWindowX + offsetX), (viewWindowY + offsetY), farClip]),
                              md.m43TransformPoint(transform, [(offsetX - viewWindowX), (viewWindowY + offsetY), farClip]),
                              md.m43TransformPoint(transform, [(offsetX - viewWindowX), (offsetY - viewWindowY), farClip]),
                              md.m43TransformPoint(transform, [(viewWindowX + offsetX), (offsetY - viewWindowY), farClip]) ];
        }

        return frustumPoints;
    },

    getFrustumExtents : function getFrustumExtentsFn(extents)
    {
        var frustumPoints = this.getFrustumPoints();
        var frustumPoint = frustumPoints[0];
        var min0 = frustumPoint[0];
        var min1 = frustumPoint[1];
        var min2 = frustumPoint[2];
        var max0 = min0;
        var max1 = min1;
        var max2 = min2;
        for (var i = 1; i < 8; i += 1)
        {
            frustumPoint = frustumPoints[i];
            var p0 = frustumPoint[0];
            var p1 = frustumPoint[1];
            var p2 = frustumPoint[2];
            if (min0 > p0)
            {
                min0 = p0;
            }
            else if (max0 < p0)
            {
                max0 = p0;
            }
            if (min1 > p1)
            {
                min1 = p1;
            }
            else if (max1 < p1)
            {
                max1 = p1;
            }
            if (min2 > p2)
            {
                min2 = p2;
            }
            else if (max2 < p2)
            {
                max2 = p2;
            }
        }
        extents[0] = min0;
        extents[1] = min1;
        extents[2] = min2;
        extents[3] = max0;
        extents[4] = max1;
        extents[5] = max2;
    }
};

// Constructor function
Camera.create = function cameraCreateFn(md)
{
    var c = new Camera();
    c.md = md;
    c.matrix = md.m43BuildIdentity();
    c.viewMatrix = md.m43BuildIdentity();
    c.updateProjectionMatrix();
    c.viewProjectionMatrix = c.projectionMatrix.slice();
    c.frustumPlanes = [];
    c.updateFrustumPlanes();
    return c;
};

//
// CameraController
//
function CameraController() {}
CameraController.prototype =
{
    version : 1,

    rotateSpeed       : 2.0,
    maxSpeed          : 1,
    mouseRotateFactor : 0.1,

    rotate : function rotateFn(turn, pitch)
    {
        var degreestoradians = (Math.PI / 180.0);
        var md = this.md;
        var matrix = this.camera.matrix;
        var pos = md.m43Pos(matrix);
        md.m43SetPos(matrix, md.v3BuildZero());

        var rotate;
        if (pitch !== 0.0)
        {
            pitch *= this.rotateSpeed * degreestoradians;
            pitch *= this.mouseRotateFactor;

            var right = md.v3Normalize(md.m43Right(matrix));
            md.m43SetRight(matrix, right);

            rotate = md.m43FromAxisRotation(right, pitch);

            matrix = md.m43Mul(matrix, rotate);
        }

        if (turn !== 0.0)
        {
            turn *= this.rotateSpeed * degreestoradians;
            turn *= this.mouseRotateFactor;

            rotate = md.m43FromAxisRotation(md.v3BuildYAxis(), turn);

            matrix = md.m43Mul(matrix, rotate);
        }

        md.m43SetPos(matrix, pos);

        this.camera.matrix = matrix;
    },

    translate : function translateFn(right, up, forward)
    {
        var md = this.md;
        var matrix = this.camera.matrix;
        var pos = md.m43Pos(matrix);
        var speed = this.maxSpeed;
        pos = md.v3Add4(pos,
                        md.v3ScalarMul(md.m43Right(matrix), (speed * right)),
                        md.v3ScalarMul(md.m43Up(matrix),    (speed * up)),
                        md.v3ScalarMul(md.m43At(matrix),   -(speed * forward)));
        md.m43SetPos(matrix, pos);
    },

    update : function cameraControllerUpdateFn()
    {
        var updateMatrix = false;

        if (this.turn !== 0.0 ||
            this.pitch !== 0.0)
        {
            updateMatrix = true;

            this.rotate(this.turn, this.pitch);

            this.turn = 0.0;
            this.pitch = 0.0;
        }

        if (this.step > 0)
        {
            this.forward += this.step;
        }
        else if (this.step < 0)
        {
            this.backward -= this.step;
        }

        var right = ((this.right + this.padright) - (this.left + this.padleft));
        var up = this.up - this.down;
        var forward = ((this.forward + this.padforward) - (this.backward + this.padbackward));
        if (right !== 0.0 ||
            up !== 0.0 ||
            forward !== 0.0)
        {
            updateMatrix = true;

            this.translate(right, up, forward);

            if (this.step > 0)
            {
                this.forward -= this.step;
                this.step = 0.0;
            }
            else if (this.step < 0)
            {
                this.backward += this.step;
                this.step = 0.0;
            }
        }

        if (updateMatrix)
        {
            this.camera.updateViewMatrix();
        }
    }
};

// Constructor function
CameraController.create = function cameraControllerCreateFn(gd, id, camera, log)
{
    var c = new CameraController();

    c.md = camera.md;
    c.camera = camera;
    c.turn = 0.0;
    c.pitch = 0.0;
    c.right = 0.0;
    c.left = 0.0;
    c.up = 0.0;
    c.down = 0.0;
    c.forward = 0.0;
    c.backward = 0.0;
    c.step = 0.0;
    c.padright = 0.0;
    c.padleft = 0.0;
    c.padforward = 0.0;
    c.padbackward = 0.0;

    var keyCodes;

    if (id)
    {
        keyCodes = id.keyCodes;
    }

    // keyboard handling
    function onkeydownFn(keynum)
    {
        switch (keynum)
        {
        case keyCodes.A:
        case keyCodes.LEFT:
        case keyCodes.NUMPAD_4:
            c.left = 1.0;
            break;

        case keyCodes.D:
        case keyCodes.RIGHT:
        case keyCodes.NUMPAD_6:
            c.right = 1.0;
            break;

        case keyCodes.W:
        case keyCodes.UP:
        case keyCodes.NUMPAD_8:
            c.forward = 1.0;
            break;

        case keyCodes.S:
        case keyCodes.DOWN:
        case keyCodes.NUMPAD_2:
            c.backward = 1.0;
            break;

        case keyCodes.E:
        case keyCodes.NUMPAD_9:
            c.up = 1.0;
            break;

        case keyCodes.Q:
        case keyCodes.NUMPAD_7:
            c.down = 1.0;
            break;
        }
    }

    function onkeyupFn(keynum)
    {
        switch (keynum)
        {
        case keyCodes.A:
        case keyCodes.LEFT:
        case keyCodes.NUMPAD_4:
            c.left = 0.0;
            break;

        case keyCodes.D:
        case keyCodes.RIGHT:
        case keyCodes.NUMPAD_6:
            c.right = 0.0;
            break;

        case keyCodes.W:
        case keyCodes.UP:
        case keyCodes.NUMPAD_8:
            c.forward = 0.0;
            break;

        case keyCodes.S:
        case keyCodes.DOWN:
        case keyCodes.NUMPAD_2:
            c.backward = 0.0;
            break;

        case keyCodes.E:
        case keyCodes.NUMPAD_9:
            c.up = 0.0;
            break;

        case keyCodes.Q:
        case keyCodes.NUMPAD_7:
            c.down = 0.0;
            break;

        case keyCodes.RETURN:
            gd.fullscreen = !gd.fullscreen;
            break;
        }
    }

    if (log)
    {
        c.onkeydown = function onkeydownLogFn(keynum)
        {
            log.innerHTML += " KeyDown:&nbsp;" + keynum;
            onkeydownFn(keynum);
        };

        c.onkeyup = function onkeyupLogFn(keynum)
        {
            if (keynum === keyCodes.BACKSPACE)
            {
                log.innerHTML = "";
            }
            else
            {
                log.innerHTML += " KeyUp:&nbsp;" + keynum;
            }
            onkeyupFn(keynum);
        };
    }
    else
    {
        c.onkeydown = onkeydownFn;
        c.onkeyup = onkeyupFn;
    }

    // Mouse handling
    c.onmouseup = function onmouseupFn(button, x, y)
    {
        if (!id.isLocked())
        {
            id.lockMouse();
        }
    };

    c.onmousewheel = function onmousewheelFn(delta)
    {
        c.step = delta * 5;
    };

    c.onmousemove = function onmousemoveFn(deltaX, deltaY)
    {
        c.turn  += deltaX;
        c.pitch += deltaY;
    };

    // Pad handling
    c.onpadmove = function onpadmoveFn(lX, lY, lZ, rX, rY, rZ, dpadState)
    {
        c.turn  += lX * 10.0;
        c.pitch += lY * 10.0;

        if (rX >= 0)
        {
            c.padright = rX;
            c.padleft  = 0;
        }
        else
        {
            c.padright = 0;
            c.padleft  = -rX;
        }

        if (rY >= 0)
        {
            c.padforward  = rY;
            c.padbackward = 0.0;
        }
        else
        {
            c.padforward  = 0.0;
            c.padbackward = -rY;
        }
    };

    c.onmouselocklost = function onmouselocklostFn()
    {
        id.unlockMouse();
    };

    // Attach to an InputDevice
    c.attach = function attachFn(id)
    {
        id.addEventListener('keydown', c.onkeydown);
        id.addEventListener('keyup', c.onkeyup);
        id.addEventListener('mouseup', c.onmouseup);
        id.addEventListener('mousewheel', c.onmousewheel);
        id.addEventListener('mousemove', c.onmousemove);
        id.addEventListener('padmove', c.onpadmove);
        id.addEventListener('mouselocklost', c.onmouselocklost);
    };

    if (id)
    {
        c.attach(id);
    }

    return c;
};

// Copyright (c) 2012 Turbulenz Limited

//
// SimpleRendering
//
/*global renderingCommonCreateRendererInfoFn: false,  renderingCommonGetTechniqueIndexFn: false
         renderingCommonSortKeyFn: false */
/*global TurbulenzEngine: false */
/*global Effect: false */

function SimpleRendering() {}

SimpleRendering.numPasses = 3;
SimpleRendering.passIndex =  { opaque: 0, decal: 1, transparent: 2 };

SimpleRendering.prototype =
{
    version : 1,

    updateShader: function simpleRenderingUpdateShaderFn(sm)
    {
    },

    sortRenderablesAndLights: function simpleRenderingSortRenderablesAndLightsFn(camera, scene)
    {
        var index;
        var passes = this.passes;
        var numPasses = SimpleRendering.numPasses;
        for (index = 0; index < numPasses; index += 1)
        {
            passes[index] = [];
        }

        var drawParametersArray;
        var numDrawParameters;
        var drawParameters;
        var drawParametersIndex;

        var visibleRenderables = scene.getCurrentVisibleRenderables();
        var numVisibleRenderables = visibleRenderables.length;
        if (numVisibleRenderables > 0)
        {
            var renderable, meta, pass, passIndex;
            var transparent = SimpleRendering.passIndex.transparent;
            var n = 0;
            do
            {
                renderable = visibleRenderables[n];

                var rendererInfo = renderable.rendererInfo;
                if (!rendererInfo)
                {
                    rendererInfo = renderingCommonCreateRendererInfoFn(renderable);
                }

                meta = renderable.sharedMaterial.meta;

                if (meta.far)
                {
                    renderable.distance = 1.e38;
                }

                rendererInfo.renderUpdate.call(renderable, camera);

                drawParametersArray = renderable.drawParameters;
                numDrawParameters = drawParametersArray.length;
                for (drawParametersIndex = 0; drawParametersIndex < numDrawParameters; drawParametersIndex += 1)
                {
                    drawParameters = drawParametersArray[drawParametersIndex];
                    passIndex = drawParameters.userData.passIndex;
                    if (passIndex === transparent)
                    {
                        drawParameters.sortKey = renderable.distance;
                    }
                    pass = passes[passIndex];
                    pass[pass.length] = drawParameters;
                }

                // this renderer does not care about lights

                n += 1;
            }
            while (n < numVisibleRenderables);

        }
    },

    update: function simpleRenderingUpdateFn(gd, camera, scene, currentTime)
    {
        scene.updateVisibleNodes(camera);

        this.sortRenderablesAndLights(camera, scene);

        this.eyePosition = this.md.m43Pos(camera.matrix, this.eyePosition);
        this.globalTechniqueParameters.time = currentTime;
        this.camera = camera;
        this.scene = scene;
    },

    updateBuffers: function simpleRenderingUpdateBuffersFn(gd, deviceWidth, deviceHeight)
    {
        return true;
    },

    draw: function simpleRenderingDrawFn(gd,
                                         clearColor,
                                         drawDecalsFn,
                                         drawTransparentFn,
                                         drawDebugFn)
    {
        var globalTechniqueParameters = this.globalTechniqueParameters;
        var globalTechniqueParametersArray = [globalTechniqueParameters];

        gd.clear(clearColor, 1.0, 0);

        if (this.wireframe)
        {
            this.scene.drawWireframe(gd, this.sm, this.camera, this.wireframeInfo);

            if (drawDecalsFn)
            {
                drawDecalsFn();
            }

            if (drawTransparentFn)
            {
                drawTransparentFn();
            }
        }
        else
        {

            gd.drawArray(this.passes[SimpleRendering.passIndex.opaque], globalTechniqueParametersArray, -1);

            gd.drawArray(this.passes[SimpleRendering.passIndex.decal], globalTechniqueParametersArray, -1);

            if (drawDecalsFn)
            {
                drawDecalsFn();
            }

            gd.drawArray(this.passes[SimpleRendering.passIndex.transparent], globalTechniqueParametersArray, 1);

            if (drawTransparentFn)
            {
                drawTransparentFn();
            }
        }

        if (drawDebugFn)
        {
            drawDebugFn();
        }

        this.lightPositionUpdated = false;
    },


    setGlobalLightPosition: function simpleRenderingSetGlobalLightPositionFn(pos)
    {
        this.lightPositionUpdated = true;
        this.lightPosition = pos;
    },

    setGlobalLightColor: function simpleRenderingSetGlobalLightColorFn(color)
    {
        this.globalTechniqueParameters.lightColor = color;
    },

    setAmbientColor: function simpleRenderingSetAmbientColorFn(color)
    {
        this.globalTechniqueParameters.ambientColor = color;
    },

    setDefaultTexture: function simpleRenderingSetDefaultTextureFn(tex)
    {
        this.globalTechniqueParameters.diffuse = tex;
    },

    setWireframe: function simpleRenderingSetWireframe(wireframeEnabled, wireframeInfo)
    {
        this.wireframeInfo = wireframeInfo;
        this.wireframe = wireframeEnabled;
    },

    destroy: function destroyFn()
    {
        delete this.globalTechniqueParameters;
        delete this.lightPosition;
        delete this.eyePosition;
        delete this.passes;
    }
};

//
// simplePrepareFn
//
SimpleRendering.simplePrepareFn = function simplePrepareFn(geometryInstance)
{
    var drawParameters = TurbulenzEngine.getGraphicsDevice().createDrawParameters();
    drawParameters.userData = {};
    geometryInstance.drawParameters = [drawParameters];
    geometryInstance.prepareDrawParameters(drawParameters);

    var sharedMaterial = geometryInstance.sharedMaterial;

    drawParameters.technique = this.technique;

    drawParameters.setTechniqueParameters(0, sharedMaterial.techniqueParameters);
    drawParameters.setTechniqueParameters(1, geometryInstance.techniqueParameters);

    if (sharedMaterial.meta.decal)
    {
        drawParameters.userData.passIndex = SimpleRendering.passIndex.decal;
    }
    else if (sharedMaterial.meta.transparent)
    {
        drawParameters.userData.passIndex = SimpleRendering.passIndex.transparent;
    }
    else
    {
        drawParameters.userData.passIndex = SimpleRendering.passIndex.opaque;
    }

    drawParameters.sortKey = renderingCommonSortKeyFn(this.techniqueIndex, sharedMaterial.meta.materialIndex);

    geometryInstance.rendererInfo.renderUpdate = this.update;
};

//
// Constructor function
//
SimpleRendering.create = function simpleRenderingCreateFn(gd, md, shaderManager, effectsManager)
{
    var dr = new SimpleRendering();

    dr.md = md;
    dr.sm = shaderManager;

    dr.lightPositionUpdated = true;
    dr.lightPosition = md.v3Build(1000.0, 1000.0, 0.0);

    dr.eyePosition = md.v3Build(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);

    dr.globalTechniqueParameters = gd.createTechniqueParameters({
            lightColor : md.v3BuildOne(),
            ambientColor : md.v3Build(0.2, 0.2, 0.3),
            time : 0.0
        });

    dr.passes = [[], [], []];

    var simpleCGFX = 'shaders/simplerendering.cgfx';
    var debugCGFX = 'shaders/debug.cgfx';

    shaderManager.load(simpleCGFX);
    shaderManager.load(debugCGFX);

    // Prepare effects
    var m43MulM44 = md.m43MulM44;
    var m43Inverse = md.m43Inverse;
    var m43TransformPoint = md.m43TransformPoint;
    var m33Transpose = md.m33Transpose;
    var m33InverseTranspose = md.m33InverseTranspose;

    function simpleUpdateFn(camera)
    {
        var techniqueParameters = this.techniqueParameters;
        var node = this.node;
        var matrix = node.world;
        var worldUpdate = node.worldUpdate;

        var lightPositionUpdated, worldInverse;

        techniqueParameters.worldViewProjection = m43MulM44.call(md, matrix, camera.viewProjectionMatrix, techniqueParameters.worldViewProjection);

        if (this.techniqueParametersUpdated !== worldUpdate)
        {
            this.techniqueParametersUpdated = worldUpdate;
            this.worldInverse = worldInverse = m43Inverse.call(md, matrix, worldInverse);
            lightPositionUpdated = true;
        }
        else
        {
            lightPositionUpdated = dr.lightPositionUpdated;
            worldInverse = this.worldInverse;
        }

        if (lightPositionUpdated)
        {
            techniqueParameters.lightPosition = m43TransformPoint.call(md,
                                                                       worldInverse,
                                                                       dr.lightPosition,
                                                                       techniqueParameters.lightPosition);
        }

        techniqueParameters.eyePosition = m43TransformPoint.call(md,
                                                                 worldInverse,
                                                                 dr.eyePosition,
                                                                 techniqueParameters.eyePosition);
    }

    function simpleSkinnedUpdateFn(camera)
    {
        var techniqueParameters = this.techniqueParameters;
        var node = this.node;
        var matrix = node.world;
        var worldUpdate = node.worldUpdate;

        var lightPositionUpdated, worldInverse;

        techniqueParameters.worldViewProjection = m43MulM44.call(md, matrix, camera.viewProjectionMatrix, techniqueParameters.worldViewProjection);

        if (this.techniqueParametersUpdated !== worldUpdate)
        {
            this.techniqueParametersUpdated = worldUpdate;
            this.worldInverse = worldInverse = m43Inverse.call(md, matrix, worldInverse);
            lightPositionUpdated = true;
        }
        else
        {
            lightPositionUpdated = dr.lightPositionUpdated;
            worldInverse = this.worldInverse;
        }

        if (lightPositionUpdated)
        {
            techniqueParameters.lightPosition = m43TransformPoint.call(md,
                                                                       worldInverse,
                                                                       dr.lightPosition,
                                                                       techniqueParameters.lightPosition);
        }

        techniqueParameters.eyePosition = m43TransformPoint.call(md,
                                                                 worldInverse,
                                                                 dr.eyePosition,
                                                                 techniqueParameters.eyePosition);

        var skinController = this.skinController;
        if (skinController)
        {
            techniqueParameters.skinBones = skinController.output;
            skinController.update();
        }
    }

    function simpleNoLightUpdateFn(camera)
    {
        var techniqueParameters = this.techniqueParameters;
        techniqueParameters.worldViewProjection = m43MulM44.call(md, this.node.world, camera.viewProjectionMatrix, techniqueParameters.worldViewProjection);
    }

    function simpleNoLightSkinnedUpdateFn(camera)
    {
        var techniqueParameters = this.techniqueParameters;
        techniqueParameters.worldViewProjection = m43MulM44.call(md, this.node.world, camera.viewProjectionMatrix, techniqueParameters.worldViewProjection);
        var skinController = this.skinController;
        if (skinController)
        {
            techniqueParameters.skinBones = skinController.output;
            skinController.update();
        }
    }

    function simpleDebugNormalsUpdateFn(camera)
    {
        var techniqueParameters = this.techniqueParameters;
        var node = this.node;
        var matrix = node.world;
        var worldUpdate = node.worldUpdate;

        techniqueParameters.worldViewProjection = m43MulM44.call(md, matrix, camera.viewProjectionMatrix, techniqueParameters.worldViewProjection);
        if (this.techniqueParametersUpdated !== worldUpdate)
        {
            this.techniqueParametersUpdated = worldUpdate;
            techniqueParameters.worldInverseTranspose = m33InverseTranspose.call(md, matrix, techniqueParameters.worldInverseTranspose);
        }
    }

    function simpleDebugNormalsSkinnedUpdateFn(camera)
    {
        var techniqueParameters = this.techniqueParameters;
        var node = this.node;
        var matrix = node.world;
        var worldUpdate = node.worldUpdate;

        techniqueParameters.worldViewProjection = m43MulM44.call(md, matrix, camera.viewProjectionMatrix, techniqueParameters.worldViewProjection);
        if (this.techniqueParametersUpdated !== worldUpdate)
        {
            this.techniqueParametersUpdated = worldUpdate;
            techniqueParameters.worldInverseTranspose = m33InverseTranspose.call(md, matrix, techniqueParameters.worldInverseTranspose);
        }
        var skinController = this.skinController;
        if (skinController)
        {
            techniqueParameters.skinBones = skinController.output;
            skinController.update();
        }
    }

    function simpleEnvUpdateFn(camera)
    {
        var techniqueParameters = this.techniqueParameters;
        var node = this.node;
        var matrix = node.world;
        var worldUpdate = node.worldUpdate;

        var worldInverse;

        techniqueParameters.worldViewProjection = m43MulM44.call(md, matrix, camera.viewProjectionMatrix, techniqueParameters.worldViewProjection);

        if (this.techniqueParametersUpdated !== worldUpdate)
        {
            this.techniqueParametersUpdated = worldUpdate;
            this.worldInverse = worldInverse = m43Inverse.call(md, matrix, worldInverse);
            techniqueParameters.worldInverseTranspose = m33Transpose.call(md, worldInverse, techniqueParameters.worldInverseTranspose);
        }
        else
        {
            worldInverse = this.worldInverse;
        }

        techniqueParameters.eyePosition = m43TransformPoint.call(md,
                                                                 worldInverse,
                                                                 dr.eyePosition,
                                                                 techniqueParameters.eyePosition);
    }

    function simpleEnvSkinnedUpdateFn(camera)
    {
        var techniqueParameters = this.techniqueParameters;
        var node = this.node;
        var matrix = node.world;
        var worldUpdate = node.worldUpdate;

        var worldInverse;

        techniqueParameters.worldViewProjection = m43MulM44.call(md, matrix, camera.viewProjectionMatrix, techniqueParameters.worldViewProjection);

        if (this.techniqueParametersUpdated !== worldUpdate)
        {
            this.techniqueParametersUpdated = worldUpdate;
            this.worldInverse = worldInverse = m43Inverse.call(md, matrix, worldInverse);
            techniqueParameters.worldInverseTranspose = m33Transpose.call(md, worldInverse, techniqueParameters.worldInverseTranspose);
        }
        else
        {
            worldInverse = this.worldInverse;
        }

        techniqueParameters.eyePosition = m43TransformPoint.call(md,
                                                                 worldInverse,
                                                                 dr.eyePosition,
                                                                 techniqueParameters.eyePosition);

        var skinController = this.skinController;
        if (skinController)
        {
            techniqueParameters.skinBones = skinController.output;
            skinController.update();
        }
    }

    function debugLinesPrepareFn(geometryInstance)
    {
        SimpleRendering.simplePrepareFn.call(this, geometryInstance);
        var techniqueParameters = geometryInstance.techniqueParameters;
        techniqueParameters.constantColor = geometryInstance.sharedMaterial.meta.constantColor;
    }

    function simplePrepareFn(geometryInstance)
    {
        SimpleRendering.simplePrepareFn.call(this, geometryInstance);
        //For untextured objects we need to choose a technique that uses materialColor instead.
        var techniqueParameters = geometryInstance.sharedMaterial.techniqueParameters;
        var diffuse = techniqueParameters.diffuse;
        if (diffuse === undefined)
        {
            if (!techniqueParameters.materialColor)
            {
                techniqueParameters.materialColor = md.v4BuildOne();
            }
        }
        else if (diffuse.length === 4)
        {
            techniqueParameters.diffuse = techniqueParameters.diffuse_map;
            techniqueParameters.materialColor = md.v4Build.apply(md, diffuse);
        }
    }

    function flatPrepareFn(geometryInstance)
    {
        simplePrepareFn.call(this, geometryInstance);

        //For untextured objects we need to switch techniques.
        var techniqueParameters = geometryInstance.sharedMaterial.techniqueParameters;
        if (!techniqueParameters.diffuse)
        {
            var shader = shaderManager.get(simpleCGFX);
            if (geometryInstance.geometryType === "skinned")
            {
                geometryInstance.drawParameters[0].technique = shader.getTechnique("flat_skinned");
            }
            else
            {
                geometryInstance.drawParameters[0].technique = shader.getTechnique("flat");
            }
        }
    }

    function loadTechniques(shaderManager)
    {
        var that = this;

        var callback = function shaderLoadedCallbackFn(shader)
        {
            that.shader = shader;
            that.technique = shader.getTechnique(that.techniqueName);
            that.techniqueIndex =  renderingCommonGetTechniqueIndexFn(that.techniqueName);
        };
        shaderManager.load(this.shaderName, callback);
    }

    dr.simplePrepareFn = simplePrepareFn;
    dr.simpleUpdateFn = simpleUpdateFn;

    var effect;
    var effectTypeData;
    var skinned = "skinned";
    var rigid = "rigid";

    // Register the effects

    //
    // constant
    //
    effect = Effect.create("constant");
    effectsManager.add(effect);

    effectTypeData = {  prepare : flatPrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "flat",
                        update : simpleUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : flatPrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "flat_skinned",
                        update : simpleSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // lambert
    //
    effect = Effect.create("lambert");
    effectsManager.add(effect);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn",
                        update : simpleUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_skinned",
                        update : simpleSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // blinn
    //
    effect = Effect.create("blinn");
    effectsManager.add(effect);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn",
                        update : simpleUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_skinned",
                        update : simpleSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // blinn_nocull
    //
    effect = Effect.create("blinn_nocull");
    effectsManager.add(effect);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_nocull",
                        update : simpleUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_skinned_nocull",
                        update : simpleSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // phong
    //
    effect = Effect.create("phong");
    effectsManager.add(effect);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn",
                        update : simpleUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_skinned",
                        update : simpleSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // debug_lines_constant
    //
    effect = Effect.create("debug_lines_constant");
    effectsManager.add(effect);

    effectTypeData = {  prepare : debugLinesPrepareFn,
                        shaderName : debugCGFX,
                        techniqueName : "debug_lines_constant",
                        update : simpleNoLightUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    //
    // debug_normals
    //
    effect = Effect.create("debug_normals");
    effectsManager.add(effect);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : debugCGFX,
                        techniqueName : "debug_normals",
                        update : simpleDebugNormalsUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : debugCGFX,
                        techniqueName : "debug_normals_skinned",
                        update : simpleDebugNormalsSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // debug_tangents
    //
    effect = Effect.create("debug_tangents");
    effectsManager.add(effect);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : debugCGFX,
                        techniqueName : "debug_tangents",
                        update : simpleDebugNormalsUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : debugCGFX,
                        techniqueName : "debug_tangents_skinned",
                        update : simpleDebugNormalsSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // debug_binormals
    //
    effect = Effect.create("debug_binormals");
    effectsManager.add(effect);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : debugCGFX,
                        techniqueName : "debug_binormals",
                        update : simpleDebugNormalsUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : debugCGFX,
                        techniqueName : "debug_binormals_skinned",
                        update : simpleDebugNormalsSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // normalmap
    //
    effect = Effect.create("normalmap");
    effectsManager.add(effect);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn",
                        update : simpleUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_skinned",
                        update : simpleSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // normalmap_specularmap
    //
    effect = Effect.create("normalmap_specularmap");
    effectsManager.add(effect);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_specularmap",
                        update : simpleUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_specularmap_skinned",
                        update : simpleSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // normalmap_specularmap_alphamap
    //
    effect = Effect.create("normalmap_specularmap_alphamap");
    effectsManager.add(effect);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_specularmap_alphamap",
                        update : simpleUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    //
    // normalmap_alphatest
    //
    effect = Effect.create("normalmap_alphatest");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_alphatest",
                        update : simpleUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_alphatest_skinned",
                        update : simpleSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);


    //
    // normalmap_specularmap_alphatest
    //
    effect = Effect.create("normalmap_specularmap_alphatest");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_specularmap_alphatest",
                        update : simpleUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_specularmap_alphatest_skinned",
                        update : simpleSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // normalmap_glowmap
    //
    effect = Effect.create("normalmap_glowmap");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_glowmap",
                        update : simpleUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_glowmap_skinned",
                        update : simpleSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // normalmap_specularmap_glowmap
    //
    effect = Effect.create("normalmap_specularmap_glowmap");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_specularmap_glowmap",
                        update : simpleUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_specularmap_glowmap_skinned",
                        update : simpleSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // rxgb_normalmap
    //
    effect = Effect.create("rxgb_normalmap");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn",
                        update : simpleUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_skinned",
                        update : simpleSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // rxgb_normalmap_specularmap
    //
    effect = Effect.create("rxgb_normalmap_specularmap");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_specularmap",
                        update : simpleUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_specularmap_skinned",
                        update : simpleSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // rxgb_normalmap_alphatest
    //
    effect = Effect.create("rxgb_normalmap_alphatest");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_alphatest",
                        update : simpleUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_alphatest_skinned",
                        update : simpleSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // rxgb_normalmap_specularmap_alphatest
    //
    effect = Effect.create("rxgb_normalmap_specularmap_alphatest");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_specularmap_alphatest",
                        update : simpleUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_specularmap_alphatest_skinned",
                        update : simpleSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // rxgb_normalmap_glowmap
    //
    effect = Effect.create("rxgb_normalmap_glowmap");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_glowmap",
                        update : simpleUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_glowmap_skinned",
                        update : simpleSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // rxgb_normalmap_specularmap_glowmap
    //
    effect = Effect.create("rxgb_normalmap_specularmap_glowmap");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_specularmap_glowmap",
                        update : simpleUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blinn_specularmap_glowmap_skinned",
                        update : simpleSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // add
    //
    effect = Effect.create("add");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "add",
                        update : simpleNoLightUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "add_skinned",
                        update : simpleNoLightSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // add_particle
    //
    effect = Effect.create("add_particle");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "add_particle",
                        update : simpleNoLightUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    //
    // blend
    //
    effect = Effect.create("blend");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blend",
                        update : simpleNoLightUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blend_skinned",
                        update : simpleNoLightSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // blend_particle
    //
    effect = Effect.create("blend_particle");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "blend_particle",
                        update : simpleNoLightUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    //
    // translucent
    //
    effect = Effect.create("translucent");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "translucent",
                        update : simpleNoLightUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "translucent_skinned",
                        update : simpleNoLightSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // translucent_particle
    //
    effect = Effect.create("translucent_particle");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "translucent_particle",
                        update : simpleNoLightUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    //
    // filter
    //
    effect = Effect.create("filter");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "filter",
                        update : simpleNoLightUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "filter_skinned",
                        update : simpleNoLightSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // invfilter
    //
    effect = Effect.create("invfilter");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "invfilter",
                        update : simpleNoLightUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    //
    // invfilter_particle
    //
    effect = Effect.create("invfilter_particle");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "invfilter_particle",
                        update : simpleNoLightUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    //
    // glass
    //
    effect = Effect.create("glass");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "glass",
                        update : simpleNoLightUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    //
    // glass_env
    //
    effect = Effect.create("glass_env");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "glass_env",
                        update : simpleEnvUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    //
    // modulate2
    //
    effect = Effect.create("modulate2");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "modulate2",
                        update : simpleNoLightUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "modulate2_skinned",
                        update : simpleNoLightSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // skybox
    //
    effect = Effect.create("skybox");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "skybox",
                        update : simpleEnvUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    //
    // env
    //
    effect = Effect.create("env");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "env",
                        update : simpleEnvUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "env_skinned",
                        update : simpleEnvSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // flare
    //
    effect = Effect.create("flare");
    effectsManager.add(effect);
    effectTypeData = {  prepare : simplePrepareFn,
                        shaderName : simpleCGFX,
                        techniqueName : "add",
                        update : simpleNoLightUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectsManager.map("simple", "blinn");

    return dr;
};

// Copyright (c) 2009-2011 Turbulenz Limited
/*global Utilities: false*/



function Effect() {}

Effect.prototype =
{
    version : 1,

    //
    // prepareMaterial
    //
    prepareMaterial : function effectPrepareMaterialFn(material)
    {
        material.meta.materialIndex = this.numMaterials;
        material.effect = this;
        this.numMaterials += 1;
    },

    //
    // add
    //
    add : function effectAddFn(geometryType, prepareObject)
    {
        this.geometryType[geometryType] = prepareObject;
    },

    //
    // remove
    //
    remove : function effectRemoveFn(geometryType)
    {
        delete this.geometryType[geometryType];
    },

    //
    // get
    //
    get : function effectGetFn(geometryType)
    {
        return this.geometryType[geometryType];
    },

    //
    // prepare
    //
    prepare : function effectPrepareFn(renderable)
    {
        var prepareObject = this.geometryType[renderable.geometryType];
        if (prepareObject)
        {
            prepareObject.prepare(renderable);
        }
        else
        {
            Utilities.assert(false, "Unsupported or missing geometryType");
        }
    }

};

Effect.create = function effectCreateFn(name)
{
    var effect = new Effect();

    effect.name = name;
    effect.geometryType = {};
    effect.numMaterials = 0;

    return effect;
};


//
// EffectManager
//
function EffectManager() {}

EffectManager.prototype =
{
    version : 1,

    //
    // add
    //
    add : function effectAddFn(effect)
    {
        Utilities.assert(this.effects[effect.name] === undefined);
        this.effects[effect.name] = effect;
    },

    //
    // remove
    //
    remove : function effectManagerRemoveFn(name)
    {
        delete this.effects[name];
    },

    //
    // map
    //
    map : function effectManagerMapFn(destination, source)
    {
        this.effects[destination] = this.effects[source];
    },

    //
    // get
    //
    get : function effectManagerGetFn(name)
    {
        var effect = this.effects[name];
        if (!effect)
        {
            return this.effects["default"];
        }
        return effect;
    }
};

EffectManager.create = function effectManagerCreateFn()
{
    var effectManager = new EffectManager();

    effectManager.effects = {};

    return effectManager;
};

// Copyright (c) 2010-2012 Turbulenz Limited

/*global TurbulenzEngine: false*/
/*global Reference: false*/

//
// Geometry
//
function Geometry() {}
Geometry.prototype =
{
    version: 1,

    //
    // destroy
    //
    destroy: function geometryDestroyFn()
    {
        if (this.vertexBufferAllocation)
        {
            this.vertexBufferManager.free(this.vertexBufferAllocation);
            delete this.vertexBufferManager;
            delete this.vertexBufferAllocation;
        }
        if (this.indexBufferAllocation)
        {
            this.indexBufferManager.free(this.indexBufferAllocation);
            delete this.indexBufferManager;
            delete this.indexBufferAllocation;
        }
        delete this.vertexBuffer;
        delete this.indexBuffer;
        delete this.vertexData;
        delete this.indexData;
        delete this.semantics;
        delete this.first;
        delete this.halfExtents;
        delete this.reference;
        delete this.surfaces;
    }
};

//
// Geometry Constructor
//
Geometry.create = function geometryCreateFn()
{
    var geometry = new Geometry();
    geometry.reference = Reference.create(geometry);
    geometry.surfaces = {};
    geometry.type = "rigid";
    return geometry;
};

//
// Geometry Instance
//
function GeometryInstance() {}

GeometryInstance.prototype =
{
    version: 1,

    maxUpdateValue: Number.MAX_VALUE,

    //
    // clone
    //
    clone: function geometryInstanceCloneFn()
    {
        var newInstance = GeometryInstance.create(this.geometry,
                                                  this.surface,
                                                  this.sharedMaterial);
        newInstance.halfExtents = this.halfExtents.slice();
        if (this.center)
        {
            newInstance.center = this.center.slice();
        }
        if (this.disabled)
        {
            newInstance.disabled = true;
        }

        newInstance.worldExtents = [];
        newInstance.worldExtentsUpdate = -1;

        return newInstance;
    },

    //
    // isSkinned
    //
    isSkinned : function geometryInstanceIsSkinnedFn()
    {
        if (this.geometry.skeleton)
        {
            return true;
        }
        return false;
    },

    //
    // setNode
    //
    setNode : function geometryInstanceSetNodeFn(node)
    {
        if (this.node)
        {
            if (this.hasCustomWorldExtents())
            {
                this.node.renderableWorldExtentsRemoved();
            }
        }

        this.node = node;

        if (this.node)
        {
            if (this.hasCustomWorldExtents())
            {
                this.node.renderableWorldExtentsUpdated(false);
            }
        }
        this.worldExtentsUpdate = -1;
    },

    //
    // getNode
    //
    getNode : function geometryInstanceGetNodeFn()
    {
        return this.node;
    },

    //
    // setMaterial
    //
    setMaterial : function geometryInstanceSetMaterialFn(material)
    {
        material.reference.add();
        this.sharedMaterial.reference.remove();

        this.sharedMaterial = material;

        delete this.rendererInfo;
    },

    //
    // getMaterial
    //
    getMaterial : function geometryInstanceGetMaterialFn()
    {
        return this.sharedMaterial;
    },

    //
    // getWorldExtents
    //
    getWorldExtents: function geometryInstanceGetWorldExtentsFn()
    {
        //Note: This method is only valid on a clean node.
        var worldExtents = this.worldExtents;
        var node = this.node;
        if (node.worldUpdate > this.worldExtentsUpdate)
        {
            this.worldExtentsUpdate = node.worldUpdate;

            var center = this.center;
            var halfExtents = this.halfExtents;

            var world = node.world;
            var m0 = world[0];
            var m1 = world[1];
            var m2 = world[2];
            var m3 = world[3];
            var m4 = world[4];
            var m5 = world[5];
            var m6 = world[6];
            var m7 = world[7];
            var m8 = world[8];

            var ct0 = world[9];
            var ct1 = world[10];
            var ct2 = world[11];
            if (center)
            {
                var c0 = center[0];
                var c1 = center[1];
                var c2 = center[2];
                ct0 += (m0 * c0 + m3 * c1 + m6 * c2);
                ct1 += (m1 * c0 + m4 * c1 + m7 * c2);
                ct2 += (m2 * c0 + m5 * c1 + m8 * c2);
            }

            var h0 = halfExtents[0];
            var h1 = halfExtents[1];
            var h2 = halfExtents[2];
            var ht0 = ((m0 < 0 ? -m0 : m0) * h0 + (m3 < 0 ? -m3 : m3) * h1 + (m6 < 0 ? -m6 : m6) * h2);
            var ht1 = ((m1 < 0 ? -m1 : m1) * h0 + (m4 < 0 ? -m4 : m4) * h1 + (m7 < 0 ? -m7 : m7) * h2);
            var ht2 = ((m2 < 0 ? -m2 : m2) * h0 + (m5 < 0 ? -m5 : m5) * h1 + (m8 < 0 ? -m8 : m8) * h2);

            worldExtents[0] = (ct0 - ht0);
            worldExtents[1] = (ct1 - ht1);
            worldExtents[2] = (ct2 - ht2);
            worldExtents[3] = (ct0 + ht0);
            worldExtents[4] = (ct1 + ht1);
            worldExtents[5] = (ct2 + ht2);
        }
        return worldExtents;
    },

    //
    // addCustomWorldExtents
    //
    addCustomWorldExtents: function geometryInstanceAddCustomWorldExtentsFn(customWorldExtents)
    {
        var worldExtents = this.worldExtents;
        worldExtents[0] = customWorldExtents[0];
        worldExtents[1] = customWorldExtents[1];
        worldExtents[2] = customWorldExtents[2];
        worldExtents[3] = customWorldExtents[3];
        worldExtents[4] = customWorldExtents[4];
        worldExtents[5] = customWorldExtents[5];
        var alreadyHadCustomExtents = (this.worldExtentsUpdate === this.maxUpdateValue);
        this.worldExtentsUpdate = this.maxUpdateValue;
        this.node.renderableWorldExtentsUpdated(alreadyHadCustomExtents);
    },

    //
    // removeCustomWorldExtents
    //
    removeCustomWorldExtents: function geometryInstanceRemoveCustomWorldExtentsFn()
    {
        this.worldExtentsUpdate = -1;
        this.node.renderableWorldExtentsRemoved();
    },

    //
    // getCustomWorldExtents
    //
    getCustomWorldExtents: function geometryInstanceGetCustomWorldExtentsFn()
    {
        if (this.worldExtentsUpdate === this.maxUpdateValue)
        {
            return this.worldExtents;
        }
        return undefined;
    },

    //
    // hasCustomWorldExtents
    //
    hasCustomWorldExtents: function geometryInstanceHasCustomWorldExtentsFn()
    {
        return this.worldExtentsUpdate === this.maxUpdateValue;
    },

    //
    // destroy
    //
    destroy: function geometryInstanceDestroyFn()
    {
        if (this.geometry.reference)
        {
            this.geometry.reference.remove();
        }

        if (this.sharedMaterial.reference)
        {
            this.sharedMaterial.reference.remove();
        }

        delete this.surface;
        delete this.geometry;
        delete this.sharedMaterial;
        delete this.techniqueParameters;
        delete this.halfExtents;
        delete this.center;
        delete this.worldExtentsUpdate;
        delete this.drawParameters;
        delete this.renderInfo;
        delete this.sorting;
    },

    //
    // prepareDrawParameters
    //
    prepareDrawParameters: function geometryInstancePrepareFn(drawParameters)
    {
        var surface = this.surface;
        var geometry = this.geometry;
        drawParameters.setVertexBuffer(0, geometry.vertexBuffer);
        drawParameters.setSemantics(0, this.semantics);

        drawParameters.primitive = surface.primitive;

        drawParameters.firstIndex = surface.first;

        if (surface.indexBuffer)
        {
            drawParameters.indexBuffer = surface.indexBuffer;
            drawParameters.count = surface.numIndices;
        }
        else
        {
            drawParameters.count = surface.numVertices;
        }
    }
};

//
// Constructor function
//
GeometryInstance.create = function geometryInstanceCreateFn(geometry,
                                                            surface,
                                                            sharedMaterial)
{
    var instance = new GeometryInstance();
    var graphicsDevice = TurbulenzEngine.getGraphicsDevice(); //Maybe null when running on the server.

    instance.geometry = geometry;
    instance.geometry.reference.add();
    instance.geometryType = geometry.type;
    instance.surface = surface;
    instance.semantics = geometry.semantics;
    instance.halfExtents = geometry.halfExtents;
    instance.center = geometry.center;
    instance.techniqueParameters = graphicsDevice ? graphicsDevice.createTechniqueParameters(): null;
    instance.sharedMaterial = sharedMaterial;
    if (instance.sharedMaterial)
    {
        instance.sharedMaterial.reference.add();
    }
    instance.worldExtents = [];
    instance.worldUpdate = -1;

    return instance;
};

// Copyright (c) 2010-2011 Turbulenz Limited

//
// Material
//
function Material() {}
Material.prototype =
{
    version: 1,

    //
    // getName
    //
    getName: function materialGetNameFn()
    {
        return this.name;
    },

    //
    // setName
    //
    setName: function materialSetNameFn(name)
    {
        this.name = name;
    },

    //
    // loadTextures
    //
    loadTextures: function materialLoadTexturesFn(textureManager)
    {
        var materialTextureNames = this.texturesNames;
        for (var p in materialTextureNames)
        {
            if (materialTextureNames.hasOwnProperty(p))
            {
                var textureName = materialTextureNames[p];
                textureManager.load(textureName);
                this.setTextureInstance(p, textureManager.getInstance(textureName));
            }
        }
    },

    //
    // setTextureInstance
    //
    setTextureInstance: function materialSetTextureInstanceFn(propertryName, textureInstance)
    {
        if (!this.textureInstances)
        {
            this.textureInstances = {};
        }
        var oldInstance = this.textureInstances[propertryName];
        if (oldInstance !== textureInstance)
        {
            if (oldInstance && oldInstance.unsubscribeTextureChanged)
            {
                oldInstance.unsubscribeTextureChanged(this.onTextureChanged);
            }
            this.textureInstances[propertryName] = textureInstance;
            this.techniqueParameters[propertryName] = textureInstance.texture;
            textureInstance.subscribeTextureChanged(this.onTextureChanged);
            textureInstance.reference.add();
        }
    },

    //
    // destroy
    //
    destroy: function materialDestroyFn()
    {
        delete this.techniqueParameters;

        var textureInstance;
        var textureInstances = this.textureInstances;
        for (var p in textureInstances)
        {
            if (textureInstances.hasOwnProperty(p))
            {
                textureInstance = textureInstances[p];
                textureInstance.unsubscribeTextureChanged(this.onTextureChanged);
                textureInstance.reference.remove();
            }
        }
        delete this.textureInstances;
        delete this.textureNames;
    }
};

//
// Material Constructor
//
Material.create = function materialCreateFn(graphicsDevice)
{
    var newMaterial = new Material();
    newMaterial.reference = Reference.create(newMaterial);
    newMaterial.techniqueParameters = graphicsDevice.createTechniqueParameters();
    newMaterial.meta = {};

    newMaterial.onTextureChanged = function materialOnTextureChangedFn(textureInstance)
    {
        var textureInstanceTexture = textureInstance.texture;
        var material = newMaterial;
        var materialTechniqueParameters = material.techniqueParameters;
        var materialTextureInstances = material.textureInstances;

        for (var p in materialTextureInstances)
        {
            if (materialTextureInstances.hasOwnProperty(p))
            {
                if (materialTextureInstances[p] === textureInstance)
                {
                    materialTechniqueParameters[p] = textureInstanceTexture;
                }
            }
        }
    };

    return newMaterial;
};

// Copyright (c) 2010-2011 Turbulenz Limited

//
// Observer
//
function Observer() {}

Observer.prototype = {
    subscribe: function observerSubscribeFn(subscriber)
    {
        //Check for duplicates
        var subscribers = this.subscribers;
        var length = subscribers.length;
        for (var index = 0; index < length; index += 1)
        {
            if (subscribers[index] === subscriber)
            {
                return;
            }
        }

        subscribers.push(subscriber);
    },

    unsubscribe: function observerUnsubscribeFn(subscriber)
    {
        var subscribers = this.subscribers;
        var length = subscribers.length;
        for (var index = 0; index < length; index += 1)
        {
            if (subscribers[index] === subscriber)
            {
                subscribers.splice(index, 1);
                break;
            }
        }
    },

    unsubscribeAll: function observerUnsubscribeAllFn(subscriber)
    {
        this.subscribers.length = 0;
    },

    // this function can take any number of arguments
    // they are passed on to the subscribers
    notify: function observerNotifyFn()
    {
        // Note that the callbacks might unsubscribe
        var subscribers = this.subscribers;
        var length = this.subscribers.length;
        var index = 0;

        while (index < length)
        {
            subscribers[index].apply(null, arguments);
            if (subscribers.length === length)
            {
                index += 1;
            }
            else
            {
                length = subscribers.length;
            }
        }
    }
};

Observer.create = function observerCreateFn()
{
    var observer = new Observer();
    observer.subscribers = [];
    return observer;
};

// Copyright (c) 2010-2011 Turbulenz Limited

//
// renderingCommonGetTechniqueIndexFn
//
function renderingCommonGetTechniqueIndexFn(techniqueName)
{
    var dataStore = renderingCommonGetTechniqueIndexFn;
    var techniqueIndex = dataStore.techniquesIndexMap[techniqueName];
    if (techniqueIndex === undefined)
    {
        techniqueIndex = dataStore.numTechniques;
        dataStore.techniquesIndexMap[techniqueName] = techniqueIndex;
        dataStore.numTechniques += 1;
    }
    return techniqueIndex;
}

renderingCommonGetTechniqueIndexFn.techniquesIndexMap = {};
renderingCommonGetTechniqueIndexFn.numTechniques = 0;

//
// renderingCommonSortKeyFn
//
function renderingCommonSortKeyFn(techniqueIndex, materialIndex)
{
    return techniqueIndex * 0x10000 + materialIndex % 0x10000;
}

//
// renderingCommonCreateRendererInfoFn
//
function renderingCommonCreateRendererInfoFn(renderable)
{
    var rendererInfo = {};
    renderable.rendererInfo = rendererInfo;
    var effect = renderable.sharedMaterial.effect;

    if (effect.prepare)
    {
        effect.prepare(renderable);
    }

    return rendererInfo;
}

//
// renderingCommonAddDrawParameterFastestFn
//
function renderingCommonAddDrawParameterFastestFn(drawParameters)
{
    var array = this.array;
    array[array.length] = drawParameters;
}

// Copyright (c) 2010-2011 Turbulenz Limited

//
// ResourceLoader
//
function ResourceLoader() {}
ResourceLoader.prototype =
{
    version: 1,

    //
    // clear
    //
    clear: function resourceLoaderClearFn()
    {
        this.nodesMap = {};
        this.referencesPending = {};
        this.numReferencesPending = 0;
        this.animationsPending = {};
    },

    //
    // endLoading
    //
    endLoading: function resourceLoaderEndLoadingFn(onload)
    {
        this.referencesPending = {};
        this.animationsPending = {};

        if (onload)
        {
            onload(this.data);
        }
    },

    resolveShapes: function resourceLoaderResolveShapesFn(loadParams)
    {
        function copyObjectFn(o)
        {
            var newObj = { };
            for (var p in o)
            {
                if (o.hasOwnProperty(p))
                {
                    newObj[p] = o[p];
                }
            }
            return newObj;
        }

        var shapesNamePrefix = loadParams.shapesNamePrefix;
        // we reuse shapesNamePrefix to save adding prefixes for everything
        var skeletonNamePrefix = loadParams.shapesNamePrefix;
        var sceneData = loadParams.data;
        var fileShapes = sceneData.geometries;
        var targetShapes = this.data.geometries;
        if (!targetShapes)
        {
            targetShapes = {};
            this.data.geometries = targetShapes;
        }

        for (var fileShapeName in fileShapes)
        {
            if (fileShapes.hasOwnProperty(fileShapeName))
            {
                var fileShape = fileShapes[fileShapeName];
                var targetShapeName = (shapesNamePrefix ? (shapesNamePrefix + "-" + fileShapeName) : fileShapeName);

                // Update the skeleton reference
                var fileSkeletonName = fileShape.skeleton;
                if (fileSkeletonName)
                {
                    // the shape has to be copied if it has a skeleton as the same shape
                    // can be used with multiple skeletons
                    targetShapes[targetShapeName] = copyObjectFn(fileShape);
                    targetShapes[targetShapeName].skeleton = (skeletonNamePrefix ? (skeletonNamePrefix + "-" + fileSkeletonName) : fileSkeletonName);
                }
                else
                {
                    targetShapes[targetShapeName] = fileShape;
                }
            }
        }
    },

    resolveSkeletons: function resourceLoaderResolveSkeletonsFn(loadParams)
    {
        // we reuse shapesNamePrefix to save adding prefixes for everything
        var skeletonNamePrefix = loadParams.shapesNamePrefix;
        var sceneData = loadParams.data;
        var fileSkeletons = sceneData.skeletons;
        var targetSkeletons = this.data.skeletons;
        if (!targetSkeletons)
        {
            targetSkeletons = {};
            this.data.skeletons = targetSkeletons;
        }

        for (var fileSkeletonName in fileSkeletons)
        {
            if (fileSkeletons.hasOwnProperty(fileSkeletonName))
            {
                var fileSkeleton = fileSkeletons[fileSkeletonName];
                var targetSkeletonName = (skeletonNamePrefix ? (skeletonNamePrefix + "-" + fileSkeletonName) : fileSkeletonName);
                targetSkeletons[targetSkeletonName] = fileSkeleton;
            }
        }
    },

    //
    // Resolve animations
    //
    resolveAnimations: function resourceLoaderResolveAnimationsFn(loadParams)
    {
        var sceneData = loadParams.data;

        var fileAnims = sceneData.animations;
        if (!fileAnims)
        {
            return;
        }

        var currentLoader = this;
        var anims = currentLoader.data.animations;
        if (!anims)
        {
            anims = {};
            currentLoader.data.animations = anims;
        }


        var resolveRef = function (currentScene)
        {
            var postLoadReference = function (sceneText)
            {
                if (sceneText)
                {
                    var sceneData = JSON.parse(sceneText);
                    for (var anim in sceneData.animations)
                    {
                        if (sceneData.animations.hasOwnProperty(anim))
                        {
                            anims[anim] = sceneData.animations[anim];
                        }
                    }
                }
                //Utilities.log("resolved ref for " + anim + " count now " + (currentLoader.numReferencesPending-1));
                currentLoader.numReferencesPending -= 1;
                if (currentLoader.numReferencesPending <= 0)
                {
                    currentLoader.endLoading(loadParams.onload);
                }
            };

            return postLoadReference;
        };

        // Import animations
        var requestOwner = (loadParams.request ? loadParams : TurbulenzEngine);
        for (var a in fileAnims)
        {
            if (fileAnims.hasOwnProperty(a))
            {
                var reference = fileAnims[a].reference;
                if (reference)
                {
                    if (!this.animationsPending[a])
                    {
                        this.animationsPending[a] = true;
                        this.numReferencesPending += 1;
                        //Utilities.log("adding ref for " + a + " count now " + this.numReferencesPending);
                        delete fileAnims[a].reference;

                        loadParams.requestHandler.request({
                            src: reference,
                            requestOwner: requestOwner,
                            onload: resolveRef(this)
                        });
                    }
                }
                else
                {
                    anims[a] = fileAnims[a];
                }
            }
        }
    },


    //
    // resolveNodes
    //
    resolveNodes: function resourceLoaderResolveNodesFn(loadParams)
    {
        var sceneData = loadParams.data;

        var references = this.referencesPending;
        var numReferences = 0;
        var nodes = this.nodes;
        var nodesMap = this.nodesMap;

        var currentLoader = this;

        var nodesNamePrefix = loadParams.nodesNamePrefix;
        var shapesNamePrefix = loadParams.shapesNamePrefix;

        var requestOwner = (loadParams.request ? loadParams : TurbulenzEngine);

        function copyObjectFn(o)
        {
            var newObj = { };
            for (var p in o)
            {
                if (o.hasOwnProperty(p))
                {
                    newObj[p] = o[p];
                }
            }
            return newObj;
        }

        function resolveNodeFn(fileNode, nodeName, parentNodePath)
        {
            // We're changing a node which may be referenced multiple times so take a copy
            var node = copyObjectFn(fileNode);
            var nodePath = parentNodePath ? (parentNodePath + "/" + nodeName) : nodeName;

            var reference = node.reference;
            if (reference)
            {
                //Utilities.log("Reference resolve for " + nodePath);

                var internalReferenceIndex = reference.indexOf("#");
                if (internalReferenceIndex === -1)
                {
                    var referenceParameters = references[reference];
                    if (!referenceParameters || referenceParameters.length === 0 || !node.inplace)
                    {
                        numReferences += 1;
                        //Utilities.log("adding ref for " + nodePath + " numrefs now " + numReferences);

                        var sceneParameters = copyObjectFn(loadParams);
                        sceneParameters.append = true;
                        if (node.inplace)
                        {
                            sceneParameters.nodesNamePrefix = parentNodePath;
                            sceneParameters.shapesNamePrefix = null;
                            sceneParameters.parentNode = null;
                        }
                        else
                        {
                            sceneParameters.nodesNamePrefix = nodePath;
                            sceneParameters.shapesNamePrefix = reference;
                            sceneParameters.parentNode = node;
                        }
                        if (node.skin)
                        {
                            sceneParameters.skin = node.skin;
                        }

                        if (!referenceParameters || referenceParameters.length === 0)
                        {
                            referenceParameters = [sceneParameters];
                            references[reference] = referenceParameters;

                            var loadReference = function (sceneText)
                            {
                                var numInstances = referenceParameters.length;
                                var sceneData;
                                if (sceneText)
                                {
                                    sceneData = JSON.parse(sceneText);
                                }
                                else
                                {
                                    // Make sure we can call scene load to correctly deal with reference
                                    // counts when a reference is missing
                                    sceneData = {};
                                }
                                var params;
                                for (var n = 0; n < numInstances; n += 1)
                                {
                                    params = referenceParameters[n];
                                    params.data = sceneData;
                                    params.isReference = true;
                                    currentLoader.resolve(params);
                                }
                                referenceParameters.length = 0;
                            };

                            loadParams.requestHandler.request({
                                    src: reference,
                                    requestOwner: requestOwner,
                                    onload: loadReference
                                });
                        }
                        else
                        {
                            referenceParameters.push(sceneParameters);
                        }
                    }
                }
                delete node.reference;
                delete node.inplace;
            }

            var geometryinstances = node.geometryinstances;
            if (shapesNamePrefix && geometryinstances)
            {
                // Need to deep copy the geometry instances dictionary because we're prefixing the names
                node.geometryinstances = { };
                for (var gi in geometryinstances)
                {
                    if (geometryinstances.hasOwnProperty(gi))
                    {
                        node.geometryinstances[gi] = copyObjectFn(geometryinstances[gi]);
                        var geometryInstance = node.geometryinstances[gi];

                        //Utilities.log("prefixing " + geometryInstance.geometry + " with " + shapesNamePrefix);
                        geometryInstance.geometry = shapesNamePrefix + "-" + geometryInstance.geometry;
                    }
                }
            }

            var fileChildren = fileNode.nodes;
            if (fileChildren)
            {
                node.nodes = {};
                for (var c in fileChildren)
                {
                    if (fileChildren.hasOwnProperty(c))
                    {
                        var childPath = nodePath + "/" + c;
                        if (!nodesMap[childPath])
                        {
                            node.nodes[c] = resolveNodeFn(fileChildren[c], c, nodePath);
                            nodesMap[childPath] = node.nodes[c];
                        }
                    }
                }
            }

            return node;
        }

        var fileNodes = sceneData.nodes;
        var parentNode = loadParams.parentNode;
        var emptyNode = {};
        for (var fn in fileNodes)
        {
            if (fileNodes.hasOwnProperty(fn) && fileNodes[fn])
            {
                var nodeName = fn;
                var fileNode = resolveNodeFn(fileNodes[fn], nodeName, nodesNamePrefix);
                var nodePath = (nodesNamePrefix ? (nodesNamePrefix + "/" + fn) : fn);
                var overloadedNode = nodesMap[nodePath];

                if (overloadedNode)
                {
                    //Utilities.log("Overloaded node '" + nodePath + "'");

                    var overloadedMatrix = overloadedNode.matrix;
                    if (overloadedMatrix && fileNode.matrix)
                    {
                        overloadedNode.matrix = VMath.m43Mul(fileNode.matrix, overloadedMatrix);
                        overloadedMatrix = null;
                    }

                    var overloadedChildren = overloadedNode.nodes;
                    if (overloadedChildren && fileNode.nodes)
                    {
                        //Utilities.log("Concat children of node '" + nodePath + "'");
                        for (var c in fileNode.nodes)
                        {
                            if (fileNode.nodes.hasOwnProperty(c))
                            {
                                overloadedChildren[c] = fileNode.nodes[c];
                            }
                        }
                    }
                    else if (fileNode.nodes)
                    {
                        overloadedNode.nodes = fileNode.nodes;
                    }

                    for (var on in fileNode)
                    {
                        if (fileNode.hasOwnProperty(on))
                        {
                            overloadedNode[on] = fileNode[on];
                        }
                    }
                    fileNode = overloadedNode;
                }
                else
                {
                    if (loadParams.isReference && parentNode)
                    {
                        if (!parentNode.nodes)
                        {
                            parentNode.nodes = {};
                        }
                        parentNode.nodes[fn] = fileNode;
                    }
                    else
                    {
                        this.data.nodes[fn] = fileNode;
                    }

                    nodesMap[nodePath] = fileNode;
                }
            }
        }

        this.numReferencesPending += numReferences;
        //Utilities.log("total refs now " + this.numReferencesPending);
    },

    //
    // loadPhysicsNodes
    //
    resolvePhysicsNodes: function resourceLoaderResolvePhysicsNodesFn(loadParams)
    {
        var sceneData = loadParams.data;
        var nodesNamePrefix = loadParams.nodesNamePrefix;
        var shapesNamePrefix = loadParams.shapesNamePrefix;

        function begetFn(o)
        {
            var F = function () { };
            F.prototype = o;
            return new F();
        }

        var fileShapes = sceneData.geometries;
        var fileModels = sceneData.physicsmodels;
        var targetFileModels = this.data.physicsmodels;
        if (!targetFileModels)
        {
            targetFileModels = {};
            this.data.physicsmodels = targetFileModels;
        }

        for (var fm in fileModels)
        {
            if (fileModels.hasOwnProperty(fm))
            {
                var fileModel = fileModels[fm];

                if (shapesNamePrefix)
                {
                    var newModelName = shapesNamePrefix ? shapesNamePrefix + "-" + fm : fm;

                    var model = begetFn(fileModel);
                    targetFileModels[newModelName] = model;

                    var geometry = model.geometry;
                    if (geometry)
                    {
                        model.geometry = shapesNamePrefix ? shapesNamePrefix + "-" + geometry : geometry;
                    }
                }
                else
                {
                    targetFileModels[fm] = fileModel;
                }
            }
        }

        var fileNodes = sceneData.physicsnodes;
        var targetFileNodes = this.data.physicsnodes;
        if (!targetFileNodes)
        {
            targetFileNodes = {};
            this.data.physicsnodes = targetFileNodes;
        }

        for (var fn in fileNodes)
        {
            if (fileNodes.hasOwnProperty(fn))
            {
                var fileNode = fileNodes[fn];

                if (nodesNamePrefix || shapesNamePrefix)
                {
                    var targetName = fileNode.target;
                    targetName = nodesNamePrefix ? (nodesNamePrefix + "/" + targetName) : targetName;

                    var node = begetFn(fileNode);
                    node.target = targetName;

                    node.body = shapesNamePrefix ? shapesNamePrefix + "-" + fileNode.body : fileNode.body;

                    var newNodeName = nodesNamePrefix ? (nodesNamePrefix + "/" + fn) : fn;
                    targetFileNodes[newNodeName] = node;
                }
                else
                {
                    targetFileNodes[fn] = fileNode;
                }
            }
        }
    },

    //
    // loadAreas
    //
    resolveAreas: function resourceLoaderResolveAreasFn(loadParams)
    {
        var sceneData = loadParams.data;

        var fileAreas = sceneData.areas;
        if (!fileAreas)
        {
            return;
        }

        var numFileAreas = fileAreas.length;
        if (numFileAreas <= 0)
        {
            return;
        }

        var targetAreas = this.data.areas;
        if (!targetAreas)
        {
            targetAreas = [];
            this.data.areas = targetAreas;
        }

        var nodesNamePrefix = loadParams.nodesNamePrefix;

        for (var fa = 0; fa < numFileAreas; fa += 1)
        {
            var fileArea = fileAreas[fa];

            if (nodesNamePrefix)
            {
                var targetName = fileArea.target;
                fileArea.target = (nodesNamePrefix + "/" + targetName);
            }
            targetAreas.push(fileArea);
        }
    },

    //
    // resolve
    //
    resolve: function resourceLoaderResolveFn(loadParams)
    {
        if (!loadParams.append)
        {
            this.data = { nodes: {} };
        }

        // Start by simply copying any dictionaries which we don't special case
        var appendData = loadParams.data;
        for (var d in appendData)
        {
            if (d !== "nodes" &&
                d !== "skeletons" &&
                d !== "geometries" &&
                d !== "animations" &&
                d !== "areas" &&
                d !== "physicsnodes" &&
                d !== "physicsmodels")
            {
                if (appendData.hasOwnProperty(d))
                {
                    var dict = appendData[d];
                    var targetDict = this.data[d];
                    if (!targetDict)
                    {
                        this.data[d] = dict;
                    }
                    else
                    {
                        for (var e in dict)
                        {
                            if (dict.hasOwnProperty(e) && !targetDict[e])
                            {
                                targetDict[e] = dict[e];
                            }
                        }
                    }
                }
            }
        }

        this.resolveShapes(loadParams);

        this.resolveSkeletons(loadParams);

        this.resolveAnimations(loadParams);

        this.resolveNodes(loadParams);

        this.resolvePhysicsNodes(loadParams);

        this.resolveAreas(loadParams);

        if (loadParams.isReference)
        {
            this.numReferencesPending -= 1;
            //Utilities.log("loaded ref now " + this.numReferencesPending);
        }

        if (this.numReferencesPending <= 0)
        {
            this.endLoading(loadParams.onload);
        }

    },

    //
    // load
    //
    load: function resourceLoaderLoadFn(assetPath, loadParams)
    {
        var loader = this;
        var dataReceived = function dataReceivedFn(text)
        {
            var sceneData = {};
            if (text)
            {
                sceneData = JSON.parse(text);
            }

            loadParams.data = sceneData;
            loadParams.append = false;
            loader.resolve(loadParams);
        };

        loadParams.requestHandler.request({
                src: assetPath,
                requestOwner: loadParams.request ? loadParams : TurbulenzEngine,
                onload: dataReceived
            });
    }

};

// Constructor function
ResourceLoader.create = function resourceLoaderCreateFn()
{
    var rl = new ResourceLoader();
    rl.clear();

    rl.skeletonNames = {};

    return rl;
};

// Copyright (c) 2009-2012 Turbulenz Limited
/*global AABBTree*/
/*global Material*/
/*global SceneNode*/
/*global Geometry*/
/*global GeometryInstance*/
/*global Light*/
/*global LightInstance*/
/*global Utilities*/
/*global VertexBufferManager*/
/*global IndexBufferManager*/
/*global window*/
/*global alert*/
/*global Uint16Array*/
/*global Uint32Array*/
/*global Float32Array*/

//
// Scene
//
function Scene() {}
Scene.prototype =
{
    version: 1,

    //
    // findNode
    //
    findNode: function sceneFindNodeFn(nodePath)
    {
        //simple case of root node
        var result =  this.rootNodesMap[nodePath];
        if (result)
        {
            return result;
        }

        //else find node in turn
        var names = nodePath.split("/");
        var rootName = names[0];
        result =  this.rootNodesMap[rootName];

        for (var depth = 1; result && depth < names.length;  depth += 1)
        {
            result = result.findChild(names[depth]);
        }
        return result;
    },

    //
    // addRootNode
    //
    addRootNode: function addRootNodeFn(rootNode)
    {
        // Add the root to the top level nodes list and update the scene hierarchys
        Utilities.assert(rootNode.name, "Root nodes must be named");
        Utilities.assert(!rootNode.scene, "Root node already in a scene");
        Utilities.assert(!this.rootNodesMap[rootNode.name], "Root node with the same name exits in the scene");

        rootNode.scene = this;
        this.rootNodes.push(rootNode);
        if (!this.dirtyRoots)
        {
            this.dirtyRoots = {};
        }
        this.dirtyRoots[rootNode.name] = rootNode;
        this.rootNodesMap[rootNode.name] = rootNode;
    },

    //
    // removeRootNode
    //
    removeRootNode : function removeRootNodeFn(rootNode)
    {
        Utilities.assert(rootNode.scene === this, "Root node is not in the scene");
        rootNode.removedFromScene(this);
        var rootNodes = this.rootNodes;
        var numRootNodes = rootNodes.length;
        for (var n = 0; n < numRootNodes; n += 1)
        {
            if (rootNode === rootNodes[n])
            {
                rootNodes.splice(n, 1);
                break;
            }
        }
        if (this.dirtyRoots)
        {
            delete this.dirtyRoots[rootNode.name];
        }
        delete this.rootNodesMap[rootNode.name];
        delete rootNode.scene;
    },

    //
    // addLight
    //
    addLight: function sceneAddLightFn(light)
    {
        this.lights[light.name] = light;

        if (light.isGlobal())
        {
            this.globalLights.push(light);
        }
    },

    //
    // removeLight
    //
    removeLight: function sceneRemoveLightFn(light)
    {
        delete this.lights[light.name];

        if (light.isGlobal())
        {
            var globalLights = this.globalLights;
            var numGlobalLights = globalLights.length;
            for (var index = 0; index < numGlobalLights; index += 1)
            {
                if (light === globalLights[index])
                {
                    globalLights.splice(index, 1);
                    break;
                }
            }
        }
    },

    //
    // getLight
    //
    getLight: function sceneGetLightFn(name)
    {
        return this.lights[name];
    },

    //
    // getGlobalLights
    //
    getGlobalLights: function sceneGetGlobalLightsFn()
    {
        return this.globalLights;
    },

    //
    // calculateNumNodes
    //
    calculateNumNodes: function calculateNumNodesFn(nodes)
    {
        var numNodes = nodes.length;
        var numTotalNodes = numNodes;
        for (var n = 0; n < numNodes; n += 1)
        {
            var children = nodes[n].children;
            if (children)
            {
                numTotalNodes += calculateNumNodesFn(children);
            }
        }
        return numTotalNodes;
    },

    //
    // buildPortalPlanes
    //
    buildPortalPlanes: function buildPortalPlanesFn(points, planes, cX, cY, cZ, frustumPlanes)
    {
        var numPoints = points.length;
        var numFrustumPlanes = frustumPlanes.length;
        var numPlanes = 0;
        var n, np, nnp, p, plane, numVisiblePointsPlane;

        var culledByPlane = [];
        culledByPlane.length = numPoints;
        np = 0;
        do
        {
            culledByPlane[np] = [];
            np += 1;
        }
        while (np < numPoints);

        n = 0;
        do
        {
            plane = frustumPlanes[n];
            var pl0 = plane[0];
            var pl1 = plane[1];
            var pl2 = plane[2];
            var pl3 = plane[3];
            numVisiblePointsPlane = 0;

            np = 0;
            do
            {
                p = points[np];
                if ((pl0 * p[0] + pl1 * p[1] + pl2 * p[2]) >= pl3)
                {
                    numVisiblePointsPlane += 1;
                }
                else
                {
                    culledByPlane[np][n] = true;
                }
                np += 1;
            }
            while (np < numPoints);

            if (numVisiblePointsPlane === 0)
            {
                planes.length = 0;
                return false;
            }
            else if (numVisiblePointsPlane < numPoints)
            {
                planes[numPlanes] = plane;
                numPlanes += 1;
            }
            n += 1;
        }
        while (n < numFrustumPlanes);

        var allPointsVisible = (numPlanes === 0);

        var newPoints = [];
        newPoints.length = numPoints;
        np = 0;
        do
        {
            p = points[np];
            newPoints[np] = [(p[0] - cX), (p[1] - cY), (p[2] - cZ)];
            np += 1;
        }
        while (np < numPoints);

        var sqrt = Math.sqrt;
        np = 0;
        do
        {
            nnp = (np + 1);
            if (nnp >= numPoints)
            {
                nnp = 0;
            }

            // Skip plane if both points were culled by the same frustum plane
            var culled0 = culledByPlane[np];
            var culled1 = culledByPlane[nnp];
            var maxCulled = (culled0.length < culled1.length ? culled0.length : culled1.length);
            for (n = 0; n < maxCulled; n += 1)
            {
                if (culled0[n] && culled1[n])
                {
                    break;
                }
            }
            if (n < maxCulled)
            {
                np += 1;
                continue;
            }

            p = newPoints[np];
            var p0X = p[0];
            var p0Y = p[1];
            var p0Z = p[2];

            p = newPoints[nnp];
            var p1X = p[0];
            var p1Y = p[1];
            var p1Z = p[2];

            // n = cross(p0, p1)
            var nX = ((p0Y * p1Z) - (p0Z * p1Y));
            var nY = ((p0Z * p1X) - (p0X * p1Z));
            var nZ = ((p0X * p1Y) - (p0Y * p1X));

            // normalize(n)
            var lnsq = ((nX * nX) + (nY * nY) + (nZ * nZ));
            if (lnsq === 0)
            {
                planes.length = 0;
                return false;
            }
            var lnrcp = 1.0 / sqrt(lnsq);
            nX *= lnrcp;
            nY *= lnrcp;
            nZ *= lnrcp;

            // d = dot(n, c)
            var d = ((nX * cX) + (nY * cY) + (nZ * cZ));

            planes[numPlanes] = [nX, nY, nZ, d];
            numPlanes += 1;

            np += 1;
        }
        while (np < numPoints);

        return allPointsVisible;
    },

    //
    // findAreaIndex
    //
    findAreaIndex: function findAreaIndexFn(bspNodes, cX, cY, cZ)
    {
        var numNodes = bspNodes.length;
        var nodeIndex = 0;
        var node, plane;
        do
        {
            node = bspNodes[nodeIndex];
            plane = node.plane;
            nodeIndex = (((plane[0] * cX) + (plane[1] * cY) + (plane[2] * cZ)) < plane[3] ? node.neg : node.pos);
            if (nodeIndex <= 0)
            {
                return -(nodeIndex + 1);
            }
        }
        while (nodeIndex < numNodes);
        return -1;
    },

    //
    // findAreaIndicesAABB
    //
    findAreaIndicesAABB: function findAreaIndicesAABBFn(bspNodes, n0, n1, n2, p0, p1, p2)
    {
        var numNodes = bspNodes.length;
        var areaIndices = [];
        var visitedArea = [];
        var stack = [0];
        var numNodesStack = 1;
        var nodeIndex, node, plane, areaIndex;
        do
        {
            numNodesStack -= 1;
            nodeIndex = stack[numNodesStack];
            do
            {
                node = bspNodes[nodeIndex];
                plane = node.plane;
                var d0 = plane[0];
                var d1 = plane[1];
                var d2 = plane[2];
                var d3 = plane[3];
                if ((d0 * (d0 < 0 ? n0 : p0) + d1 * (d1 < 0 ? n1 : p1) + d2 * (d2 < 0 ? n2 : p2)) < d3)
                {
                    nodeIndex = node.neg;
                }
                else
                {
                    if ((d0 * (d0 > 0 ? n0 : p0) + d1 * (d1 > 0 ? n1 : p1) + d2 * (d2 > 0 ? n2 : p2)) <= d3)
                    {
                        nodeIndex = node.neg;
                        if (nodeIndex <= 0)
                        {
                            if (nodeIndex < 0)
                            {
                                areaIndex = -(nodeIndex + 1);
                                if (!visitedArea[areaIndex])
                                {
                                    visitedArea[areaIndex] = true;
                                    areaIndices.push(areaIndex);
                                }
                            }
                        }
                        else
                        {
                            stack[numNodesStack] = nodeIndex;
                            numNodesStack += 1;
                        }
                    }
                    nodeIndex = node.pos;
                }
                if (nodeIndex <= 0)
                {
                    if (nodeIndex < 0)
                    {
                        areaIndex = -(nodeIndex + 1);
                        if (!visitedArea[areaIndex])
                        {
                            visitedArea[areaIndex] = true;
                            areaIndices.push(areaIndex);
                        }
                    }
                    break;
                }
            }
            while (nodeIndex < numNodes);
        }
        while (0 < numNodesStack);
        return areaIndices;
    },

    //
    // findVisiblePortals
    //
    findVisiblePortals: function sceneFindVisiblePortalsFn(areaIndex, cX, cY, cZ)
    {
        var buildPortalPlanes = this.buildPortalPlanes;
        var visiblePortals = this.visiblePortals;
        var oldNumVisiblePortals = visiblePortals.length;
        var frustumPlanes = this.frustumPlanes;
        var numFrustumPlanes = frustumPlanes.length;
        var queryCounter = this.getQueryCounter();
        var areas = this.areas;
        var portals, numPortals, portal, plane, area, n, portalPlanes, portalItem;
        var numVisiblePortals = 0;

        // Cull portals behind camera
        // (do NOT use nearPlane directly because areaIndex is based on the camera position)
        var nearPlane  = this.nearPlane;
        var nearPlane0 = nearPlane[0];
        var nearPlane1 = nearPlane[1];
        var nearPlane2 = nearPlane[2];
        frustumPlanes[numFrustumPlanes] = [nearPlane0, nearPlane1, nearPlane2, ((nearPlane0 * cX) + (nearPlane1 * cY) + (nearPlane2 * cZ))];

        area = areas[areaIndex];
        portals = area.portals;
        numPortals = portals.length;
        for (n = 0; n < numPortals; n += 1)
        {
            portal = portals[n];
            if (portal.disabled)
            {
                continue;
            }
            portal.queryCounter = queryCounter;
            plane = portal.plane;
            if (((plane[0] * cX) + (plane[1] * cY) + (plane[2] * cZ)) < plane[3])
            {
                if (numVisiblePortals < oldNumVisiblePortals)
                {
                    portalItem = visiblePortals[numVisiblePortals];
                    portalPlanes = portalItem.planes;
                    portalPlanes.length = 0;
                }
                else
                {
                    portalPlanes = [];
                }
                buildPortalPlanes(portal.points, portalPlanes, cX, cY, cZ, frustumPlanes);
                if (0 < portalPlanes.length)
                {
                    if (numVisiblePortals < oldNumVisiblePortals)
                    {
                        portalItem.portal = portal;
                        portalItem.area   = portal.area;
                    }
                    else
                    {
                        visiblePortals[numVisiblePortals] = {
                                portal: portal,
                                planes: portalPlanes,
                                area: portal.area
                            };
                    }
                    numVisiblePortals += 1;
                }
            }
        }

        frustumPlanes.length = numFrustumPlanes; // remove camera plane, not needed to cull nodes

        if (0 < numVisiblePortals)
        {
            var numPortalPlanes, nextArea, plane0, plane1, plane2, plane3, planes, allPointsVisible;
            var currentPortalIndex = 0;
            do
            {
                portalItem = visiblePortals[currentPortalIndex];
                currentPortalIndex += 1;
                portalPlanes = portalItem.planes;
                numPortalPlanes = portalPlanes.length;
                portal = portalItem.portal;
                areaIndex = portalItem.area;

                portalPlanes[numPortalPlanes] = portal.plane; // Add current plane to cull portals behind

                area = areas[areaIndex];
                portals = area.portals;
                numPortals = portals.length;
                for (n = 0; n < numPortals; n += 1)
                {
                    portal = portals[n];
                    nextArea = portal.area;
                    if (nextArea !== areaIndex &&
                        portal.queryCounter !== queryCounter &&
                        !portal.disabled)
                    {
                        plane = portal.plane;
                        plane0 = plane[0];
                        plane1 = plane[1];
                        plane2 = plane[2];
                        plane3 = plane[3];
                        if (((plane0 * cX) + (plane1 * cY) + (plane2 * cZ)) < plane3)
                        {
                            if (numVisiblePortals < oldNumVisiblePortals)
                            {
                                portalItem = visiblePortals[numVisiblePortals];
                                planes = portalItem.planes;
                                planes.length = 0;
                            }
                            else
                            {
                                planes = [];
                            }
                            allPointsVisible = buildPortalPlanes(portal.points, planes, cX, cY, cZ, portalPlanes);
                            if (0 < planes.length)
                            {
                                if (allPointsVisible)
                                {
                                    portal.queryCounter = queryCounter;
                                }
                                if (numVisiblePortals < oldNumVisiblePortals)
                                {
                                    portalItem.portal = portal;
                                    portalItem.area   = nextArea;
                                }
                                else
                                {
                                    visiblePortals[numVisiblePortals] = {
                                            portal: portal,
                                            planes: planes,
                                            area: nextArea
                                        };
                                }
                                numVisiblePortals += 1;
                            }
                        }
                        else
                        {
                            portal.queryCounter = queryCounter;
                        }
                    }
                }

                portalPlanes.length = numPortalPlanes; // remove current plane, not needed to cull nodes
            }
            while (currentPortalIndex < numVisiblePortals);
        }

        if (numVisiblePortals < oldNumVisiblePortals)
        {
            visiblePortals.length = numVisiblePortals;
        }
    },

    //
    // findVisibleNodes
    //
    findVisibleNodes: function sceneFindVisibleNodesFn(camera, visibleNodes)
    {
        var frustumPlanes = this.frustumPlanes;
        var useAABBTrees = true;
        var areas = this.areas;
        if (areas)
        {
            var cameraMatrix = camera.matrix;
            var cX = cameraMatrix[9];
            var cY = cameraMatrix[10];
            var cZ = cameraMatrix[11];

            var areaIndex = this.findAreaIndex(this.bspNodes, cX, cY, cZ);
            this.cameraAreaIndex = areaIndex;

            if (areaIndex >= 0)
            {
                camera.getFrustumExtents(this.cameraExtents);
                var cameraMinExtent0 = this.cameraExtents[0];
                var cameraMinExtent1 = this.cameraExtents[1];
                var cameraMinExtent2 = this.cameraExtents[2];
                var cameraMaxExtent0 = this.cameraExtents[3];
                var cameraMaxExtent1 = this.cameraExtents[4];
                var cameraMaxExtent2 = this.cameraExtents[5];

                this.findVisiblePortals(areaIndex, cX, cY, cZ);

                var area, na, nodes, numNodes;
                var numAreas = areas.length;
                for (na = 0; na < numAreas; na += 1)
                {
                    area = areas[na];
                    nodes = area.nodes;
                    numNodes = area.numStaticNodes;
                    if (nodes.length > numNodes)
                    {
                        nodes.length = numNodes;
                    }
                    area.addedDynamicNodes = false;
                }

                var isInsidePlanesAABB = this.isInsidePlanesAABB;
                var dynamicSpatialMap = this.dynamicSpatialMap;
                var visiblePortals = this.visiblePortals;
                var numVisiblePortals = visiblePortals.length;
                var queryCounter = this.getQueryCounter();
                var numVisibleNodes = visibleNodes.length;
                var n, node, np, portalItem, portalPlanes;

                area = areas[areaIndex];
                nodes = area.nodes;
                area.addedDynamicNodes = true;

                var areaExtent = area.extents;
                var areaMinExtent0 = areaExtent[0];
                var areaMinExtent1 = areaExtent[1];
                var areaMinExtent2 = areaExtent[2];
                var areaMaxExtent0 = areaExtent[3];
                var areaMaxExtent1 = areaExtent[4];
                var areaMaxExtent2 = areaExtent[5];
                var combinedExtents = [(areaMinExtent0 < cameraMinExtent0 ? cameraMinExtent0 : areaMinExtent0),
                                       (areaMinExtent1 < cameraMinExtent1 ? cameraMinExtent1 : areaMinExtent1),
                                       (areaMinExtent2 < cameraMinExtent2 ? cameraMinExtent2 : areaMinExtent2),
                                       (areaMaxExtent0 > cameraMaxExtent0 ? cameraMaxExtent0 : areaMaxExtent0),
                                       (areaMaxExtent1 > cameraMaxExtent1 ? cameraMaxExtent1 : areaMaxExtent1),
                                       (areaMaxExtent2 > cameraMaxExtent2 ? cameraMaxExtent2 : areaMaxExtent2)];
                dynamicSpatialMap.getOverlappingNodes(combinedExtents, nodes);

                numNodes = nodes.length;
                for (n = 0; n < numNodes; n += 1)
                {
                    node = nodes[n];
                    node.queryCounter = queryCounter;
                    if (isInsidePlanesAABB(node.worldExtents, frustumPlanes))
                    {
                        visibleNodes[numVisibleNodes] = node;
                        numVisibleNodes += 1;
                    }
                }

                for (np = 0; np < numVisiblePortals; np += 1)
                {
                    portalItem = visiblePortals[np];
                    portalPlanes = portalItem.planes;
                    area = areas[portalItem.area];
                    nodes = area.nodes;

                    if (!area.addedDynamicNodes)
                    {
                        area.addedDynamicNodes = true;
                        areaExtent = area.extents;
                        areaMinExtent0 = areaExtent[0];
                        areaMinExtent1 = areaExtent[1];
                        areaMinExtent2 = areaExtent[2];
                        areaMaxExtent0 = areaExtent[3];
                        areaMaxExtent1 = areaExtent[4];
                        areaMaxExtent2 = areaExtent[5];
                        combinedExtents[0] = (areaMinExtent0 < cameraMinExtent0 ? cameraMinExtent0 : areaMinExtent0);
                        combinedExtents[1] = (areaMinExtent1 < cameraMinExtent1 ? cameraMinExtent1 : areaMinExtent1);
                        combinedExtents[2] = (areaMinExtent2 < cameraMinExtent2 ? cameraMinExtent2 : areaMinExtent2);
                        combinedExtents[3] = (areaMaxExtent0 > cameraMaxExtent0 ? cameraMaxExtent0 : areaMaxExtent0);
                        combinedExtents[4] = (areaMaxExtent1 > cameraMaxExtent1 ? cameraMaxExtent1 : areaMaxExtent1);
                        combinedExtents[5] = (areaMaxExtent2 > cameraMaxExtent2 ? cameraMaxExtent2 : areaMaxExtent2);
                        dynamicSpatialMap.getOverlappingNodes(combinedExtents, nodes);
                    }

                    numNodes = nodes.length;
                    for (n = 0; n < numNodes; n += 1)
                    {
                        node = nodes[n];
                        if (node.queryCounter !== queryCounter)
                        {
                            if (isInsidePlanesAABB(node.worldExtents, portalPlanes))
                            {
                                node.queryCounter = queryCounter;
                                visibleNodes[numVisibleNodes] = node;
                                numVisibleNodes += 1;
                            }
                        }
                    }
                }

                useAABBTrees = false;
            } /*
            else
            {
                Utilities.log("Camera outside areas!");
            }*/
        }

        if (useAABBTrees)
        {
            this.staticSpatialMap.getVisibleNodes(frustumPlanes, visibleNodes);

            this.dynamicSpatialMap.getVisibleNodes(frustumPlanes, visibleNodes);
        }
    },

    //
    // findVisibleNodesTree
    //
    findVisibleNodesTree: function sceneFindVisibleNodesTreeFn(tree, camera, visibleNodes)
    {
        var frustumPlanes = this.frustumPlanes;
        var useAABBTree = true;
        var areas = this.areas;
        if (areas)
        {
            // Assume scene.update has been called before this function
            var areaIndex = this.cameraAreaIndex; //this.findAreaIndex(this.bspNodes, cX, cY, cZ);
            if (areaIndex >= 0)
            {
                //this.findVisiblePortals(areaIndex, cX, cY, cZ);

                //camera.getFrustumExtents(this.cameraExtents);
                var cameraMinExtent0 = this.cameraExtents[0];
                var cameraMinExtent1 = this.cameraExtents[1];
                var cameraMinExtent2 = this.cameraExtents[2];
                var cameraMaxExtent0 = this.cameraExtents[3];
                var cameraMaxExtent1 = this.cameraExtents[4];
                var cameraMaxExtent2 = this.cameraExtents[5];

                var areaExtent;
                var areaMinExtent0, areaMinExtent1, areaMinExtent2;
                var areaMaxExtent0, areaMaxExtent1, areaMaxExtent2;
                var combinedExtents = [];

                var area, na, nodes, numNodes;
                var numAreas = areas.length;
                for (na = 0; na < numAreas; na += 1)
                {
                    areas[na].externalNodes = null;
                }

                var isInsidePlanesAABB = this.isInsidePlanesAABB;
                var findOverlappingAreas = this.findOverlappingAreas;
                var findAreaIndex = this.findAreaIndex;
                var visiblePortals = this.visiblePortals;
                var numVisiblePortals = visiblePortals.length;
                var queryCounter = this.getQueryCounter();
                var bspNodes = this.bspNodes;
                var numVisibleNodes = visibleNodes.length;
                var portalPlanes;
                var n, node, nodeExtents, np, portalItem;
                var cX, cY, cZ, nodeAreaIndex, overlappingAreas, numOverlappingAreas;

                area = areas[areaIndex];
                nodes = area.externalNodes;

                if (!nodes)
                {
                    nodes = [];
                    area.externalNodes = nodes;

                    areaExtent = area.extents;
                    areaMinExtent0 = areaExtent[0];
                    areaMinExtent1 = areaExtent[1];
                    areaMinExtent2 = areaExtent[2];
                    areaMaxExtent0 = areaExtent[3];
                    areaMaxExtent1 = areaExtent[4];
                    areaMaxExtent2 = areaExtent[5];
                    combinedExtents[0] = (areaMinExtent0 < cameraMinExtent0 ? cameraMinExtent0 : areaMinExtent0);
                    combinedExtents[1] = (areaMinExtent1 < cameraMinExtent1 ? cameraMinExtent1 : areaMinExtent1);
                    combinedExtents[2] = (areaMinExtent2 < cameraMinExtent2 ? cameraMinExtent2 : areaMinExtent2);
                    combinedExtents[3] = (areaMaxExtent0 > cameraMaxExtent0 ? cameraMaxExtent0 : areaMaxExtent0);
                    combinedExtents[4] = (areaMaxExtent1 > cameraMaxExtent1 ? cameraMaxExtent1 : areaMaxExtent1);
                    combinedExtents[5] = (areaMaxExtent2 > cameraMaxExtent2 ? cameraMaxExtent2 : areaMaxExtent2);

                    tree.getOverlappingNodes(combinedExtents, nodes);

                    // Check which ones actually belong to the area
                    numNodes = nodes.length;
                    for (n = 0; n < numNodes; n += 1)
                    {
                        node = nodes[n];
                        nodeExtents = node.worldExtents;
                        cX = (nodeExtents[0] + nodeExtents[3]) * 0.5;
                        cY = (nodeExtents[1] + nodeExtents[4]) * 0.5;
                        cZ = (nodeExtents[2] + nodeExtents[5]) * 0.5;
                        nodeAreaIndex = findAreaIndex(bspNodes, cX, cY, cZ);
                        if (nodeAreaIndex >= 0 &&
                            areaIndex !== nodeAreaIndex)
                        {
                            overlappingAreas = findOverlappingAreas.call(this, nodeAreaIndex, nodeExtents);
                            numOverlappingAreas = overlappingAreas.length;
                            for (na = 0; na < numOverlappingAreas; na += 1)
                            {
                                if (overlappingAreas[na] === area)
                                {
                                    break;
                                }
                            }
                            if (na >= numOverlappingAreas)
                            {
                                numNodes -= 1;
                                if (n < numNodes)
                                {
                                    nodes[n] = nodes[numNodes];
                                    n -= 1; // compensate for the n += 1 on the for loop
                                }
                                else
                                {
                                    break;
                                }
                            }
                        }
                    }
                    nodes.length = numNodes;
                }

                numNodes = nodes.length;
                for (n = 0; n < numNodes; n += 1)
                {
                    node = nodes[n];
                    node.queryCounter = queryCounter;
                    if (isInsidePlanesAABB(node.worldExtents, frustumPlanes))
                    {
                        visibleNodes[numVisibleNodes] = node;
                        numVisibleNodes += 1;
                    }
                }

                for (np = 0; np < numVisiblePortals; np += 1)
                {
                    portalItem = visiblePortals[np];
                    portalPlanes = portalItem.planes;
                    areaIndex = portalItem.area;
                    area = areas[areaIndex];
                    nodes = area.externalNodes;

                    if (!nodes)
                    {
                        nodes = [];
                        area.externalNodes = nodes;

                        areaExtent = area.extents;
                        areaMinExtent0 = areaExtent[0];
                        areaMinExtent1 = areaExtent[1];
                        areaMinExtent2 = areaExtent[2];
                        areaMaxExtent0 = areaExtent[3];
                        areaMaxExtent1 = areaExtent[4];
                        areaMaxExtent2 = areaExtent[5];
                        combinedExtents[0] = (areaMinExtent0 < cameraMinExtent0 ? cameraMinExtent0 : areaMinExtent0);
                        combinedExtents[1] = (areaMinExtent1 < cameraMinExtent1 ? cameraMinExtent1 : areaMinExtent1);
                        combinedExtents[2] = (areaMinExtent2 < cameraMinExtent2 ? cameraMinExtent2 : areaMinExtent2);
                        combinedExtents[3] = (areaMaxExtent0 > cameraMaxExtent0 ? cameraMaxExtent0 : areaMaxExtent0);
                        combinedExtents[4] = (areaMaxExtent1 > cameraMaxExtent1 ? cameraMaxExtent1 : areaMaxExtent1);
                        combinedExtents[5] = (areaMaxExtent2 > cameraMaxExtent2 ? cameraMaxExtent2 : areaMaxExtent2);

                        tree.getOverlappingNodes(combinedExtents, nodes);

                        // Check which ones actually belong to the area
                        numNodes = nodes.length;
                        for (n = 0; n < numNodes; n += 1)
                        {
                            node = nodes[n];
                            nodeExtents = node.worldExtents;
                            cX = (nodeExtents[0] + nodeExtents[3]) * 0.5;
                            cY = (nodeExtents[1] + nodeExtents[4]) * 0.5;
                            cZ = (nodeExtents[2] + nodeExtents[5]) * 0.5;
                            nodeAreaIndex = findAreaIndex(bspNodes, cX, cY, cZ);
                            if (nodeAreaIndex >= 0 &&
                                areaIndex !== nodeAreaIndex)
                            {
                                overlappingAreas = findOverlappingAreas.call(this, nodeAreaIndex, nodeExtents);
                                numOverlappingAreas = overlappingAreas.length;
                                for (na = 0; na < numOverlappingAreas; na += 1)
                                {
                                    if (overlappingAreas[na] === area)
                                    {
                                        break;
                                    }
                                }
                                if (na >= numOverlappingAreas)
                                {
                                    numNodes -= 1;
                                    if (n < numNodes)
                                    {
                                        nodes[n] = nodes[numNodes];
                                        n -= 1; // compensate for the n += 1 on the for loop
                                    }
                                    else
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                        nodes.length = numNodes;
                    }

                    numNodes = nodes.length;
                    for (n = 0; n < numNodes; n += 1)
                    {
                        node = nodes[n];
                        if (node.queryCounter !== queryCounter)
                        {
                            if (isInsidePlanesAABB(node.worldExtents, portalPlanes))
                            {
                                node.queryCounter = queryCounter;
                                visibleNodes[numVisibleNodes] = node;
                                numVisibleNodes += 1;
                            }
                        }
                    }
                }

                useAABBTree = false;
            }
        }

        if (useAABBTree)
        {
            tree.getVisibleNodes(frustumPlanes, visibleNodes);
        }
    },

    //
    // buildPortalPlanesNoFrustum
    //
    buildPortalPlanesNoFrustum: function buildPortalPlanesNoFrustum(points, cX, cY, cZ)
    {
        var numPoints = points.length;
        var planes = [];
        var numPlanes = 0;
        var newPoints = [];
        var np, p;

        newPoints.length = numPoints;
        np = 0;
        do
        {
            p = points[np];
            newPoints[np] = [(p[0] - cX), (p[1] - cY), (p[2] - cZ)];
            np += 1;
        }
        while (np < numPoints);

        var sqrt = Math.sqrt;
        np = 0;
        do
        {
            p = newPoints[np];
            var p0X = p[0];
            var p0Y = p[1];
            var p0Z = p[2];

            p = newPoints[((np + 1) < numPoints ? (np + 1) : 0)];
            var p1X = p[0];
            var p1Y = p[1];
            var p1Z = p[2];

            // n = cross(p0, p1)
            var nX = ((p0Y * p1Z) - (p0Z * p1Y));
            var nY = ((p0Z * p1X) - (p0X * p1Z));
            var nZ = ((p0X * p1Y) - (p0Y * p1X));
            var lnsq = ((nX * nX) + (nY * nY) + (nZ * nZ));
            if (lnsq === 0)
            {
                return false;
            }
            var lnrcp = 1.0 / sqrt(lnsq);
            nX *= lnrcp;
            nY *= lnrcp;
            nZ *= lnrcp;

            // d = dot(n, c)
            var d = ((nX * cX) + (nY * cY) + (nZ * cZ));

            planes[numPlanes] = [nX, nY, nZ, d];
            numPlanes += 1;

            np += 1;
        }
        while (np < numPoints);

        return planes;
    },

    //
    // findOverlappingPortals
    //
    findOverlappingPortals: function sceneFindOverlappingPortalsFn(areaIndex, cX, cY, cZ, extents, overlappingPortals)
    {
        var portals, numPortals, n, portal, plane, d0, d1, d2, offset, area, portalExtents, planes;
        var buildPortalPlanesNoFrustum = this.buildPortalPlanesNoFrustum;
        var queryCounter = this.getQueryCounter();
        var areas = this.areas;
        var numOverlappingPortals = 0;

        var min0 = extents[0];
        var min1 = extents[1];
        var min2 = extents[2];
        var max0 = extents[3];
        var max1 = extents[4];
        var max2 = extents[5];

        area = areas[areaIndex];
        portals = area.portals;
        numPortals = portals.length;
        for (n = 0; n < numPortals; n += 1)
        {
            portal = portals[n];
            portal.queryCounter = queryCounter;

            portalExtents = portal.extents;
            if (portalExtents[0] < max0 &&
                portalExtents[1] < max1 &&
                portalExtents[2] < max2 &&
                portalExtents[3] > min0 &&
                portalExtents[4] > min1 &&
                portalExtents[5] > min2)
            {
                plane = portal.plane;
                d0 = plane[0];
                d1 = plane[1];
                d2 = plane[2];
                offset = plane[3];
                if (((d0 * cX) + (d1 * cY) + (d2 * cZ)) < offset &&
                    (d0 * (d0 < 0 ? min0 : max0) + d1 * (d1 < 0 ? min1 : max1) + d2 * (d2 < 0 ? min2 : max2)) >= offset)
                {
                    planes = buildPortalPlanesNoFrustum(portal.points, cX, cY, cZ);
                    if (planes)
                    {
                        overlappingPortals[numOverlappingPortals] = {
                                portal: portal,
                                planes: planes,
                                area: portal.area
                            };
                        numOverlappingPortals += 1;
                    }
                }
            }
        }

        if (0 < numOverlappingPortals)
        {
            var portalItem, parentPlanes, nextArea;
            var currentPortalIndex = 0;
            do
            {
                portalItem = overlappingPortals[currentPortalIndex];
                currentPortalIndex += 1;
                parentPlanes = portalItem.planes;
                areaIndex = portalItem.area;
                portal = portalItem.portal;

                area = areas[areaIndex];
                portals = area.portals;
                numPortals = portals.length;
                for (n = 0; n < numPortals; n += 1)
                {
                    portal = portals[n];
                    nextArea = portal.area;
                    if (nextArea !== areaIndex &&
                        portal.queryCounter !== queryCounter)
                    {
                        portalExtents = portal.extents;
                        if (portalExtents[0] < max0 &&
                            portalExtents[1] < max1 &&
                            portalExtents[2] < max2 &&
                            portalExtents[3] > min0 &&
                            portalExtents[4] > min1 &&
                            portalExtents[5] > min2)
                        {
                            plane = portal.plane;
                            d0 = plane[0];
                            d1 = plane[1];
                            d2 = plane[2];
                            offset = plane[3];
                            if (((d0 * cX) + (d1 * cY) + (d2 * cZ)) < offset &&
                                (d0 * (d0 < 0 ? min0 : max0) + d1 * (d1 < 0 ? min1 : max1) + d2 * (d2 < 0 ? min2 : max2)) >= offset)
                            {
                                planes = buildPortalPlanesNoFrustum(portal.points, cX, cY, cZ);
                                if (planes)
                                {
                                    portal.queryCounter = queryCounter;
                                    overlappingPortals[numOverlappingPortals] = {
                                            portal: portal,
                                            planes: parentPlanes.concat(planes),
                                            area: nextArea
                                        };
                                    numOverlappingPortals += 1;
                                }
                            }
                            else
                            {
                                portal.queryCounter = queryCounter;
                            }
                        }
                        else
                        {
                            portal.queryCounter = queryCounter;
                        }
                    }
                }
            }
            while (currentPortalIndex < numOverlappingPortals);
        }
    },

    //
    // findOverlappingNodes
    //
    findOverlappingNodes: function sceneFindOverlappingNodesFn(tree, origin, extents, overlappingNodes)
    {
        var useAABBTree = true;
        var areas = this.areas;
        if (areas)
        {
            // Assume scene.update has been called before this function
            var cX = origin[0];
            var cY = origin[1];
            var cZ = origin[2];
            var areaIndex = this.findAreaIndex(this.bspNodes, cX, cY, cZ);
            if (areaIndex >= 0)
            {
                var na, nodes, numNodes;
                var numAreas = areas.length;
                for (na = 0; na < numAreas; na += 1)
                {
                    areas[na].externalNodes = null;
                }

                var minExtent0 = extents[0];
                var minExtent1 = extents[1];
                var minExtent2 = extents[2];
                var maxExtent0 = extents[3];
                var maxExtent1 = extents[4];
                var maxExtent2 = extents[5];

                var area = areas[areaIndex];
                var testExtents = area.extents;
                var testMinExtent0 = testExtents[0];
                var testMinExtent1 = testExtents[1];
                var testMinExtent2 = testExtents[2];
                var testMaxExtent0 = testExtents[3];
                var testMaxExtent1 = testExtents[4];
                var testMaxExtent2 = testExtents[5];

                var overlappingPortals = [];
                this.findOverlappingPortals(areaIndex, cX, cY, cZ, extents, overlappingPortals);

                var isInsidePlanesAABB = this.isInsidePlanesAABB;
                var queryCounter = this.getQueryCounter();
                var numOverlappingPortals = overlappingPortals.length;
                var numOverlappingNodes = overlappingNodes.length;
                var portalPlanes;
                var n, node, np, portalItem;

                nodes = [];
                area.externalNodes = nodes;
                testExtents = [(testMinExtent0 > minExtent0 ? testMinExtent0 : minExtent0),
                               (testMinExtent1 > minExtent1 ? testMinExtent1 : minExtent1),
                               (testMinExtent2 > minExtent2 ? testMinExtent2 : minExtent2),
                               (testMaxExtent0 < maxExtent0 ? testMaxExtent0 : maxExtent0),
                               (testMaxExtent1 < maxExtent1 ? testMaxExtent1 : maxExtent1),
                               (testMaxExtent2 < maxExtent2 ? testMaxExtent2 : maxExtent2)];
                tree.getOverlappingNodes(testExtents, nodes);

                numNodes = nodes.length;
                for (n = 0; n < numNodes; n += 1)
                {
                    node = nodes[n];
                    node.queryCounter = queryCounter;
                    overlappingNodes[numOverlappingNodes] = node;
                    numOverlappingNodes += 1;
                }

                for (np = 0; np < numOverlappingPortals; np += 1)
                {
                    portalItem = overlappingPortals[np];
                    portalPlanes = portalItem.planes;
                    area = areas[portalItem.area];
                    nodes = area.externalNodes;

                    if (!nodes)
                    {
                        nodes = [];
                        area.externalNodes = nodes;
                        testExtents = area.extents;
                        testMinExtent0 = testExtents[0];
                        testMinExtent1 = testExtents[1];
                        testMinExtent2 = testExtents[2];
                        testMaxExtent0 = testExtents[3];
                        testMaxExtent1 = testExtents[4];
                        testMaxExtent2 = testExtents[5];

                        testExtents = [(testMinExtent0 > minExtent0 ? testMinExtent0 : minExtent0),
                                         (testMinExtent1 > minExtent1 ? testMinExtent1 : minExtent1),
                                         (testMinExtent2 > minExtent2 ? testMinExtent2 : minExtent2),
                                         (testMaxExtent0 < maxExtent0 ? testMaxExtent0 : maxExtent0),
                                         (testMaxExtent1 < maxExtent1 ? testMaxExtent1 : maxExtent1),
                                         (testMaxExtent2 < maxExtent2 ? testMaxExtent2 : maxExtent2)];
                        tree.getOverlappingNodes(testExtents, nodes);
                    }

                    numNodes = nodes.length;
                    for (n = 0; n < numNodes; n += 1)
                    {
                        node = nodes[n];
                        if (node.queryCounter !== queryCounter)
                        {
                            if (isInsidePlanesAABB(node.worldExtents, portalPlanes))
                            {
                                node.queryCounter = queryCounter;
                                overlappingNodes[numOverlappingNodes] = node;
                                numOverlappingNodes += 1;
                            }
                        }
                    }
                }

                useAABBTree = false;
            }
        }

        if (useAABBTree)
        {
            tree.getOverlappingNodes(extents, overlappingNodes);
        }
    },

    //
    // findStaticOverlappingNodes
    //
    findStaticOverlappingNodes: function sceneFindStaticOverlappingNodesFn(origin, extents, overlappingNodes)
    {
        this.findOverlappingNodes(this.staticSpatialMap, origin, extents, overlappingNodes);
    },

    //
    // findDynamicOverlappingNodes
    //
    findDynamicOverlappingNodes: function sceneFindDynamicOverlappingNodesFn(origin, extents, overlappingNodes)
    {
        this.findOverlappingNodes(this.dynamicSpatialMap, origin, extents, overlappingNodes);
    },

    //
    // findOverlappingRenderables
    //
    findOverlappingRenderables: function sceneFindOverlappingRenderablesFn(tree, origin, extents, overlappingRenderables)
    {
        var numOverlappingRenderables = overlappingRenderables.length;
        var minExtent0 = extents[0];
        var minExtent1 = extents[1];
        var minExtent2 = extents[2];
        var maxExtent0 = extents[3];
        var maxExtent1 = extents[4];
        var maxExtent2 = extents[5];

        var overlappingNodes = [];
        var useAABBTree = true;
        var areas = this.areas;

        var node;
        var numNodes;
        var nodeIndex;
        var renderable;
        var renderables;
        var numRenderables;
        var nodeExtents;
        var renderableIndex;
        var renderableExtents;

        if (areas)
        {
            // Assume scene.update has been called before this function
            var cX = origin[0];
            var cY = origin[1];
            var cZ = origin[2];
            var areaIndex = this.findAreaIndex(this.bspNodes, cX, cY, cZ);
            if (areaIndex >= 0)
            {
                var na, nodes;
                var numAreas = areas.length;
                for (na = 0; na < numAreas; na += 1)
                {
                    areas[na].externalNodes = null;
                }

                var area = areas[areaIndex];
                var testExtents = area.extents;
                var testMinExtent0 = testExtents[0];
                var testMinExtent1 = testExtents[1];
                var testMinExtent2 = testExtents[2];
                var testMaxExtent0 = testExtents[3];
                var testMaxExtent1 = testExtents[4];
                var testMaxExtent2 = testExtents[5];

                var overlappingPortals = [];
                this.findOverlappingPortals(areaIndex, cX, cY, cZ, extents, overlappingPortals);

                var isInsidePlanesAABB = this.isInsidePlanesAABB;
                var isFullyInsidePlanesAABB = this.isFullyInsidePlanesAABB;
                var queryCounter = this.getQueryCounter();
                var numOverlappingPortals = overlappingPortals.length;
                var portalPlanes;
                var n, np, portalItem;
                var allVisible;

                nodes = [];
                area.externalNodes = nodes;
                testExtents = [(testMinExtent0 > minExtent0 ? testMinExtent0 : minExtent0),
                               (testMinExtent1 > minExtent1 ? testMinExtent1 : minExtent1),
                               (testMinExtent2 > minExtent2 ? testMinExtent2 : minExtent2),
                               (testMaxExtent0 < maxExtent0 ? testMaxExtent0 : maxExtent0),
                               (testMaxExtent1 < maxExtent1 ? testMaxExtent1 : maxExtent1),
                               (testMaxExtent2 < maxExtent2 ? testMaxExtent2 : maxExtent2)];
                tree.getOverlappingNodes(testExtents, nodes);

                numNodes = nodes.length;
                for (nodeIndex = 0; nodeIndex < numNodes; nodeIndex += 1)
                {
                    node = nodes[nodeIndex];
                    node.queryCounter = queryCounter;
                    renderables = node.renderables;
                    if (renderables)
                    {
                        numRenderables = renderables.length;
                        if (numRenderables === 1)
                        {
                            overlappingRenderables[numOverlappingRenderables] = renderables[0];
                            numOverlappingRenderables += 1;
                        }
                        else
                        {
                            // Check if node is fully inside
                            nodeExtents = node.worldExtents;
                            if (nodeExtents[0] >= minExtent0 &&
                                nodeExtents[1] >= minExtent1 &&
                                nodeExtents[2] >= minExtent2 &&
                                nodeExtents[3] <= maxExtent0 &&
                                nodeExtents[4] <= maxExtent1 &&
                                nodeExtents[5] <= maxExtent2)
                            {
                                for (renderableIndex = 0; renderableIndex < numRenderables; renderableIndex += 1)
                                {
                                    overlappingRenderables[numOverlappingRenderables] = renderables[renderableIndex];
                                    numOverlappingRenderables += 1;
                                }
                            }
                            else
                            {
                                for (renderableIndex = 0; renderableIndex < numRenderables; renderableIndex += 1)
                                {
                                    renderable = renderables[renderableIndex];
                                    renderableExtents = renderable.getWorldExtents();
                                    if (renderableExtents[3] >= minExtent0 &&
                                        renderableExtents[4] >= minExtent1 &&
                                        renderableExtents[5] >= minExtent2 &&
                                        renderableExtents[0] <= maxExtent0 &&
                                        renderableExtents[1] <= maxExtent1 &&
                                        renderableExtents[2] <= maxExtent2)
                                    {
                                        overlappingRenderables[numOverlappingRenderables] = renderable;
                                        numOverlappingRenderables += 1;
                                    }
                                }
                            }
                        }
                    }
                }

                for (np = 0; np < numOverlappingPortals; np += 1)
                {
                    portalItem = overlappingPortals[np];
                    portalPlanes = portalItem.planes;
                    area = areas[portalItem.area];
                    nodes = area.externalNodes;

                    if (!nodes)
                    {
                        nodes = [];
                        area.externalNodes = nodes;
                        testExtents = area.extents;
                        testMinExtent0 = testExtents[0];
                        testMinExtent1 = testExtents[1];
                        testMinExtent2 = testExtents[2];
                        testMaxExtent0 = testExtents[3];
                        testMaxExtent1 = testExtents[4];
                        testMaxExtent2 = testExtents[5];

                        testExtents = [(testMinExtent0 > minExtent0 ? testMinExtent0 : minExtent0),
                                       (testMinExtent1 > minExtent1 ? testMinExtent1 : minExtent1),
                                       (testMinExtent2 > minExtent2 ? testMinExtent2 : minExtent2),
                                       (testMaxExtent0 < maxExtent0 ? testMaxExtent0 : maxExtent0),
                                       (testMaxExtent1 < maxExtent1 ? testMaxExtent1 : maxExtent1),
                                       (testMaxExtent2 < maxExtent2 ? testMaxExtent2 : maxExtent2)];
                        tree.getOverlappingNodes(testExtents, nodes);
                    }

                    numNodes = nodes.length;
                    for (n = 0; n < numNodes; n += 1)
                    {
                        node = nodes[n];
                        if (node.queryCounter !== queryCounter)
                        {
                            allVisible = true;

                            renderables = node.renderables;
                            if (renderables)
                            {
                                nodeExtents = node.worldExtents;
                                if (isInsidePlanesAABB(nodeExtents, portalPlanes))
                                {
                                    numRenderables = renderables.length;
                                    if (numRenderables === 1)
                                    {
                                        renderable = renderables[0];
                                        if (renderable.queryCounter !== queryCounter)
                                        {
                                            renderable.queryCounter = queryCounter;
                                            overlappingRenderables[numOverlappingRenderables] = renderable;
                                            numOverlappingRenderables += 1;
                                        }
                                    }
                                    else
                                    {
                                        // Check if node is fully inside
                                        if (nodeExtents[0] >= minExtent0 &&
                                            nodeExtents[1] >= minExtent1 &&
                                            nodeExtents[2] >= minExtent2 &&
                                            nodeExtents[3] <= maxExtent0 &&
                                            nodeExtents[4] <= maxExtent1 &&
                                            nodeExtents[5] <= maxExtent2)
                                        {
                                            if (isFullyInsidePlanesAABB(nodeExtents, portalPlanes))
                                            {
                                                for (renderableIndex = 0; renderableIndex < numRenderables; renderableIndex += 1)
                                                {
                                                    renderable = renderables[renderableIndex];
                                                    if (renderable.queryCounter !== queryCounter)
                                                    {
                                                        renderable.queryCounter = queryCounter;
                                                        overlappingRenderables[numOverlappingRenderables] = renderable;
                                                        numOverlappingRenderables += 1;
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                for (renderableIndex = 0; renderableIndex < numRenderables; renderableIndex += 1)
                                                {
                                                    renderable = renderables[renderableIndex];
                                                    if (renderable.queryCounter !== queryCounter)
                                                    {
                                                        if (isInsidePlanesAABB(renderable.getWorldExtents(), portalPlanes))
                                                        {
                                                            renderable.queryCounter = queryCounter;
                                                            overlappingRenderables[numOverlappingRenderables] = renderable;
                                                            numOverlappingRenderables += 1;
                                                        }
                                                        else
                                                        {
                                                            allVisible = false;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        else
                                        {
                                            if (isFullyInsidePlanesAABB(nodeExtents, portalPlanes))
                                            {
                                                for (renderableIndex = 0; renderableIndex < numRenderables; renderableIndex += 1)
                                                {
                                                    renderable = renderables[renderableIndex];
                                                    if (renderable.queryCounter !== queryCounter)
                                                    {
                                                        renderableExtents = renderable.getWorldExtents();
                                                        if (renderableExtents[3] >= minExtent0 &&
                                                            renderableExtents[4] >= minExtent1 &&
                                                            renderableExtents[5] >= minExtent2 &&
                                                            renderableExtents[0] <= maxExtent0 &&
                                                            renderableExtents[1] <= maxExtent1 &&
                                                            renderableExtents[2] <= maxExtent2)
                                                        {
                                                            renderable.queryCounter = queryCounter;
                                                            overlappingRenderables[numOverlappingRenderables] = renderable;
                                                            numOverlappingRenderables += 1;
                                                        }
                                                        else
                                                        {
                                                            allVisible = false;
                                                        }
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                for (renderableIndex = 0; renderableIndex < numRenderables; renderableIndex += 1)
                                                {
                                                    renderable = renderables[renderableIndex];
                                                    if (renderable.queryCounter !== queryCounter)
                                                    {
                                                        renderableExtents = renderable.getWorldExtents();
                                                        if (renderableExtents[3] >= minExtent0 &&
                                                            renderableExtents[4] >= minExtent1 &&
                                                            renderableExtents[5] >= minExtent2 &&
                                                            renderableExtents[0] <= maxExtent0 &&
                                                            renderableExtents[1] <= maxExtent1 &&
                                                            renderableExtents[2] <= maxExtent2 &&
                                                            isInsidePlanesAABB(renderableExtents, portalPlanes))
                                                        {
                                                            renderable.queryCounter = queryCounter;
                                                            overlappingRenderables[numOverlappingRenderables] = renderable;
                                                            numOverlappingRenderables += 1;
                                                        }
                                                        else
                                                        {
                                                            allVisible = false;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    allVisible = false;
                                }
                            }

                            if (allVisible)
                            {
                                node.queryCounter = queryCounter;
                            }
                        }
                    }
                }
                useAABBTree = false;
            }
        }

        if (useAABBTree)
        {
            tree.getOverlappingNodes(extents, overlappingNodes);
            numNodes = overlappingNodes.length;
            for (nodeIndex = 0; nodeIndex < numNodes; nodeIndex += 1)
            {
                node = overlappingNodes[nodeIndex];
                renderables = node.renderables;
                if (renderables)
                {
                    numRenderables = renderables.length;
                    if (numRenderables === 1)
                    {
                        overlappingRenderables[numOverlappingRenderables] = renderables[0];
                        numOverlappingRenderables += 1;
                    }
                    else
                    {
                        // Check if node is fully inside
                        nodeExtents = node.worldExtents;
                        if (nodeExtents[0] >= minExtent0 &&
                            nodeExtents[1] >= minExtent1 &&
                            nodeExtents[2] >= minExtent2 &&
                            nodeExtents[3] <= maxExtent0 &&
                            nodeExtents[4] <= maxExtent1 &&
                            nodeExtents[5] <= maxExtent2)
                        {
                            for (renderableIndex = 0; renderableIndex < numRenderables; renderableIndex += 1)
                            {
                                overlappingRenderables[numOverlappingRenderables] = renderables[renderableIndex];
                                numOverlappingRenderables += 1;
                            }
                        }
                        else
                        {
                            for (renderableIndex = 0; renderableIndex < numRenderables; renderableIndex += 1)
                            {
                                renderable = renderables[renderableIndex];
                                renderableExtents = renderable.getWorldExtents();
                                if (renderableExtents[3] >= minExtent0 &&
                                    renderableExtents[4] >= minExtent1 &&
                                    renderableExtents[5] >= minExtent2 &&
                                    renderableExtents[0] <= maxExtent0 &&
                                    renderableExtents[1] <= maxExtent1 &&
                                    renderableExtents[2] <= maxExtent2)
                                {
                                    overlappingRenderables[numOverlappingRenderables] = renderable;
                                    numOverlappingRenderables += 1;
                                }
                            }
                        }
                    }
                }
            }
        }
    },

    //
    // findStaticOverlappingRenderables
    //
    findStaticOverlappingRenderables: function sceneFindStaticOverlappingRenderablesFn(origin, extents, overlappingRenderables)
    {
        this.findOverlappingRenderables(this.staticSpatialMap, origin, extents, overlappingRenderables);
    },

    //
    // findDynamicOverlappingRenderables
    //
    findDynamicOverlappingRenderables: function sceneFindDynamicOverlappingRenderablesFn(origin, extents, overlappingRenderables)
    {
        this.findOverlappingRenderables(this.dynamicSpatialMap, origin, extents, overlappingRenderables);
    },

    //
    // cloneRootNode
    //
    cloneRootNode: function cloneRootNodeFn(rootNode, newInstanceName)
    {
        var newNode = rootNode.clone(newInstanceName);
        this.addRootNode(newNode);
        return newNode;
    },

    //
    // updateVisibleNodes
    //
    updateVisibleNodes: function sceneUpdateVisibleNodesFn(camera)
    {
        var visibleNodes = this.visibleNodes;
        visibleNodes.length = 0;
        var numVisibleNodes = 0;

        var visibleRenderables = this.visibleRenderables;
        this.visibleRenderables.length = 0;
        var numVisibleRenderables = 0;

        var visibleLights = this.visibleLights;
        this.visibleLights.length = 0;
        var numVisibleLights = 0;

        this.extractFrustumPlanes(camera);

        var frameIndex = this.frameIndex;
        var maxDistance = 0;
        var nearPlane = this.nearPlane;
        var d0 = nearPlane[0];
        var d1 = nearPlane[1];
        var d2 = nearPlane[2];
        var offset = nearPlane[3];
        var n = 0;
        var node;

        var queryCounter = this.getQueryCounter();
        var isInsidePlanesAABB = this.isInsidePlanesAABB;
        var isFullyInsidePlanesAABB = this.isFullyInsidePlanesAABB;

        //
        // sceneProcessVisibleNodeFn helper
        //
        function sceneProcessVisibleNodeFn(node, planes, cameraExtents)
        {
            var n0, n1, n2, p0, p1, p2, distance;
            var extents = node.worldExtents;
            var allVisible = true;

            if (node.frameVisible !== frameIndex)
            {
                node.frameVisible = frameIndex;

                n0 = extents[0];
                n1 = extents[1];
                n2 = extents[2];
                p0 = extents[3];
                p1 = extents[4];
                p2 = extents[5];

                // Frustum tests do return some false positives, check bounding boxes
                if (cameraExtents[3] > n0 &&
                    cameraExtents[4] > n1 &&
                    cameraExtents[5] > n2 &&
                    p0 > cameraExtents[0] &&
                    p1 > cameraExtents[1] &&
                    p2 > cameraExtents[2])
                {
                    distance = ((d0 * (d0 > 0 ? p0 : n0)) + (d1 * (d1 > 0 ? p1 : n1)) + (d2 * (d2 > 0 ? p2 : n2)) - offset);
                }
                else
                {
                    distance = -1;
                }

                node.distance = distance;
                if (0 < distance)
                {
                    //This signifies any part of the node is visible, but not necessarily all.
                    visibleNodes[numVisibleNodes] = node;
                    numVisibleNodes += 1;
                }
            }
            else
            {
                distance = node.distance;
            }

            if (0 < distance)
            {
                if (!node.disabled)
                {
                    var renderable, i, lightInstance, l;
                    var renderables = node.renderables;
                    var numRenderables = (renderables ? renderables.length : 0);

                    var lights = node.lightInstances;
                    var numLights = (lights ? lights.length : 0);

                    var fullyVisible = (1 < (numLights + numRenderables) ?
                                        isFullyInsidePlanesAABB(extents, planes) :
                                        false);

                    if (renderables)
                    {
                        if (numRenderables === 1 && !lights)
                        {
                            for (i = 0; i < numRenderables; i += 1)
                            {
                                renderable = renderables[i];
                                if (!renderable.disabled &&
                                    renderable.queryCounter !== queryCounter)
                                {
                                    if (maxDistance < distance)
                                    {
                                        maxDistance = distance;
                                    }
                                    renderable.distance = distance;
                                    renderable.frameVisible = frameIndex;
                                    renderable.queryCounter = queryCounter;
                                    visibleRenderables[numVisibleRenderables] = renderable;
                                    numVisibleRenderables += 1;
                                }
                            }
                        }
                        else
                        {
                            for (i = 0; i < numRenderables; i += 1)
                            {
                                renderable = renderables[i];
                                if (!renderable.disabled &&
                                    renderable.queryCounter !== queryCounter)
                                {
                                    extents = renderable.getWorldExtents();
                                    if (fullyVisible || isInsidePlanesAABB(extents, planes))
                                    {
                                        n0 = extents[0];
                                        n1 = extents[1];
                                        n2 = extents[2];
                                        p0 = extents[3];
                                        p1 = extents[4];
                                        p2 = extents[5];

                                        // Frustum tests do return some false positives, check bounding boxes
                                        if (fullyVisible ||
                                            (cameraExtents[3] > n0 &&
                                             cameraExtents[4] > n1 &&
                                             cameraExtents[5] > n2 &&
                                             p0 > cameraExtents[0] &&
                                             p1 > cameraExtents[1] &&
                                             p2 > cameraExtents[2]))
                                        {
                                            distance = ((d0 * (d0 > 0 ? p0 : n0)) + (d1 * (d1 > 0 ? p1 : n1)) + (d2 * (d2 > 0 ? p2 : n2)) - offset);
                                        }
                                        else
                                        {
                                            distance -= 1;
                                        }

                                        if (0 < distance)
                                        {
                                            if (maxDistance < distance)
                                            {
                                                maxDistance = distance;
                                            }
                                            renderable.distance = distance;
                                            renderable.frameVisible = frameIndex;
                                            renderable.queryCounter = queryCounter;
                                            visibleRenderables[numVisibleRenderables] = renderable;
                                            numVisibleRenderables += 1;
                                        }
                                        else
                                        {
                                            allVisible = false;
                                        }
                                    }
                                    else
                                    {
                                        allVisible = false;
                                    }
                                }
                            }
                        }
                    }

                    if (lights)
                    {
                        if (numLights === 1 && !renderables)
                        {
                            for (l = 0; l < numLights; l += 1)
                            {
                                lightInstance = lights[l];
                                if (!lightInstance.disabled &&
                                    lightInstance.queryCounter !== queryCounter &&
                                    !lightInstance.light.isGlobal())
                                {
                                    lightInstance.distance = distance;
                                    lightInstance.frameVisible = frameIndex;
                                    lightInstance.queryCounter = queryCounter;
                                    visibleLights[numVisibleLights] = lightInstance;
                                    numVisibleLights += 1;
                                }
                            }
                        }
                        else
                        {
                            for (l = 0; l < numLights; l += 1)
                            {
                                lightInstance = lights[l];
                                if (!lightInstance.disabled &&
                                    lightInstance.queryCounter !== queryCounter &&
                                    !lightInstance.light.isGlobal())
                                {
                                    extents = lightInstance.getWorldExtents();
                                    if (fullyVisible || isInsidePlanesAABB(extents, planes))
                                    {
                                        n0 = extents[0];
                                        n1 = extents[1];
                                        n2 = extents[2];
                                        p0 = extents[3];
                                        p1 = extents[4];
                                        p2 = extents[5];

                                        // Frustum tests do return some false positives, check bounding boxes
                                        if (fullyVisible ||
                                            (cameraExtents[3] > n0 &&
                                             cameraExtents[4] > n1 &&
                                             cameraExtents[5] > n2 &&
                                             p0 > cameraExtents[0] &&
                                             p1 > cameraExtents[1] &&
                                             p2 > cameraExtents[2]))
                                        {
                                            distance = ((d0 * (d0 > 0 ? p0 : n0)) + (d1 * (d1 > 0 ? p1 : n1)) + (d2 * (d2 > 0 ? p2 : n2)) - offset);
                                        }
                                        else
                                        {
                                            distance -= 1;
                                        }

                                        if (0 < distance)
                                        {
                                            lightInstance.distance = distance;
                                            lightInstance.frameVisible = frameIndex;
                                            lightInstance.queryCounter = queryCounter;
                                            visibleLights[numVisibleLights] = lightInstance;
                                            numVisibleLights += 1;
                                        }
                                        else
                                        {
                                            allVisible = false;
                                        }
                                    }
                                    else
                                    {
                                        allVisible = false;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (allVisible)
            {
                node.queryCounter = queryCounter;
            }
        }

        // findVisibleNodes
        var cameraExtents = this.cameraExtents;
        camera.getFrustumExtents(cameraExtents);

        var frustumPlanes = this.frustumPlanes;
        var useAABBTrees = true;
        var areas = this.areas;
        if (areas)
        {
            var cameraMatrix = camera.matrix;
            var cX = cameraMatrix[9];
            var cY = cameraMatrix[10];
            var cZ = cameraMatrix[11];

            var areaIndex = this.findAreaIndex(this.bspNodes, cX, cY, cZ);
            this.cameraAreaIndex = areaIndex;

            if (areaIndex >= 0)
            {
                var cameraMinExtent0 = cameraExtents[0];
                var cameraMinExtent1 = cameraExtents[1];
                var cameraMinExtent2 = cameraExtents[2];
                var cameraMaxExtent0 = cameraExtents[3];
                var cameraMaxExtent1 = cameraExtents[4];
                var cameraMaxExtent2 = cameraExtents[5];

                this.findVisiblePortals(areaIndex, cX, cY, cZ);

                var area, na, nodes, numNodes;
                var numAreas = areas.length;
                for (na = 0; na < numAreas; na += 1)
                {
                    area = areas[na];
                    nodes = area.nodes;
                    numNodes = area.numStaticNodes;
                    if (nodes.length > numNodes)
                    {
                        nodes.length = numNodes;
                    }
                    area.addedDynamicNodes = false;
                }

                var dynamicSpatialMap = this.dynamicSpatialMap;
                var visiblePortals = this.visiblePortals;
                var numVisiblePortals = visiblePortals.length;

                var np, portalItem, portalPlanes;

                area = areas[areaIndex];
                nodes = area.nodes;
                area.addedDynamicNodes = true;

                var areaExtent = area.extents;
                var areaMinExtent0 = areaExtent[0];
                var areaMinExtent1 = areaExtent[1];
                var areaMinExtent2 = areaExtent[2];
                var areaMaxExtent0 = areaExtent[3];
                var areaMaxExtent1 = areaExtent[4];
                var areaMaxExtent2 = areaExtent[5];
                var combinedExtents = [(areaMinExtent0 < cameraMinExtent0 ? cameraMinExtent0 : areaMinExtent0),
                                       (areaMinExtent1 < cameraMinExtent1 ? cameraMinExtent1 : areaMinExtent1),
                                       (areaMinExtent2 < cameraMinExtent2 ? cameraMinExtent2 : areaMinExtent2),
                                       (areaMaxExtent0 > cameraMaxExtent0 ? cameraMaxExtent0 : areaMaxExtent0),
                                       (areaMaxExtent1 > cameraMaxExtent1 ? cameraMaxExtent1 : areaMaxExtent1),
                                       (areaMaxExtent2 > cameraMaxExtent2 ? cameraMaxExtent2 : areaMaxExtent2)];
                dynamicSpatialMap.getOverlappingNodes(combinedExtents, nodes);

                numNodes = nodes.length;
                for (n = 0; n < numNodes; n += 1)
                {
                    node = nodes[n];
                    node.queryCounter = queryCounter;
                    if (isInsidePlanesAABB(node.worldExtents, frustumPlanes))
                    {
                        sceneProcessVisibleNodeFn(node, frustumPlanes, cameraExtents);
                    }
                }

                for (np = 0; np < numVisiblePortals; np += 1)
                {
                    portalItem = visiblePortals[np];
                    portalPlanes = portalItem.planes;
                    area = areas[portalItem.area];
                    nodes = area.nodes;

                    // Frustum tests do return some false positives, check bounding boxes
                    areaExtent = area.extents;
                    areaMinExtent0 = areaExtent[0];
                    areaMinExtent1 = areaExtent[1];
                    areaMinExtent2 = areaExtent[2];
                    areaMaxExtent0 = areaExtent[3];
                    areaMaxExtent1 = areaExtent[4];
                    areaMaxExtent2 = areaExtent[5];
                    if (cameraMaxExtent0 > areaMinExtent0 &&
                        cameraMaxExtent1 > areaMinExtent1 &&
                        cameraMaxExtent2 > areaMinExtent2 &&
                        areaMaxExtent0 > cameraMinExtent0 &&
                        areaMaxExtent1 > cameraMinExtent1 &&
                        areaMaxExtent2 > cameraMinExtent2)
                    {
                        if (!area.addedDynamicNodes)
                        {
                            area.addedDynamicNodes = true;
                            combinedExtents[0] = (areaMinExtent0 < cameraMinExtent0 ? cameraMinExtent0 : areaMinExtent0);
                            combinedExtents[1] = (areaMinExtent1 < cameraMinExtent1 ? cameraMinExtent1 : areaMinExtent1);
                            combinedExtents[2] = (areaMinExtent2 < cameraMinExtent2 ? cameraMinExtent2 : areaMinExtent2);
                            combinedExtents[3] = (areaMaxExtent0 > cameraMaxExtent0 ? cameraMaxExtent0 : areaMaxExtent0);
                            combinedExtents[4] = (areaMaxExtent1 > cameraMaxExtent1 ? cameraMaxExtent1 : areaMaxExtent1);
                            combinedExtents[5] = (areaMaxExtent2 > cameraMaxExtent2 ? cameraMaxExtent2 : areaMaxExtent2);
                            dynamicSpatialMap.getOverlappingNodes(combinedExtents, nodes);
                        }

                        numNodes = nodes.length;
                        for (n = 0; n < numNodes; n += 1)
                        {
                            node = nodes[n];
                            if (node.queryCounter !== queryCounter)
                            {
                                if (isInsidePlanesAABB(node.worldExtents, portalPlanes))
                                {
                                    sceneProcessVisibleNodeFn(node, portalPlanes, cameraExtents);
                                }
                            }
                        }
                    }
                }

                useAABBTrees = false;
            }
        }

        if (useAABBTrees)
        {
            var queryVisibleNodes = [];
            this.staticSpatialMap.getVisibleNodes(frustumPlanes, queryVisibleNodes);
            this.dynamicSpatialMap.getVisibleNodes(frustumPlanes, queryVisibleNodes);
            var numQueryVisibleNodes = queryVisibleNodes.length;
            if (numQueryVisibleNodes)
            {
                n = 0;
                do
                {
                    sceneProcessVisibleNodeFn(queryVisibleNodes[n], frustumPlanes, cameraExtents);
                    n += 1;
                }
                while (n < numQueryVisibleNodes);
            }
        }

        this.maxDistance = (maxDistance + camera.nearPlane);
        this.frameIndex += 1;
    },

    //
    // getCurrentVisibleNodes
    //
    getCurrentVisibleNodes: function sceneGetCurrentVisibleNodesFn()
    {
        return this.visibleNodes;
    },

    //
    // getCurrentVisibleRenderables
    //
    getCurrentVisibleRenderables: function sceneGetCurrentVisibleRenderablesFn()
    {
        return this.visibleRenderables;
    },

    //
    // getCurrentVisibleLights
    //
    getCurrentVisibleLights: function sceneGetCurrentVisibleLightsFn()
    {
        return this.visibleLights;
    },

    //
    // updateNodes
    //
    updateNodes: function sceneUpdateNodesFn()
    {
        var dirtyRoots = this.dirtyRoots;
        if (dirtyRoots)
        {
            var nodesToUpdate = [];
            var numNodesToUpdate = 0;
            for (var root in dirtyRoots)
            {
                if (dirtyRoots.hasOwnProperty(root))
                {
                    nodesToUpdate[numNodesToUpdate] = dirtyRoots[root];
                    numNodesToUpdate += 1;
                }
            }
            delete this.dirtyRoots;
            dirtyRoots = null;
            if (0 < numNodesToUpdate)
            {
                SceneNode.prototype.updateHelper(this.md, this, nodesToUpdate);
            }
        }
    },

    //
    // update
    //
    update: function sceneUpdateFn()
    {
        this.updateNodes();
        this.staticSpatialMap.finalize();
        this.dynamicSpatialMap.finalize();
        this.updateExtents();

        if (this.areas &&
            this.staticNodesChangeCounter !== this.areaInitalizeStaticNodesChangeCounter)
        {
            //Note this leaves extents of areas as large as they ever got.
            this.initializeAreas();
        }
    },

    //
    // updateExtents
    //
    updateExtents: function sceneUpdateExtentsFn()
    {
        var rootStaticNode = this.staticSpatialMap.getRootNode();
        var rootDynamicNode = this.dynamicSpatialMap.getRootNode();

        var extents;
        if (rootStaticNode)
        {
            extents = rootStaticNode.extents;

            if (rootDynamicNode)
            {
                var minStaticX, minStaticY, minStaticZ, maxStaticX, maxStaticY, maxStaticZ;
                var minDynamicX, minDynamicY, minDynamicZ, maxDynamicX, maxDynamicY, maxDynamicZ;

                minStaticX = extents[0];
                minStaticY = extents[1];
                minStaticZ = extents[2];
                maxStaticX = extents[3];
                maxStaticY = extents[4];
                maxStaticZ = extents[5];

                extents = rootDynamicNode.extents;
                minDynamicX = extents[0];
                minDynamicY = extents[1];
                minDynamicZ = extents[2];
                maxDynamicX = extents[3];
                maxDynamicY = extents[4];
                maxDynamicZ = extents[5];

                this.extents = [(minStaticX < minDynamicX ? minStaticX : minDynamicX),
                                  (minStaticY < minDynamicY ? minStaticY : minDynamicY),
                                  (minStaticZ < minDynamicZ ? minStaticZ : minDynamicZ),
                                  (maxStaticX > maxDynamicX ? maxStaticX : maxDynamicX),
                                  (maxStaticY > maxDynamicY ? maxStaticY : maxDynamicY),
                                  (maxStaticZ > maxDynamicZ ? maxStaticZ : maxDynamicZ)];
            }
            else
            {
                this.extents = extents.slice();
            }
        }
        else
        {
            if (rootDynamicNode)
            {
                this.extents = rootDynamicNode.extents.slice();
            }
            else
            {
                this.extents = [0, 0, 0, 0, 0, 0];
            }
        }
    },

    //
    //  getExtents
    //
    getExtents: function sceneGetExtentsFn()
    {
        if (this.dirtyRoots)
        {
            this.updateNodes();
            this.staticSpatialMap.finalize();
            this.dynamicSpatialMap.finalize();
            this.updateExtents();
        }
        return this.extents;
    },

    //
    //  loadMaterial
    //
    loadMaterial: function loadMaterialFn(graphicsDevice, textureManager, effectManager, materialName, material)
    {
        var materials = this.materials;

        // Check materials if the materialName has already been added
        if (!materials[materialName])
        {
            var effectName = material.effect || "default";
            var newMaterial = this.createMaterial(materialName, material, effectName, null, null, graphicsDevice);
            if (newMaterial)
            {
                delete newMaterial.effectName;
                var effect = effectManager.get(effectName);
                if (effect)
                {
                    effect.prepareMaterial(newMaterial);
                }
                newMaterial.loadTextures(textureManager);
                return true;
            }
        }
        return false;
    },

    //
    // hasMaterial
    //
    hasMaterial: function sceneHasMaterialFn(materialName)
    {
        var material = this.materials[materialName];
        if (material)
        {
            return true;
        }
        return false;
    },

    //
    // getMaterial
    //
    getMaterial: function sceneGetMaterialFn(materialName)
    {
        return this.materials[materialName];
    },

    //
    // Draw nodes with same technique, mostly for debugging
    //
    drawNodesArray: function sceneDrawNodesArrayFn(nodes, gd, globalMaterial, technique, renderUpdate)
    {
        var numNodes = nodes.length;
        if (numNodes > 0)
        {
            var setTechnique = gd.setTechnique;
            var setTechniqueParameters = gd.setTechniqueParameters;
            var setStream = gd.setStream;
            var setIndexBuffer = gd.setIndexBuffer;
            var drawIndexed = gd.drawIndexed;
            var draw = gd.draw;
            var currentSharedTechniqueParameters = null;
            var currentVertexBuffer = null;
            var currentSemantics = null;
            var node, shape, sharedTechniqueParameters, techniqueParameters, vertexBuffer, semantics, surface, indexBuffer;
            var renderables, renderable, numRenderables, i;
            var n = 0;
            setTechnique.call(gd, technique);
            setTechniqueParameters.call(gd, globalMaterial);
            do
            {
                node = nodes[n];
                renderables = node.renderables;
                if (renderables)
                {
                    numRenderables = renderables.length;
                    for (i = 0; i < numRenderables; i += 1)
                    {
                        renderable = renderables[i];

                        renderUpdate.call(renderable);

                        shape = renderable.geometry;
                        vertexBuffer = shape.vertexBuffer;
                        semantics = shape.semantics;
                        surface = renderable.surface;
                        sharedTechniqueParameters = renderable.sharedMaterial.techniqueParameters;
                        techniqueParameters = renderable.techniqueParameters;

                        if (currentSharedTechniqueParameters !== sharedTechniqueParameters)
                        {
                            currentSharedTechniqueParameters = sharedTechniqueParameters;
                            setTechniqueParameters.call(gd, sharedTechniqueParameters, techniqueParameters);
                        }
                        else
                        {
                            setTechniqueParameters.call(gd, techniqueParameters);
                        }

                        if (currentVertexBuffer !== vertexBuffer ||
                            currentSemantics !== semantics)
                        {
                            currentVertexBuffer = vertexBuffer;
                            currentSemantics = semantics;
                            setStream.call(gd, vertexBuffer, semantics);
                        }

                        indexBuffer = surface.indexBuffer;
                        if (indexBuffer)
                        {
                            setIndexBuffer.call(gd, indexBuffer);

                            drawIndexed.call(gd, surface.primitive, surface.numIndices, surface.first);
                        }
                        else
                        {
                            //Utilities.log("" + surface.primitive + " ," + surface.numVertices + " ," + surface.first);
                            draw.call(gd, surface.primitive, surface.numVertices, surface.first);
                        }
                    }
                }

                n += 1;
            }
            while (n < numNodes);
        }
    },

    drawVisibleNodes: function sceneDrawVisibleNodesFn(gd, globalTechniqueParameters, technique, renderUpdate)
    {
        this.drawNodesArray(this.visibleNodes, gd, globalTechniqueParameters, technique, renderUpdate);
    },

    //
    // clearMaterials
    //
    clearMaterials: function sceneClearMaterialsFn()
    {
        var onMaterialDestroyed = this.onMaterialDestroyed;
        var materials = this.materials;
        if (materials)
        {
            for (var p in materials)
            {
                if (materials.hasOwnProperty(p))
                {
                    materials[p].reference.unsubscribeDestroyed(onMaterialDestroyed);
                }
            }
        }
        this.materials = {};
    },

    //
    // clearShapes
    //
    clearShapes: function sceneClearShapesFn()
    {
        var onGeometryDestroyed = this.onGeometryDestroyed;
        var shapes = this.shapes;
        if (shapes)
        {
            for (var p in shapes)
            {
                if (shapes.hasOwnProperty(p))
                {
                    shapes[p].reference.unsubscribeDestroyed(onGeometryDestroyed);
                }
            }
        }
        this.shapes = {};
    },

    //
    // clearShapesVertexData
    //
    clearShapesVertexData: function sceneClearShapesVertexDataFn()
    {
        var shapes = this.shapes;
        var shape;
        if (shapes)
        {
            for (var p in shapes)
            {
                if (shapes.hasOwnProperty(p))
                {
                    shape = shapes[p];
                    delete shape.vertexData;
                    delete shape.indexData;
                    var surfaces = shape.surfaces;
                    if (surfaces)
                    {
                        for (var s in surfaces)
                        {
                            if (surfaces.hasOwnProperty(s))
                            {
                                var surface = surfaces[s];
                                delete surface.vertexData;
                                delete surface.indexData;
                            }
                        }
                    }
                }
            }
        }
    },

    //
    // clearRootNodes
    //
    clearRootNodes: function sceneRootNodesFn()
    {
        var rootNodes = this.rootNodes;
        if (rootNodes)
        {
            var rootLength = rootNodes.length;
            for (var rootIndex = 0; rootIndex < rootLength; rootIndex += 1)
            {
                rootNodes[rootIndex].destroy();
            }
        }
        this.rootNodes = [];
        delete this.dirtyRoots;
        this.rootNodesMap = {};
    },

    //
    // clear
    //
    clear: function sceneClearFn()
    {
        this.effects = [];
        this.effectsMap = {};
        this.semantics = {};
        this.lights = {};
        this.globalLights = [];
        this.clearRootNodes();
        this.clearMaterials();
        this.clearShapes();
        this.staticSpatialMap = AABBTree.create(true);
        this.dynamicSpatialMap = AABBTree.create();
        this.frustumPlanes = [];
        this.animations = {};
        this.skeletons = {};
        this.visibleNodes = [];
        this.visibleRenderables = [];
        this.visibleLights = [];
        this.cameraAreaIndex = -1;
        this.cameraExtents = [];
        this.visiblePortals = [];
        this.frameIndex = 0;
        this.queryCounter = 0;
        this.staticNodesChangeCounter = 0;
    },

    //
    // endLoading
    //
    endLoading: function sceneEndLoadingFn(onload)
    {
        this.initializeNodes();
        this.initializeAreas();
        if (onload)
        {
            onload(this);
        }
    },

    //
    // initializeNodes
    //
    initializeNodes: function sceneInitializeNodesFn()
    {
        this.updateNodes();
        this.staticSpatialMap.finalize();
        this.updateExtents();
    },

    //
    // addAreaStaticNodes
    //
    addAreaStaticNodes: function addAreaStaticNodesFn()
    {
        var findAreaIndicesAABB = this.findAreaIndicesAABB;
        var findAreaIndex = this.findAreaIndex;
        var scene = this;

        function addAreasNodeFn(bspNodes, areas)
        {
            if (this.dynamic)
            {
                return;
            }

            if (this.hasRenderables() || (this.hasLightInstances() && this.worldExtents))
            {
                var extents = this.worldExtents;
                var min0 = extents[0];
                var min1 = extents[1];
                var min2 = extents[2];
                var max0 = extents[3];
                var max1 = extents[4];
                var max2 = extents[5];
                var area, areaExtents, na;
                var cX = (min0 + max0) * 0.5;
                var cY = (min1 + max1) * 0.5;
                var cZ = (min2 + max2) * 0.5;
                var areaIndex = findAreaIndex(bspNodes, cX, cY, cZ);
                if (areaIndex >= 0)
                {
                    area = areas[areaIndex];
                    area.nodes.push(this);

                    var overlappingAreas = scene.findOverlappingAreas(areaIndex, extents);
                    var numOverlappingAreas = overlappingAreas.length;
                    for (na = 0; na < numOverlappingAreas; na += 1)
                    {
                        overlappingAreas[na].nodes.push(this);
                    }
                }
                else
                {
                    var areaFound = false;
                    for (;;)
                    {
                        var areaIndices = findAreaIndicesAABB(bspNodes, min0, min1, min2, max0, max1, max2);
                        var numAreaIndices = areaIndices.length;
                        if (0 < numAreaIndices)
                        {
                            // 1st try: only attach to overlapping areas
                            na = 0;
                            do
                            {
                                area = areas[areaIndices[na]];
                                areaExtents = area.extents;
                                if (areaExtents[0] <= max0 &&
                                    areaExtents[1] <= max1 &&
                                    areaExtents[2] <= max2 &&
                                    areaExtents[3] >= min0 &&
                                    areaExtents[4] >= min1 &&
                                    areaExtents[5] >= min2)
                                {
                                    area.nodes.push(this);
                                    areaFound = true;
                                }
                                na += 1;
                            }
                            while (na < numAreaIndices);
                            if (!areaFound)
                            {
                                // 2nd try: attach to any areas from bsp query
                                na = 0;
                                do
                                {
                                    areas[areaIndices[na]].nodes.push(this);
                                    na += 1;
                                }
                                while (na < numAreaIndices);
                            }
                            break;
                        }
                        else
                        {
                            // 3nd try: increase bounding box
                            var delta = Math.max((max0 - min0), (max1 - min1), (max2 - min2)) / 20;
                            min0 -= delta;
                            min1 -= delta;
                            min2 -= delta;
                            max0 += delta;
                            max1 += delta;
                            max2 += delta;
                        }
                    }
                }
            }
            var children = this.children;
            if (children)
            {
                var numChildren = children.length;
                for (var nc = 0; nc < numChildren; nc += 1)
                {
                    addAreasNodeFn.call(children[nc], bspNodes, areas);
                }
            }
        }

        var rootNodes = this.rootNodes;
        var numRootNodes = rootNodes.length;
        var bspNodes = this.bspNodes;
        var areas = this.areas;
        for (var n = 0; n < numRootNodes; n += 1)
        {
            addAreasNodeFn.call(rootNodes[n], bspNodes, areas);
        }
    },

    //
    // findOverlappingAreas
    //
    findOverlappingAreas: function sceneFindOverlappingAreasFn(startAreaIndex, extents)
    {
        var area, portals, numPortals, n, portal, plane, d0, d1, d2, portalExtents, areaIndex, nextArea;
        var queryCounter = this.getQueryCounter();
        var areas = this.areas;
        var portalsStack = [];
        var numPortalsStack = 0;
        var overlappingAreas = [];
        var numOverlappingAreas = 0;

        var min0 = extents[0];
        var min1 = extents[1];
        var min2 = extents[2];
        var max0 = extents[3];
        var max1 = extents[4];
        var max2 = extents[5];

        area = areas[startAreaIndex];
        area.queryCounter = queryCounter;

        portals = area.portals;
        numPortals = portals.length;
        for (n = 0; n < numPortals; n += 1)
        {
            portal = portals[n];
            portal.queryCounter = queryCounter;

            portalExtents = portal.extents;
            if (portalExtents[0] < max0 &&
                portalExtents[1] < max1 &&
                portalExtents[2] < max2 &&
                portalExtents[3] > min0 &&
                portalExtents[4] > min1 &&
                portalExtents[5] > min2)
            {
                plane = portal.plane;
                d0 = plane[0];
                d1 = plane[1];
                d2 = plane[2];
                if ((d0 * (d0 < 0 ? min0 : max0) + d1 * (d1 < 0 ? min1 : max1) + d2 * (d2 < 0 ? min2 : max2)) >= plane[3])
                {
                    portalsStack[numPortalsStack] = portal;
                    numPortalsStack += 1;
                }
            }
        }

        while (0 < numPortalsStack)
        {
            numPortalsStack -= 1;
            portal = portalsStack[numPortalsStack];

            areaIndex = portal.area;
            area = areas[areaIndex];
            if (area.queryCounter !== queryCounter)
            {
                area.queryCounter = queryCounter;
                overlappingAreas[numOverlappingAreas] = area;
                numOverlappingAreas += 1;
            }

            portals = area.portals;
            numPortals = portals.length;
            for (n = 0; n < numPortals; n += 1)
            {
                portal = portals[n];
                nextArea = portal.area;
                if (nextArea !== areaIndex &&
                    nextArea !== startAreaIndex &&
                    portal.queryCounter !== queryCounter)
                {
                    portal.queryCounter = queryCounter;

                    portalExtents = portal.extents;
                    if (portalExtents[0] < max0 &&
                        portalExtents[1] < max1 &&
                        portalExtents[2] < max2 &&
                        portalExtents[3] > min0 &&
                        portalExtents[4] > min1 &&
                        portalExtents[5] > min2)
                    {
                        plane = portal.plane;
                        d0 = plane[0];
                        d1 = plane[1];
                        d2 = plane[2];
                        if ((d0 * (d0 < 0 ? min0 : max0) + d1 * (d1 < 0 ? min1 : max1) + d2 * (d2 < 0 ? min2 : max2)) >= plane[3])
                        {
                            portalsStack[numPortalsStack] = portal;
                            numPortalsStack += 1;
                        }
                    }
                }
            }
        }

        return overlappingAreas;
    },

    //
    // checkAreaDynamicNodes
    //
    checkAreaDynamicNodes: function checkAreaDynamicNodesFn()
    {
        var findAreaIndicesAABB = this.findAreaIndicesAABB;
        var dynamicSpatialMap = this.dynamicSpatialMap;
        var bspNodes = this.bspNodes;
        var areas = this.areas;

        function checkAreaNodeFn()
        {
            if (this.dynamic &&
                (this.hasRenderables() || (this.hasLightInstances() && this.worldExtents)))
            {
                var extents = this.worldExtents;
                var min0 = extents[0];
                var min1 = extents[1];
                var min2 = extents[2];
                var max0 = extents[3];
                var max1 = extents[4];
                var max2 = extents[5];
                var pad = false;
                var areaFound = false;
                var na;
                for (;;)
                {
                    var areaIndices = findAreaIndicesAABB(bspNodes, min0, min1, min2, max0, max1, max2);
                    var numAreaIndices = areaIndices.length;
                    if (0 < numAreaIndices)
                    {
                        na = 0;
                        do
                        {
                            var area = areas[areaIndices[na]];
                            var areaExtent = area.extents;
                            if (areaExtent[0] <= max0 &&
                                areaExtent[1] <= max1 &&
                                areaExtent[2] <= max2 &&
                                areaExtent[3] >= min0 &&
                                areaExtent[4] >= min1 &&
                                areaExtent[5] >= min2)
                            {
                                areaFound = true;
                                break;
                            }
                            na += 1;
                        }
                        while (na < numAreaIndices);
                    }
                    if (areaFound)
                    {
                        break;
                    }
                    var delta = Math.max((max0 - min0), (max1 - min1), (max2 - min2)) / 20;
                    min0 -= delta;
                    min1 -= delta;
                    min2 -= delta;
                    max0 += delta;
                    max1 += delta;
                    max2 += delta;
                    pad = true;
                }
                if (pad)
                {   //TODO: This alters extents but the developer would expect them to remain constant if they are responsible for them.
                    extents[0] = min0;
                    extents[1] = min1;
                    extents[2] = min2;
                    extents[3] = max0;
                    extents[4] = max1;
                    extents[5] = max2;
                    dynamicSpatialMap.update(this, extents);
                }
            }
            var children = this.children;
            if (children)
            {
                var numChildren = children.length;
                for (var nc = 0; nc < numChildren; nc += 1)
                {
                    checkAreaNodeFn.call(children[nc]);
                }
            }
        }

        var rootNodes = this.rootNodes;
        var numRootNodes = rootNodes.length;
        for (var n = 0; n < numRootNodes; n += 1)
        {
            checkAreaNodeFn.call(rootNodes[n]);
        }
    },

    //
    // initializeAreas
    //
    initializeAreas: function sceneInitializeAreasFn()
    {
        var areas = this.areas;
        if (areas)
        {
            var numAreas = areas.length;
            var n, area, target, extents, areaExtents;
            for (n = 0; n < numAreas; n += 1)
            {
                area = areas[n];
                target = area.target;
                area.nodes = [];
                extents = target.calculateHierarchyWorldExtents();
                if (extents)
                {
                    areaExtents = area.extents;
                    area.extents = [
                            (extents[0] < areaExtents[0] ? extents[0] : areaExtents[0]),
                            (extents[1] < areaExtents[1] ? extents[1] : areaExtents[1]),
                            (extents[2] < areaExtents[2] ? extents[2] : areaExtents[2]),
                            (extents[3] > areaExtents[3] ? extents[3] : areaExtents[3]),
                            (extents[4] > areaExtents[4] ? extents[4] : areaExtents[4]),
                            (extents[5] > areaExtents[5] ? extents[5] : areaExtents[5])
                        ];
                }
            }

            this.addAreaStaticNodes();

            this.checkAreaDynamicNodes();

            for (n = 0; n < numAreas; n += 1)
            {
                area = areas[n];
                area.numStaticNodes = area.nodes.length;
            }
        }
        this.areaInitalizeStaticNodesChangeCounter = this.staticNodesChangeCounter;
    },

    //
    // createMaterial
    //
    createMaterial: function createMaterialFn(materialName, fileMaterial, effectName, fileEffects, fileImages, graphicsDevice)
    {
        var materials = this.materials;

        var material = Material.create(graphicsDevice);
        var param, filename, effectType, p;

        // Effect associated, load from file
        if (fileEffects)
        {
            var fileEffect = fileEffects[effectName];
            if (fileEffect)
            {
                var effectParameters = fileEffect.parameters;
                for (p in effectParameters)
                {
                    if (effectParameters.hasOwnProperty(p))
                    {
                        param = effectParameters[p];
                        if (typeof param === 'string')
                        {
                            if (fileImages)
                            {
                                filename = fileImages[param] || param;
                            }
                            else
                            {
                                filename = param;
                            }

                            if (!material.texturesNames)
                            {
                                material.texturesNames = {};
                            }
                            material.texturesNames[p] = filename;
                            material.techniqueParameters[p] = null;
                        }
                        else
                        {
                            material.techniqueParameters[p] = param;
                        }
                    }
                }
                effectType = fileEffect.type;
            }
            else
            {
                effectType = effectName;
            }
        }
        else
        {
            effectType = effectName;
        }

        var materialParameters = fileMaterial.parameters;
        for (p in materialParameters)
        {
            if (materialParameters.hasOwnProperty(p))
            {
                param = materialParameters[p];
                if (typeof param === 'string')
                {
                    if (fileImages)
                    {
                        filename = fileImages[param] || param;
                    }
                    else
                    {
                        filename = param;
                    }

                    if (!material.texturesNames)
                    {
                        material.texturesNames = {};
                    }
                    material.texturesNames[p] = filename;

                    material.techniqueParameters[p] = null;
                }
                else
                {
                    material.techniqueParameters[p] = param;
                }
            }
        }

        material.effectName = effectType;

        if (fileMaterial.meta)
        {
            material.meta = fileMaterial.meta;
        }

        materials[materialName] = material;
        material.name = materialName;
        material.reference.subscribeDestroyed(this.onMaterialDestroyed);

        return material;
    },

    //
    // loadMaterials
    //
    loadMaterials: function sceneLoadMaterialsFn(loadParams)
    {
        var sceneData = loadParams.data;
        var gd = loadParams.graphicsDevice;
        var textureManager = loadParams.textureManager;
        var createMaterial = this.createMaterial;

        if (!loadParams.append)
        {
            this.effects = [];
            this.effectsMap = {};
            this.clearMaterials();
        }

        // Import materials
        var fileMaterials = sceneData.materials;
        if (fileMaterials)
        {
            var fileImages = sceneData.images;
            var fileEffects = sceneData.effects;
            var materials = this.materials;
            for (var m in fileMaterials)
            {
                if (fileMaterials.hasOwnProperty(m) &&
                    !materials[m])
                {
                    var fileMaterial = fileMaterials[m];
                    var effectName = (fileMaterial.effect || "default");
                    createMaterial.call(this, m, fileMaterial, effectName, fileEffects, fileImages, gd, textureManager);
                }
            }
        }
    },

    //
    // loadSkeletons
    //
    loadSkeletons: function sceneLoadSkeletonsFn(loadParams)
    {
        var sceneData = loadParams.data;
        var fileSkeletons = sceneData.skeletons;

        var md = this.md;
        var m43Build = md.m43Build;

        var invLTM, bindPose;

        for (var s in fileSkeletons)
        {
            if (fileSkeletons.hasOwnProperty(s))
            {
                var skeleton = fileSkeletons[s];

                var numJoints = skeleton.numNodes;
                var invLTMs = skeleton.invBoneLTMs;
                var bindPoses = skeleton.bindPoses;

                // copy the inv bone ltms and bind poses to make them native
                for (var b = 0; b < numJoints; b += 1)
                {
                    invLTM = invLTMs[b];
                    bindPose = bindPoses[b];

                    invLTMs[b] = m43Build.apply(md, invLTM);
                    bindPoses[b] = m43Build.apply(md, bindPose);
                }
                this.skeletons[s] = skeleton;
            }
        }
    },

    //
    // loadShape
    //
    loadShape: function sceneLoadShapeFn(shapeName, fileShapeName, loadParams)
    {
        var shape = this.shapes[shapeName];

        if (!shape)
        {
            var cachedSemantics = this.semantics;

            var sceneData = loadParams.data;
            var gd = loadParams.graphicsDevice;
            var keepVertexData = loadParams.keepVertexData;
            var fileShapes = sceneData.geometries;
            var fileShape = fileShapes[fileShapeName];
            var sources = fileShape.sources;
            var inputs = fileShape.inputs;
            var skeletonName = fileShape.skeleton;

            shape = Geometry.create();

            if (skeletonName)
            {
                var skeleton = this.skeletons[skeletonName];
                if (skeleton)
                {
                    shape.skeleton = skeleton;
                    shape.type = "skinned";
                }
                else
                {
                    // Failed to load skeleton so just draw bind pose
                    shape.type = "rigid";
                }
            }
            else
            {
                shape.type = "rigid";
            }

            if (gd)
            {
                // First calculate data about the vertex streams
                var offset, stride;
                var destStride;
                var destFormat;
                var maxOffset = 0;
                var vertexSources = [];

                var isUByte4Range = function isUByte4RangeFn(minVal, maxVal)
                {
                    return (minVal >= 0) && (maxVal <= 255) && (maxVal > 1);
                };

                var areInRange = function areInRangeFn(minVals, maxVals, isRangeFn)
                {
                    var numVals = minVals.length;
                    if (maxVals.length !== numVals)
                    {
                        return false;
                    }
                    for (var valIdx = 0 ; valIdx < numVals ; valIdx += 1)
                    {
                        if (!isRangeFn(minVals[valIdx], maxVals[valIdx]))
                        {
                            return false;
                        }
                    }
                    return true;
                };

                var formatMap = loadParams.vertexFormatMap || {};

                for (var input in inputs)
                {
                    if (inputs.hasOwnProperty(input))
                    {
                        var fileInput = inputs[input];
                        offset = fileInput.offset;
                        if (offset > maxOffset)
                        {
                            maxOffset = offset;
                        }
                        var fileSource = sources[fileInput.source];
                        var fileSourceStride = fileSource.stride;

                        // If the caller gave a preferred format, try
                        // to use it.

                        destFormat = formatMap[input];
                        destStride = fileSourceStride;

                        // If we got a caller preference, check for a
                        // new stride

                        if (destFormat)
                        {
                            if (destFormat.indexOf("4"))
                            {
                                destStride = 4;
                            }
                            else if (destFormat.indexOf("3")) {
                                destStride = 3;
                            }
                            else if (destFormat.indexOf("2"))
                            {
                                destStride = 2;
                            }
                            else if (destFormat.indexOf("1"))
                            {
                                destStride = 1;
                            }
                            else
                            { /* ERROR */
                                destFormat = null;
                            }
                        }

                        // No preferred format, make our own choice

                        if (!destFormat)
                        {
                            // Check for appropriate formats.  Make
                            // assumptions based on semantic names.

                            if (input === "BLENDINDICES" || input === "BLENDINDICES0")
                            {
                                if (fileSourceStride === 4 &&
                                    areInRange(fileSource.min, fileSource.max, isUByte4Range))
                                {
                                    destFormat = "UBYTE4";
                                }
                            }

                            // if (input == "NORMAL" || input == "NORMAL0")
                            // {
                            //     if (fileSourceStride == 3)
                            //     {
                            //         Check range is within [-1,1]

                            //         destFormat = "BYTE";
                            //         destFormatNormalized = true;
                            //         destStride = 4;
                            //     }
                            // }
                        }

                        // If we still don't have a format, revert to FLOATn

                        if (!destFormat)
                        {
                            destFormat = "FLOAT" + fileSourceStride;
                        }

                        vertexSources.push({
                            semantic: input,
                            offset: offset,
                            data: fileSource.data,
                            stride: fileSourceStride,
                            destFormat: destFormat,
                            destStride: destStride
                        });
                    }
                }
                var indicesPerVertex = (maxOffset + 1);

                if (0 < maxOffset)
                {
                    var vertexSourcesCompare = function (vertexSourceA, vertexSourceB)
                    {
                        if (vertexSourceA.offset === vertexSourceB.offset)
                        {
                            var semanticA = vertexSourceA.semantic;
                            if (typeof semanticA === 'string')
                            {
                                semanticA = gd['SEMANTIC_' + semanticA];
                            }
                            var semanticB = vertexSourceB.semantic;
                            if (typeof semanticB === 'string')
                            {
                                semanticB = gd['SEMANTIC_' + semanticB];
                            }
                            return (semanticA - semanticB);
                        }
                        else
                        {
                            return (vertexSourceA.offset - vertexSourceB.offset);
                        }
                    };
                    vertexSources.sort(vertexSourcesCompare);
                }

                var numVertexSources = vertexSources.length;
                var semanticsNames = [];
                var attributes = [];
                var useFloatArray = (this.float32ArrayConstructor ? true : false);
                var numValuesPerVertex = 0;
                var vs, vertexSource;
                for (vs = 0; vs < numVertexSources; vs += 1)
                {
                    vertexSource = vertexSources[vs];
                    semanticsNames[vs] = vertexSource.semantic;
                    destFormat = vertexSource.destFormat;
                    if (useFloatArray)
                    {
                        if (typeof destFormat === "string")
                        {
                            if (destFormat[0] !== "F")
                            {
                                useFloatArray = false;
                            }
                        }
                        else
                        {
                            if (destFormat !== gd.VERTEXFORMAT_FLOAT1 &&
                                destFormat !== gd.VERTEXFORMAT_FLOAT2 &&
                                destFormat !== gd.VERTEXFORMAT_FLOAT3 &&
                                destFormat !== gd.VERTEXFORMAT_FLOAT4)
                            {
                                useFloatArray = false;
                            }
                        }
                    }
                    attributes[vs] = destFormat;
                    numValuesPerVertex += vertexSource.stride;
                }

                // Now parse the surfaces to work out primitive types and the total vertex count
                var numVertices, totalNumVertices = 0;
                var noSurfaces = false;
                var surfaces = fileShape.surfaces;
                if (!surfaces)
                {
                    noSurfaces = true;
                    surfaces = {
                        singleSurface: {
                            triangles: fileShape.triangles,
                            lines: fileShape.lines,
                            numPrimitives: fileShape.numPrimitives
                        }
                    };
                }

                var surface;
                var destSurface;
                var faces;
                var s;

                for (s in surfaces)
                {
                    if (surfaces.hasOwnProperty(s))
                    {
                        surface = surfaces[s];
                        destSurface = {};
                        shape.surfaces[s] = destSurface;

                        faces = surface.triangles;
                        var primitive, vertexPerPrimitive;
                        if (faces)
                        {
                            primitive = gd.PRIMITIVE_TRIANGLES;
                            vertexPerPrimitive = 3;
                        }
                        else
                        {
                            faces = surface.lines;
                            if (faces)
                            {
                                primitive = gd.PRIMITIVE_LINES;
                                vertexPerPrimitive = 2;
                            }
                        }
                        destSurface.primitive = primitive;
                        destSurface.faces = faces;

                        if (faces)
                        {
                            if (1 < indicesPerVertex)
                            {
                                numVertices = (surface.numPrimitives * vertexPerPrimitive);
                                destSurface.numVertices = numVertices;
                            }
                            else
                            {

                                numVertices = (vertexSources[0].data.length / vertexSources[0].stride);
                                if (numVertices > faces.length)
                                {
                                    numVertices = faces.length;
                                }
                                destSurface.numVertices = numVertices;
                            }
                        }
                    }
                }

                // For cases where > 1-index per vertex we process it to create 1-index per vertex from data

                var updateSingleIndexTables =
                    function updateSingleIndexTablesFn(surface, indicesPerVertex,
                                                       verticesAsIndexLists,
                                                       verticesAsIndexListTable)
                {
                    var faces = surface.faces;
                    var numVerts = faces.length / indicesPerVertex;

                    var singleIndices = [];
                    singleIndices[numVerts - 1] = 0;

                    var hashIndexList = function hashIndexListFn(indexList)
                    {
                        return indexList.join(",");
                    };

                    var vertIdx = 0;
                    var srcIdx = 0;
                    var nextSrcIdx = indicesPerVertex;

                    while (srcIdx < faces.length)
                    {
                        var thisVert = faces.slice(srcIdx, nextSrcIdx);
                        var thisVertHash = hashIndexList(thisVert);

                        var thisVertIndex = verticesAsIndexListTable[thisVertHash];
                        if (!thisVertIndex)
                        {
                            // New index - add to tables

                            thisVertIndex = verticesAsIndexLists.length;
                            verticesAsIndexLists[thisVertIndex] = thisVert;
                            verticesAsIndexListTable[thisVertHash] = thisVertIndex;
                        }

                        singleIndices[vertIdx] = thisVertIndex;

                        srcIdx = nextSrcIdx;
                        nextSrcIdx += indicesPerVertex;
                        vertIdx += 1;
                    }

                    surface.faces = singleIndices;
                };

                if (indicesPerVertex > 1)
                {
                    // [ [a,b,c], [d,e,f], ... ]
                    var verticesAsIndexLists = [];
                    var verticesAsIndexListTable = {};

                    var shapeSurfaces = shape.surfaces;
                    for (s in shapeSurfaces)
                    {
                        if (shapeSurfaces.hasOwnProperty(s))
                        {
                            var shapeSurface = shapeSurfaces[s];
                            updateSingleIndexTables(shapeSurface,
                                                    indicesPerVertex,
                                                    verticesAsIndexLists,
                                                    verticesAsIndexListTable);
                        }
                    }

                    // recalc totalNumVertices

                    totalNumVertices = verticesAsIndexLists.length;

                    // Recreate vertex buffer data on the vertexSources

                    for (var vertSource in vertexSources)
                    {
                        if (vertexSources.hasOwnProperty(vertSource))
                        {
                            vertexSource = vertexSources[vertSource];
                            var thisSourceOffset = vertexSource.offset;
                            var thisSourceStride = vertexSource.stride;
                            var thisSourceData = vertexSource.data;

                            var newData = new Array(thisSourceStride * totalNumVertices);

                            // For each entry in index list

                            var vertIdx = 0;
                            while (vertIdx < totalNumVertices)
                            {
                                var newVBIdx = thisSourceStride * vertIdx;
                                var oldVBIdx = thisSourceStride * verticesAsIndexLists[vertIdx][thisSourceOffset];

                                // Copy the vertex data out of the vertex buffer

                                for (var attrIdx = 0 ;
                                     attrIdx < thisSourceStride ;
                                     attrIdx += 1)
                                {
                                    newData[newVBIdx + attrIdx] =
                                        thisSourceData[oldVBIdx + attrIdx];
                                }

                                vertIdx += 1;
                            }

                            vertexSource.data = newData;
                            vertexSource.offset = 0;
                        }
                    }

                    indicesPerVertex = 1;
                }

                Utilities.assert(indicesPerVertex === 1);

                totalNumVertices = vertexSources[0].data.length / vertexSources[0].stride;

                var vertexBufferManager = (loadParams.vertexBufferManager || this.vertexBufferManager);
                if (!vertexBufferManager)
                {
                    vertexBufferManager = VertexBufferManager.create(gd);
                    this.vertexBufferManager = vertexBufferManager;
                }

                var indexBufferManager = (loadParams.indexBufferManager || this.indexBufferManager);
                if (!indexBufferManager)
                {
                    indexBufferManager = IndexBufferManager.create(gd);
                    this.indexBufferManager = indexBufferManager;
                }

                var baseIndex;
                var vertexBuffer = null;
                var vertexBufferAllocation = vertexBufferManager.allocate(totalNumVertices, attributes);
                vertexBuffer = vertexBufferAllocation.vertexBuffer;
                if (!vertexBuffer)
                {
                    return undefined;
                }

                shape.vertexBuffer = vertexBuffer;
                shape.vertexBufferManager = vertexBufferManager;
                shape.vertexBufferAllocation = vertexBufferAllocation;

                baseIndex = vertexBufferAllocation.baseIndex;

                var indexBufferAllocation;
                var t, index, nextIndex;
                //
                // We no have the simple case of each index maps to one vertex so create one vertex buffer and fill in.
                //
                var vertexData = (useFloatArray ?
                                  new this.float32ArrayConstructor(totalNumVertices * numValuesPerVertex) :
                                  new Array(totalNumVertices * numValuesPerVertex));
                var vertexDataCount = 0;
                for (t = 0; t < totalNumVertices; t += 1)
                {
                    vs = 0;
                    do
                    {
                        vertexSource = vertexSources[vs];
                        var sourceData = vertexSource.data;
                        stride = vertexSource.stride;
                        index = t * stride;
                        nextIndex = (index + stride);
                        destStride = vertexSource.destStride;
                        do
                        {
                            vertexData[vertexDataCount] = sourceData[index];
                            vertexDataCount += 1;
                            index += 1;
                        }
                        while (index < nextIndex);

                        while (stride < destStride)
                        {
                            vertexData[vertexDataCount] = 0;
                            vertexDataCount += 1;
                            destStride -= 1;
                        }

                        vs += 1;
                    }
                    while (vs < numVertexSources);
                }
                vertexBuffer.setData(vertexData, baseIndex, totalNumVertices);

                // Count total num indices
                var isSequentialIndices = function isSequentialIndicesFn(indices, numIndices)
                {
                    var baseIndex = indices[0];
                    var n;
                    for (n = 1; n < numIndices; n += 1)
                    {
                        if (indices[n] !== (baseIndex + n))
                        {
                            return false;
                        }
                    }
                    return true;
                };

                var totalNumIndices = 0;
                var numIndices;

                for (s in surfaces)
                {
                    if (surfaces.hasOwnProperty(s))
                    {
                        destSurface = shape.surfaces[s];
                        faces = destSurface.faces;
                        if (faces)
                        {
                            numIndices = faces.length;
                            if (!isSequentialIndices(faces, numIndices))
                            {
                                totalNumIndices += numIndices;
                            }
                        }
                    }
                }

                var indexBuffer, indexBufferData, indexBufferBaseIndex, indexBufferOffset, maxIndex;
                if (0 < totalNumIndices)
                {
                    maxIndex = (baseIndex + totalNumVertices - 1);

                    indexBufferAllocation = indexBufferManager.allocate(totalNumIndices,
                                                                        (maxIndex < 65536 ? 'USHORT' : 'UINT'));
                    indexBuffer = indexBufferAllocation.indexBuffer;
                    if (!indexBuffer)
                    {
                        return undefined;
                    }

                    shape.indexBufferManager = indexBufferManager;
                    shape.indexBufferAllocation = indexBufferAllocation;

                    if (maxIndex < 65536 &&
                        this.uint16ArrayConstructor)
                    {
                        indexBufferData = new this.uint16ArrayConstructor(totalNumIndices);
                    }
                    else if (this.uint32ArrayConstructor)
                    {
                        indexBufferData = new this.uint32ArrayConstructor(totalNumIndices);
                    }
                    else
                    {
                        indexBufferData = new Array(totalNumIndices);
                    }

                    indexBufferBaseIndex = indexBufferAllocation.baseIndex;
                    indexBufferOffset = 0;
                }

                // Fill index buffers
                for (s in surfaces)
                {
                    if (surfaces.hasOwnProperty(s))
                    {
                        destSurface = shape.surfaces[s];

                        faces = destSurface.faces;
                        delete destSurface.faces;

                        if (faces)
                        {
                            // Vertices already de-indexed (1 index per vert)
                            numIndices = faces.length;

                            //See if they are all sequential, in which case we don't need an index buffer
                            if (!isSequentialIndices(faces, numIndices))
                            {
                                destSurface.indexBuffer = indexBuffer;
                                destSurface.numIndices = numIndices;
                                destSurface.first = (indexBufferBaseIndex + indexBufferOffset);

                                if (baseIndex)
                                {
                                    for (t = 0; t < numIndices; t += 1)
                                    {
                                        indexBufferData[indexBufferOffset] = (baseIndex + faces[t]);
                                        indexBufferOffset += 1;
                                    }
                                }
                                else
                                {
                                    for (t = 0; t < numIndices; t += 1)
                                    {
                                        indexBufferData[indexBufferOffset] = faces[t];
                                        indexBufferOffset += 1;
                                    }
                                }

                                if (keepVertexData)
                                {
                                    if (maxIndex < 65536 &&
                                        this.uint16ArrayConstructor)
                                    {
                                        destSurface.indexData = new this.uint16ArrayConstructor(faces);
                                    }
                                    else if (this.uint32ArrayConstructor)
                                    {
                                        destSurface.indexData = new this.uint32ArrayConstructor(faces);
                                    }
                                    else
                                    {
                                        destSurface.indexData = faces;
                                    }
                                }
                            }
                            else
                            {
                                destSurface.first = (baseIndex + faces[0]);
                            }

                            faces = null;

                            if (keepVertexData)
                            {
                                destSurface.vertexData = vertexData;
                            }
                        }
                        else
                        {
                            delete shape.surfaces[s];
                        }
                    }
                }

                if (indexBuffer)
                {
                    indexBuffer.setData(indexBufferData, indexBufferBaseIndex, totalNumIndices);
                    indexBufferData = null;
                }

                //Utilities.log("Buffers creation time: " + (TurbulenzEngine.time - startTime));

                var semanticsHash = semanticsNames.join();
                var semantics = cachedSemantics[semanticsHash];
                if (!semantics)
                {
                    semantics = gd.createSemantics(semanticsNames);
                    cachedSemantics[semanticsHash] = semantics;
                }
                shape.semantics = semantics;

                if (noSurfaces)
                {
                    // TODO: could remove this and always have surfaces
                    surface = shape.surfaces.singleSurface;

                    if (surface)
                    {
                        shape.primitive = surface.primitive;
                        if (keepVertexData)
                        {
                            shape.vertexData = surface.vertexData;
                        }

                        shape.first = surface.first;

                        if (surface.indexBuffer)
                        {
                            shape.indexBuffer = surface.indexBuffer;
                            shape.numIndices = surface.numIndices;
                            if (keepVertexData)
                            {
                                shape.indexData = surface.indexData;
                            }
                        }
                        else
                        {
                            shape.numVertices = surface.numVertices;
                        }
                    }

                    delete shape.surfaces;
                }
            }

            if (inputs.POSITION)
            {
                var positions = sources[inputs.POSITION.source];
                var minPos = positions.min;
                var maxPos = positions.max;
                if (minPos && maxPos)
                {
                    var min0 = minPos[0];
                    var min1 = minPos[1];
                    var min2 = minPos[2];
                    var max0 = maxPos[0];
                    var max1 = maxPos[1];
                    var max2 = maxPos[2];
                    if (min0 !== -max0 || min1 !== -max1 || min2 !== -max2)
                    {
                        var c0 = (min0 + max0) * 0.5;
                        var c1 = (min1 + max1) * 0.5;
                        var c2 = (min2 + max2) * 0.5;
                        shape.center      = [c0, c1, c2];
                        shape.halfExtents = [(max0 - c0), (max1 - c1), (max2 - c2)];
                    }
                    else
                    {
                        shape.halfExtents = [(max0 - min0) * 0.5, (max1 - min1) * 0.5, (max2 - min2) * 0.5];
                    }
                }
                //else
                //{
                    //TODO: add warning that we have no extents information
                //}
            }

            this.shapes[shapeName] = shape;
            shape.name = shapeName;
            shape.reference.subscribeDestroyed(this.onGeometryDestroyed);
        }
        return shape;
    },

    streamShapes: function sceneStreamShapesFn(loadParams, postLoadFn)
    {
        // Firstly build an array listing all the shapes we need to load
        var yieldFn = loadParams.yieldFn;
        var scene = this;
        var shapesNamePrefix = loadParams.shapesNamePrefix;
        var sceneData = loadParams.data;
        var fileShapes = sceneData.geometries;
        var loadCustomShapeFn = loadParams.loadCustomShapeFn;

        var shapesToLoad = [];
        var customShapesToLoad = [];

        for (var fileShapeName in fileShapes)
        {
            if (fileShapes.hasOwnProperty(fileShapeName))
            {
                var fileShape = fileShapes[fileShapeName];
                if (fileShape.meta && fileShape.meta.graphics)
                {
                    if (fileShape.meta.custom)
                    {
                        customShapesToLoad.push(fileShapeName);
                    }
                    else
                    {
                        shapesToLoad.push(fileShapeName);
                    }
                }
            }
        }

        function sceneLoadNextShapeFn()
        {
            var nextShape = shapesToLoad.pop();

            var shapeName = (shapesNamePrefix ? (shapesNamePrefix + "-" + nextShape) : nextShape);
            scene.loadShape(shapeName, nextShape, loadParams);

            if (shapesToLoad.length)
            {
                yieldFn(sceneLoadNextShapeFn);
            }
            else
            {
                yieldFn(postLoadFn);
            }
        }

        function sceneLoadNextCustomShapeFn()
        {
            var nextShape = customShapesToLoad.pop();

            var shapeName = (shapesNamePrefix ? (shapesNamePrefix + "-" + nextShape) : nextShape);
            loadCustomShapeFn.call(scene, shapeName, nextShape, loadParams);

            if (customShapesToLoad.length)
            {
                yieldFn(sceneLoadNextCustomShapeFn);
            }
            else if (shapesToLoad.length)
            {
                yieldFn(sceneLoadNextShapeFn);
            }
            else
            {
                yieldFn(postLoadFn);
            }
        }

        if (customShapesToLoad.length)
        {
            yieldFn(sceneLoadNextCustomShapeFn);
        }
        else if (shapesToLoad.length)
        {
            yieldFn(sceneLoadNextShapeFn);
        }
        else
        {
            yieldFn(postLoadFn);
        }
    },

    //
    // Load lights
    //
    loadLights: function sceneLoadLightsFn(loadParams)
    {
        var sceneData = loadParams.data;
        var textureManager = loadParams.textureManager;

        if (!loadParams.append)
        {
            this.lights = {};
            this.globalLights = [];
        }

        var fileLights = sceneData.lights;
        var lights = this.lights;
        var globalLights = this.globalLights;
        var materials = this.materials;
        var beget = Utilities.beget;

        var md = loadParams.mathDevice;
        var v3Build = md.v3Build;

        for (var l in fileLights)
        {
            if (fileLights.hasOwnProperty(l) &&
                !lights[l])
            {
                var fileLight = fileLights[l];

                // convert to create parameters
                var lightParams = beget(fileLight);

                var type = fileLight.type;
                if (type === 'directional')
                {
                    lightParams.directional = true;
                }
                else if (type === 'spot')
                {
                    lightParams.spot = true;
                }
                else if (type === 'ambient')
                {
                    lightParams.ambient = true;
                }
                else //if (type === 'point')
                {
                    lightParams.point = true;
                }

                // Convert to MathDevice objects
                lightParams.color = fileLight.color && v3Build.apply(md, fileLight.color);

                /*jslint white: false*/
                lightParams.origin = fileLight.origin && v3Build.apply(md, fileLight.origin);
                lightParams.center = fileLight.center && v3Build.apply(md, fileLight.center);
                lightParams.target = fileLight.target && v3Build.apply(md, fileLight.target);
                lightParams.right =  fileLight.right  && v3Build.apply(md, fileLight.right);
                lightParams.up =     fileLight.up     && v3Build.apply(md, fileLight.up);
                lightParams.start =  fileLight.start  && v3Build.apply(md, fileLight.start);
                lightParams.end =    fileLight.end    && v3Build.apply(md, fileLight.end);
                lightParams.direction = fileLight.direction && v3Build.apply(md, fileLight.direction);
                /*jslint white: true*/

                lightParams.halfExtents = fileLight.halfextents && v3Build.apply(md, fileLight.halfextents);

                var materialName = fileLight.material;
                if (materialName)
                {
                    var material = materials[materialName];
                    if (material)
                    {
                        lightParams.material = material;

                        if (material.effectName)
                        {
                            delete material.effectName;
                            material.loadTextures(textureManager);
                        }
                    }
                }

                var light = Light.create(lightParams);
                lights[l] = light;
                if (light.isGlobal())
                {
                    globalLights.push(light);
                }
            }
        }
    },

    //
    // loadNodes
    //
    loadNodes: function sceneLoadNodesFn(loadParams)
    {
        var sceneData = loadParams.data;
        var gd = loadParams.graphicsDevice;
        var textureManager = loadParams.textureManager;
        var effectManager = loadParams.effectManager;
        var baseScene = loadParams.baseScene;
        var keepCameras = loadParams.keepCameras;
        var keepLights = loadParams.keepLights;
        var disableNodes = loadParams.disabled;

        if (!loadParams.append)
        {
            this.clearRootNodes();
            this.staticSpatialMap = AABBTree.create(true);
            this.dynamicSpatialMap = AABBTree.create();
        }

        var loadCustomGeometryInstanceFn = loadParams.loadCustomGeometryInstanceFn;

        var md = this.md;
        var m43Build = md.m43Build;
        var materials = this.materials;
        var lights = this.lights;
        var currentScene = this;

        var baseMaterials;
        if (baseScene)
        {
            baseMaterials = baseScene.materials;
        }
        var baseMatrix = loadParams.baseMatrix;
        var nodesNamePrefix = loadParams.nodesNamePrefix;
        var shapesNamePrefix = loadParams.shapesNamePrefix;

        function copyNodeFn(nodeName, parentNodePath, baseNode, materialSkin)
        {
            var nodePath = parentNodePath ? (parentNodePath + "/" + nodeName) : nodeName;

            var node = SceneNode.create({name: nodeName,
                                         local: this.matrix && m43Build.apply(md, this.matrix),
                                         dynamic: this.dynamic || baseNode.dynamic || loadParams.dynamic});

            var effect;

            var customgeometryinstance = this.customgeometryinstances;
            if (customgeometryinstance && loadCustomGeometryInstanceFn)
            {
                for (var ci in customgeometryinstance)
                {
                    if (customgeometryinstance.hasOwnProperty(ci))
                    {
                        var fileCustomGeometryInstance = customgeometryinstance[ci];
                        var customGeometryInstance = loadCustomGeometryInstanceFn.call(currentScene, fileCustomGeometryInstance, loadParams);

                        if (customGeometryInstance)
                        {
                            node.addRenderable(customGeometryInstance);
                        }
                    }
                }
            }

            var geometryinstances = this.geometryinstances;
            if (geometryinstances)
            {
                for (var gi in geometryinstances)
                {
                    if (geometryinstances.hasOwnProperty(gi))
                    {
                        var fileGeometryInstance = geometryinstances[gi];
                        var fileShapeName = fileGeometryInstance.geometry;
                        var shapeName = (shapesNamePrefix ? (shapesNamePrefix + "-" + fileShapeName) : fileShapeName);
                        var nodeShape = currentScene.loadShape(shapeName, fileShapeName, loadParams);

                        if (gd)
                        {
                            var sharedMaterialName = fileGeometryInstance.material;
                            if (materialSkin && sceneData.skins)
                            {
                                var skin = sceneData.skins[materialSkin];
                                if (skin)
                                {
                                    var newMaterialName = skin[sharedMaterialName];
                                    if (newMaterialName)
                                    {
                                        sharedMaterialName = newMaterialName;
                                    }
                                }
                            }
                            var sharedMaterial = materials[sharedMaterialName];
                            if (!sharedMaterial)
                            {
                                if (baseScene)
                                {
                                    sharedMaterial = baseMaterials[sharedMaterialName];
                                }

                                if (!sharedMaterial)
                                {
                                    //Utilities.log("Unknown material '" + sharedMaterialName + "'");
                                    return undefined;
                                }
                                materials[sharedMaterialName] = sharedMaterial;
                                sharedMaterial.name = sharedMaterialName;
                                sharedMaterial.reference.subscribeDestroyed(currentScene.onMaterialDestroyed);
                            }
                            effect = sharedMaterial.effect;
                            if (!effect)
                            {
                                // Load the textures since if the effect is undefined then scene.loadMaterial
                                // has not yet been called for this material
                                sharedMaterial.loadTextures(textureManager);
                                var effectName = sharedMaterial.effectName;
                                delete sharedMaterial.effectName;
                                effect = effectManager.get(effectName);
                                if (effect)
                                {
                                    effect.prepareMaterial(sharedMaterial);
                                }
                            }

                            var surfaces = nodeShape.surfaces;
                            var surface = (surfaces ? surfaces[fileGeometryInstance.surface] : nodeShape);

                            var geometryInstance = GeometryInstance.create(nodeShape,
                                                                           surface,
                                                                           sharedMaterial);
                            node.addRenderable(geometryInstance);

                            if (fileGeometryInstance.disabled)
                            {
                                geometryInstance.disabled = true;
                            }

                        }
                        else
                        {
                            node.addRenderable(GeometryInstance.create(nodeShape));
                        }
                    }
                }
            }

            // Check for a camera on the node
            if (this.camera)
            {
                if (keepCameras)
                {
                    node.camera = this.camera;
                }
            }

            // Check for any instances of lights attached to the node
            var fileLightInstances = this.lightinstances;
            if (fileLightInstances && keepLights)
            {
                for (var li in fileLightInstances)
                {
                    if (fileLightInstances.hasOwnProperty(li))
                    {
                        var fileLightInstance = fileLightInstances[li];
                        var light = lights[fileLightInstance.light];
                        if (light && !light.global)
                        {
                            var lightInstance = LightInstance.create(light);
                            node.addLightInstance(lightInstance);
                            if (fileLightInstance.disabled)
                            {
                                lightInstance.disabled = true;
                            }
                        }
                    }
                }
            }

            if (this.reference)
            {
                alert("Found unresolved node reference during scene loading");
            }

            if (this.kinematic || baseNode.kinematic)
            {
                node.kinematic = true;
            }

            if ((this.disabled || baseNode.disabled) && (disableNodes !== false))
            {
                node.disabled = true;
            }

            var fileChildren = this.nodes;

            if (fileChildren)
            {
                for (var c in fileChildren)
                {
                    if (fileChildren.hasOwnProperty(c))
                    {
                        if (!node.findChild(c))
                        {
                            var child = copyNodeFn.call(fileChildren[c], c, nodePath, node, this.skin || materialSkin);
                            if (child)
                            {
                                node.addChild(child);
                            }
                        }
                    }
                }
            }

            return node;
        }

        var fileNodes = sceneData.nodes;
        var parentNode = loadParams.parentNode;

        var emptyNode = {};
        for (var fn in fileNodes)
        {
            if (fileNodes.hasOwnProperty(fn))
            {
                var fileNode = fileNodes[fn];
                var nodeName = fn;
                var nodePath = (nodesNamePrefix ? (nodesNamePrefix + "/" + fn) : fn);
                var overloadedNode = currentScene.findNode(nodePath); //If a node with the same name exist already we update that.

                var node = copyNodeFn.call(fileNode,
                                           nodeName,
                                           nodesNamePrefix,
                                           (overloadedNode || parentNode || emptyNode),
                                           fileNode.skin || loadParams.materialSkin);
                if (node)
                {
                    if (parentNode && !overloadedNode)
                    {
                        parentNode.addChild(node);
                    }

                    if (baseMatrix)
                    {
                        if (node.local)
                        {
                            node.setLocalTransform(md.m43Mul(node.getLocalTransform(), baseMatrix));
                        }
                        else
                        {
                            node.setLocalTransform(baseMatrix);
                        }
                    }
                    else
                    {
                        if (!node.local)
                        {
                            node.setLocalTransform(md.m43BuildIdentity());
                        }
                    }

                    if (disableNodes)
                    {
                        node.enableHierarchy(false);
                    }

                    if (overloadedNode)
                    {
                        //Utilities.log("Overloaded node '" + nodePath + "'");

                        var overloadedMatrix = overloadedNode.local;
                        if (overloadedMatrix && node.local)
                        {
                            node.local = md.m43Mul(node.local, overloadedMatrix);
                            overloadedNode.setLocalTransform(node.local);
                            delete node.local;
                        }

                        var overloadedChildren = overloadedNode.children;
                        if (overloadedChildren && node.children)
                        {
                            //Utilities.log("Concat children of node '" + nodePath + "'");
                            while (node.children.length)
                            {
                                var child = node.children[0];
                                if (!overloadedNode.findChild(child.name))
                                {
                                    overloadedNode.addChild(child);
                                }
                                node.removeChild(child);
                            }
                        }

                        for (var on in node)
                        {   //TODO: This really doesn't work other than simple objects....
                            if (node.hasOwnProperty(on))
                            {
                                overloadedNode[on] = node[on];
                            }
                        }
                        node = null;
                    }
                    else if (!parentNode)
                    {
                        this.addRootNode(node);
                    }
                }
            }
        }
    },

    //
    // loadAreas
    //
    loadAreas: function sceneLoadAreasNodesFn(loadParams)
    {
        var sceneData = loadParams.data;

        var fileAreas = sceneData.areas;
        if (!fileAreas)
        {
            return;
        }

        var numFileAreas = fileAreas.length;
        if (numFileAreas <= 0)
        {
            return;
        }

        if (!loadParams.append)
        {
            delete this.areas;
        }

        var areas = this.areas;
        if (!areas)
        {
            areas = [];
            this.areas = areas;
        }

        var nodesNamePrefix = loadParams.nodesNamePrefix;
        var md = this.md;
        var planeNormalize = this.planeNormalize;
        var baseIndex = areas.length;

        var maxValue = Number.MAX_VALUE;

        for (var fa = 0; fa < numFileAreas; fa += 1)
        {
            var fileArea = fileAreas[fa];

            var targetName = fileArea.target;
            if (nodesNamePrefix)
            {
                targetName = (nodesNamePrefix + "/" + targetName);
            }
            var target = this.findNode(targetName);
            if (!target)
            {
                //Utilities.log("Missing target: " + targetName);
                baseIndex -= 1;
                continue;
            }

            var matrix = target.getWorldTransform();
            var m0 = matrix[0];
            var m1 = matrix[1];
            var m2 = matrix[2];
            var m3 = matrix[3];
            var m4 = matrix[4];
            var m5 = matrix[5];
            var m6 = matrix[6];
            var m7 = matrix[7];
            var m8 = matrix[8];
            var m9 = matrix[9];
            var m10 = matrix[10];
            var m11 = matrix[11];

            var minAreaX = maxValue;
            var minAreaY = maxValue;
            var minAreaZ = maxValue;
            var maxAreaX = -maxValue;
            var maxAreaY = -maxValue;
            var maxAreaZ = -maxValue;

            var filePortals = fileArea.portals;
            var numFilePortals = filePortals.length;
            var portals = [];
            var filePortal, filePoints, points, numPoints, np, filePoint;
            for (var fp = 0; fp < numFilePortals; fp += 1)
            {
                var minX = maxValue;
                var minY = maxValue;
                var minZ = maxValue;
                var maxX = -maxValue;
                var maxY = -maxValue;
                var maxZ = -maxValue;
                var c0 = 0;
                var c1 = 0;
                var c2 = 0;
                filePortal = filePortals[fp];
                filePoints = filePortal.points;
                numPoints = filePoints.length;
                points = [];
                for (np = 0; np < numPoints; np += 1)
                {
                    filePoint = filePoints[np];
                    var fp0 = filePoint[0];
                    var fp1 = filePoint[1];
                    var fp2 = filePoint[2];
                    var p0 = (m0 * fp0 + m3 * fp1 + m6 * fp2 + m9);
                    var p1 = (m1 * fp0 + m4 * fp1 + m7 * fp2 + m10);
                    var p2 = (m2 * fp0 + m5 * fp1 + m8 * fp2 + m11);
                    /*jslint white: false */
                    if (p0 < minX) { minX = p0; }
                    if (p1 < minY) { minY = p1; }
                    if (p2 < minZ) { minZ = p2; }
                    if (p0 > maxX) { maxX = p0; }
                    if (p1 > maxY) { maxY = p1; }
                    if (p2 > maxZ) { maxZ = p2; }
                    /*jslint white: true */
                    c0 += p0;
                    c1 += p1;
                    c2 += p2;
                    points.push(md.v3Build(p0, p1, p2));
                }
                /*jslint white: false */
                if (minX < minAreaX) { minAreaX = minX; }
                if (minY < minAreaY) { minAreaY = minY; }
                if (minZ < minAreaZ) { minAreaZ = minZ; }
                if (maxX > maxAreaX) { maxAreaX = maxX; }
                if (maxY > maxAreaY) { maxAreaY = maxY; }
                if (maxZ > maxAreaZ) { maxAreaZ = maxZ; }
                /*jslint white: true */
                var normal = md.v3Cross(md.v3Sub(points[1], points[0]), md.v3Sub(points[2], points[0]));
                var portal = {
                    area: (baseIndex + filePortal.area),
                    points: points,
                    origin: [(c0 / numPoints), (c1 / numPoints), (c2 / numPoints)],
                    extents: [minX, minY, minZ, maxX, maxY, maxZ],
                    plane: planeNormalize([normal[0], normal[1], normal[2], md.v3Dot(normal, points[0])])
                };
                portals.push(portal);
            }

            var area = {
                target: target,
                portals: portals,
                extents: [minAreaX, minAreaY, minAreaZ, maxAreaX, maxAreaY, maxAreaZ]
            };
            areas.push(area);
        }

        // Keep bsp tree
        var fileBspNodes = sceneData.bspnodes;
        var numBspNodes = fileBspNodes.length;
        var bspNodes = [];
        bspNodes.length = numBspNodes;
        this.bspNodes = bspNodes;
        for (var bn = 0; bn < numBspNodes; bn += 1)
        {
            var fileBspNode = fileBspNodes[bn];
            var plane = fileBspNode.plane;
            bspNodes[bn] = {
                    plane: [plane[0], plane[1], plane[2], -plane[3]],
                    pos: fileBspNode.pos,
                    neg: fileBspNode.neg
                };
        }
    },

    //
    // load
    //
    load: function sceneLoadFn(loadParams)
    {
        var scene = this;

        if (!loadParams.append)
        {
            this.clearShapes();
            this.semantics = {};
        }

        var sceneCompleteLoadStage = function sceneCompleteLoadStageFn()
        {
            if (loadParams.keepLights)
            {
                scene.loadLights(loadParams);
            }

            scene.loadNodes(loadParams);

            if (loadParams.physicsManager)
            {
                loadParams.physicsManager.loadNodes(loadParams, scene);
            }

            scene.loadAreas(loadParams);

            scene.endLoading(loadParams.onload);
        };

        if (loadParams.graphicsDevice)
        {
            this.loadMaterials(loadParams);
        }

        // Needs to be called before the geometry is loaded by loadNodes or streamShapes
        scene.loadSkeletons(loadParams);

        var yieldFn = loadParams.yieldFn;
        if (yieldFn)
        {
            var streamNodesStage = function sceneStreamNodesStage()
            {
                scene.streamShapes(loadParams, sceneCompleteLoadStage);
            };
            yieldFn(streamNodesStage);
        }
        else
        {
            sceneCompleteLoadStage();
        }
    },

    planeNormalize : function scenePlaneNormalizeFn(plane)
    {
        var a = plane[0];
        var b = plane[1];
        var c = plane[2];
        var lsq = ((a * a) + (b * b) + (c * c));
        if (lsq > 0.0)
        {
            var lr = 1.0 / Math.sqrt(lsq);
            return [(a * lr), (b * lr), (c * lr), (plane[3] * lr)];
        }
        else
        {
            return [0, 0, 0, 0];
        }
    },

    isInsidePlanesAABB : function sceneIsInsidePlanesAABBFn(extents, planes)
    {
        var n0 = extents[0];
        var n1 = extents[1];
        var n2 = extents[2];
        var p0 = extents[3];
        var p1 = extents[4];
        var p2 = extents[5];
        var numPlanes = planes.length;
        var n = 0;
        do
        {
            var plane = planes[n];
            var d0 = plane[0];
            var d1 = plane[1];
            var d2 = plane[2];
            if ((d0 * (d0 < 0 ? n0 : p0) + d1 * (d1 < 0 ? n1 : p1) + d2 * (d2 < 0 ? n2 : p2)) < plane[3])
            {
                return false;
            }
            n += 1;
        }
        while (n < numPlanes);
        return true;
    },

    isFullyInsidePlanesAABB : function sceneIsFullyInsidePlanesAABBFn(extents, planes)
    {
        var n0 = extents[0];
        var n1 = extents[1];
        var n2 = extents[2];
        var p0 = extents[3];
        var p1 = extents[4];
        var p2 = extents[5];
        var numPlanes = planes.length;
        var n = 0;
        do
        {
            var plane = planes[n];
            var d0 = plane[0];
            var d1 = plane[1];
            var d2 = plane[2];
            if ((d0 * (d0 > 0 ? n0 : p0) + d1 * (d1 > 0 ? n1 : p1) + d2 * (d2 > 0 ? n2 : p2)) < plane[3])
            {
                return false;
            }
            n += 1;
        }
        while (n < numPlanes);
        return true;
    },

    extractFrustumPlanes: function sceneExtractFrustumPlanesFn(camera)
    {
        var planeNormalize = this.planeNormalize;
        var m = camera.viewProjectionMatrix;
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var m9 = m[9];
        var m10 = m[10];
        var m11 = m[11];
        var m12 = m[12];
        var m13 = m[13];
        var m14 = m[14];
        var m15 = m[15];
        var planes = this.frustumPlanes;

        // Negate 'd' here to avoid doing it on the isVisible functions
        planes[0] = planeNormalize([(m3 + m0), (m7 + m4), (m11 + m8), -(m15 + m12)]); // left
        planes[1] = planeNormalize([(m3 - m0), (m7 - m4), (m11 - m8), -(m15 - m12)]); // right
        planes[2] = planeNormalize([(m3 - m1), (m7 - m5), (m11 - m9), -(m15 - m13)]); // top
        planes[3] = planeNormalize([(m3 + m1), (m7 + m5), (m11 + m9), -(m15 + m13)]); // bottom

        if (this.areas)
        {
            if (planes.length > 4)
            {
                planes.length = 4;
            }
        }
        else
        {
            planes[4] = planeNormalize([(m3 - m2), (m7 - m6), (m11 - m10), -(m15 - m14)]); // far
        }

        this.nearPlane = planeNormalize([(m3 + m2), (m7 + m6), (m11 + m10), -(m15 + m14)]);  // near

        return planes;
    },

    //
    // calculateHullScreenExtents
    //
    calculateHullScreenExtents : function sceneCalculateHullScreenExtents(polygons)
    {
        // Sutherland-Hodgman polygon clipping algorithm
        function clipLine(va, vb, axis, positive, out)
        {
            var a = va[axis];
            var b = vb[axis];
            var aw = va[3];
            var bw = vb[3];
            var t = 0.0;
            var bInside = true;
            if (positive)
            {
                if (a > aw)
                {
                    if (b <= bw)
                    {
                        if (b < bw)
                        {
                            t = ((aw - a) / ((b - a) - (bw - aw)));
                        }
                    }
                    else
                    {
                        // both out
                        return;
                    }
                }
                else if (b > bw)
                {
                    if (a < aw)
                    {
                        t = ((aw - a) / ((b - a) - (bw - aw)));
                    }
                    bInside = false;
                }
            }
            else
            {
                if (a < -aw)
                {
                    if (b >= -bw)
                    {
                        if (b > -bw)
                        {
                            t = ((- aw - a) / ((b - a) + (bw - aw)));
                        }
                    }
                    else
                    {
                        // both out
                        return;
                    }
                }
                else if (b < -bw)
                {
                    if (a > -aw)
                    {
                        t = ((- aw - a) / ((b - a) + (bw - aw)));
                    }
                    bInside = false;
                }
            }

            if (t > 0.0)
            {
                var ax = va[0];
                var ay = va[1];
                var az = va[2];
                var bx = vb[0];
                var by = vb[1];
                var bz = vb[2];
                out.push([ (ax + (t * (bx - ax))),
                           (ay + (t * (by - ay))),
                           (az + (t * (bz - az))),
                           (aw + (t * (bw - aw))) ]);
            }

            if (bInside)
            {
                out.push(vb);
            }
        }

        var minX =  1.0;
        var maxX = -1.0;
        var minY =  1.0;
        var maxY = -1.0;

        var numPolygons = polygons.length;
        for (var n = 0; n < numPolygons; n += 1)
        {
            var points = polygons[n];
            var numPoints, p, a, b, out;
            for (var positive = 0; positive < 2; positive += 1)
            {
                for (var axis = 0; axis < 3; axis += 1)
                {
                    numPoints = points.length;
                    if (!numPoints)
                    {
                        break;
                    }
                    out = [];
                    for (p = 0; p < numPoints; p += 1)
                    {
                        if (p < 1)
                        {
                            a = points[numPoints - 1];
                        }
                        else
                        {
                            a = points[p - 1];
                        }
                        b = points[p];
                        clipLine(a, b, axis, positive, out);
                    }
                    points = out;
                }
            }

            numPoints = points.length;
            for (p = 0; p < numPoints; p += 1)
            {
                a = points[p];
                var ax = a[0];
                var ay = a[1];
                var aw = a[3];
                if (aw === 0)
                {
                    ax = (ax >= 0 ? 1 : -1);
                    ay = (ay >= 0 ? 1 : -1);
                }
                else
                {
                    var rcpa = 1.0 / aw;
                    ax *= rcpa;
                    ay *= rcpa;
                }
                if (minX > ax)
                {
                    minX = ax;
                }
                if (maxX < ax)
                {
                    maxX = ax;
                }
                if (minY > ay)
                {
                    minY = ay;
                }
                if (maxY < ay)
                {
                    maxY = ay;
                }
            }
        }

        if (minX >= maxX || minY >= maxY)
        {
            return undefined;
        }

        if (minX < -1.0)
        {
            minX = -1.0;
        }
        if (maxX > 1.0)
        {
            maxX = 1.0;
        }
        if (minY < -1.0)
        {
            minY = -1.0;
        }
        if (maxY > 1.0)
        {
            maxY = 1.0;
        }
        return [minX, minY, maxX, maxY];
    },

    //
    // calculateLightsScreenExtents
    //
    calculateLightsScreenExtents : function sceneCalculateLightsScreenExtentsFn(camera)
    {
        var visibleLights = this.visibleLights;
        var numVisibleLights = visibleLights.length;
        if (numVisibleLights > 0)
        {
            var matrix, halfExtents, center, hx, hy, hz, p0, p1, p2, p3, p4, p5, p6, p7, st, polygons;
            var lightInstance, light, worldViewProjectionMatrix;
            var viewProjectionMatrix = camera.viewProjectionMatrix;
            var calculateHullScreenExtents = this.calculateHullScreenExtents;
            var md = this.md;
            var m44Transform = md.m44Transform;
            var m43MulM44 = md.m43MulM44;
            var v4Build = md.v4Build;
            var spotA = v4Build.call(md, -1, -1, 1, 1);
            var spotB = v4Build.call(md,  1, -1, 1, 1);
            var spotC = v4Build.call(md, -1,  1, 1, 1);
            var spotD = v4Build.call(md,  1,  1, 1, 1);
            var n = 0;
            do
            {
                lightInstance = visibleLights[n];
                light = lightInstance.light;
                if (light)
                {
                    if (light.global)
                    {
                        continue;
                    }

                    matrix = lightInstance.node.world;

                    if (light.spot)
                    {
                        var transform = md.m33MulM43(light.frustum, matrix);

                        worldViewProjectionMatrix = m43MulM44.call(md, transform, viewProjectionMatrix, worldViewProjectionMatrix);

                        p0 = m44Transform.call(md, worldViewProjectionMatrix, spotA, p0);
                        p1 = m44Transform.call(md, worldViewProjectionMatrix, spotB, p1);
                        p2 = m44Transform.call(md, worldViewProjectionMatrix, spotC, p2);
                        p3 = m44Transform.call(md, worldViewProjectionMatrix, spotD, p3);

                        st = md.m43Pos(matrix);
                        st = v4Build.call(md, st[0], st[1], st[2], 1);
                        st = m44Transform.call(md, viewProjectionMatrix, st, st);

                        polygons = [ [st, p0, p1],
                                     [st, p1, p3],
                                     [st, p2, p0],
                                     [st, p3, p2],
                                     [p2, p3, p1, p0]];
                    }
                    else
                    {
                        halfExtents = light.halfExtents;
                        if (!light.fog)
                        {
                            center = light.center;
                            if (center)
                            {
                                matrix = md.m43Offset(matrix, center);
                            }
                        }

                        hx = halfExtents[0];
                        hy = halfExtents[1];
                        hz = halfExtents[2];

                        worldViewProjectionMatrix = m43MulM44.call(md, matrix, viewProjectionMatrix, worldViewProjectionMatrix);

                        p0 = m44Transform.call(md, worldViewProjectionMatrix, v4Build.call(md, - hx, - hy, - hz, 1, p0), p0);
                        p1 = m44Transform.call(md, worldViewProjectionMatrix, v4Build.call(md, + hx, - hy, - hz, 1, p1), p1);
                        p2 = m44Transform.call(md, worldViewProjectionMatrix, v4Build.call(md, + hx, - hy, + hz, 1, p2), p2);
                        p3 = m44Transform.call(md, worldViewProjectionMatrix, v4Build.call(md, - hx, - hy, + hz, 1, p3), p3);
                        p4 = m44Transform.call(md, worldViewProjectionMatrix, v4Build.call(md, - hx, + hy, - hz, 1, p4), p4);
                        p5 = m44Transform.call(md, worldViewProjectionMatrix, v4Build.call(md, + hx, + hy, - hz, 1, p5), p5);
                        p6 = m44Transform.call(md, worldViewProjectionMatrix, v4Build.call(md, + hx, + hy, + hz, 1, p6), p6);
                        p7 = m44Transform.call(md, worldViewProjectionMatrix, v4Build.call(md, - hx, + hy, + hz, 1, p7), p7);

                        polygons = [ [p3, p2, p1, p0],
                                     [p4, p5, p6, p7],
                                     [p0, p1, p5, p4],
                                     [p7, p6, p2, p3],
                                     [p4, p7, p3, p0],
                                     [p1, p2, p6, p5] ];
                    }

                    lightInstance.screenExtents = calculateHullScreenExtents(polygons);
                }

                n += 1;
            }
            while (n < numVisibleLights);
        }
    },

    //
    // destroy
    //
    destroy: function sceneDestroyFn()
    {
        this.clear();
        if (this.vertexBufferManager)
        {
            this.vertexBufferManager.destroy();
            delete this.vertexBufferManager;
        }
        if (this.indexBufferManager)
        {
            this.indexBufferManager.destroy();
            delete this.indexBufferManager;
        }
    },

    getQueryCounter: function sceneGetQueryCounter()
    {
        var queryCounter = this.queryCounter;
        this.queryCounter = (queryCounter + 1);
        return queryCounter;
    }
};

// Constructor function
Scene.create = function sceneCreateFn(mathDevice)
{
    var newScene = new Scene();
    newScene.md = mathDevice;
    newScene.clear();

    newScene.onGeometryDestroyed = function sceneOnGeometryDestroyedFn(geometry)
    {
        var scene = newScene;
        geometry.reference.unsubscribeDestroyed(scene.onGeometryDestroyed);
        delete scene.shapes[geometry.name];
    };

    newScene.onMaterialDestroyed = function sceneOnMaterialDestroyedFn(material)
    {
        var scene = newScene;
        material.reference.unsubscribeDestroyed(scene.onMaterialDestroyed);
        delete scene.materials[material.name];
    };

    return newScene;
};

// Detect correct typed arrays
(function () {
    var testArray, textDescriptor;
    if (typeof Uint16Array !== "undefined")
    {
        testArray = new Uint16Array(4);
        textDescriptor = Object.prototype.toString.call(testArray);
        if (textDescriptor === '[object Uint16Array]')
        {
            Scene.prototype.uint16ArrayConstructor = Uint16Array;
        }
    }
    if (typeof Uint32Array !== "undefined")
    {
        testArray = new Uint32Array(4);
        textDescriptor = Object.prototype.toString.call(testArray);
        if (textDescriptor === '[object Uint32Array]')
        {
            Scene.prototype.uint32ArrayConstructor = Uint32Array;
        }
    }
    if (typeof Float32Array !== "undefined")
    {
        testArray = new Float32Array(4);
        textDescriptor = Object.prototype.toString.call(testArray);
        if (textDescriptor === '[object Float32Array]')
        {
            Scene.prototype.float32ArrayConstructor = Float32Array;
        }
    }
}());

// Copyright (c) 2010-2012 Turbulenz Limited
/*global TurbulenzEngine: false*/
/*global Utilities: false*/
/*global Observer: false*/

//
// SceneNode
//
function SceneNode() {}

//
//SceneNode.makePath
//
SceneNode.makePath = function sceneNodeMakePathFn(parentPath, childName)
{
    return parentPath + "/" + childName;
};

//
//SceneNode.invalidSetLocalTransform
//
SceneNode.invalidSetLocalTransform = function sceneNodeInvlaidSetLocalTransformFn()
{
    Utilities.assert(false, "setLocalTransform can not be called on static nodes.");
};

SceneNode.prototype =
{
    version: 1,

    //
    //getName
    //
    getName: function sceneNodeGetNameFn()
    {
        return this.name;
    },

    //
    //getPath
    //
    getPath: function sceneNodeGetPathFn()
    {
        if (this.parent)
        {
            return SceneNode.makePath(this.parent.getPath(), this.name);
        }
        return this.name;
    },

    //
    //getParent
    //
    getParent: function sceneNodeGetParentFn()
    {
        return this.parent;
    },

    //
    //setParentHelper
    //
    setParentHelper: function sceneNodeHelperSetParentFn(parent)
    {
        //***Only valid to call from addChild()/removeChild() ***
        this.parent = parent;
        this.notifiedParent = false;
        this.dirtyWorld = false;
        this.setDirtyWorldTransform();
    },

    //
    //addChild
    //
    addChild: function sceneNodeAddChildFn(child)
    {
        if (child.parent)
        {
            child.parent.removeChild(child);
        }
        else
        {
            //Child was a root node
            if (child.scene)
            {
                child.scene.removeRootNode(child);
            }
        }

        if (!this.children)
        {
            this.children = [];
            this.childNeedsUpdateCount = 0;
        }
        this.children.push(child);
        child.setParentHelper(this);

        if (this.dynamic && !child.dynamic)
        {
            child.setDynamic();
        }
    },

    //
    //removeChild
    //
    removeChild: function sceneNodeRemoveChildFn(child)
    {
        var children = this.children;
        if (children)
        {
            if (child.notifiedParent)
            {
                this.childUpdated();
            }
            var numChildren = children.length;
            for (var n = 0; n < numChildren; n += 1)
            {
                if (children[n] === child)
                {
                    var root = this.getRoot();
                    if (root.scene)
                    {
                        child.removedFromScene(root.scene);   //Maybe decouple with an event.
                    }
                    children.splice(n, 1);
                    child.setParentHelper(null);
                    return;
                }
            }
        }
        Utilities.assert(false, "Invalid child");
    },

    //
    //findChild
    //
    findChild: function sceneNodeFindChildFn(name)
    {
        var children = this.children;
        if (children)
        {
            var numChildren = children.length;
            for (var childIndex = 0; childIndex < numChildren; childIndex += 1)
            {
                if (children[childIndex].name === name)
                {
                    return children[childIndex];
                }
            }
        }
        return undefined;
    },

    //
    // clone
    //
    clone: function sceneNodeCloneFn(newNodeName)
    {
        var newNode = SceneNode.create({name: newNodeName || this.name,
                                              local: this.local,
                                              dynamic: this.dynamic,
                                              disabled: this.disabled});

        // Clone renderables
        var renderables = this.renderables;
        if (renderables)
        {
            var numRenderables = renderables.length;

            for (var i = 0; i < numRenderables; i += 1)
            {
                var renderable = renderables[i];
                newNode.addRenderable(renderable.clone());
            }
        }

        // Clone lights
        var lights = this.lights;
        if (lights)
        {
            var numLights = lights.length;
            for (var l = 0; l < numLights; l += 1)
            {
                var light = lights[l];
                newNode.addLightInstance(light.clone());
            }
        }

        if (this.clonedObserver)
        {
            this.clonedObserver.notify({oldNode: this,
                                        newNode: newNode});
        }

        var childNodes = this.children;
        if (childNodes)
        {
            var numChildren = childNodes.length;
            for (var c = 0; c < numChildren; c += 1)
            {
                newNode.addChild(childNodes[c].clone());
            }
        }

        return newNode;
    },

    //
    //getRoot
    //
    getRoot: function sceneNodeGetRootFn()
    {
        var result = this;
        while (result.parent)
        {
            result = result.parent;
        }
        return result;
    },

    //
    // isInScene
    //
    isInScene: function sceneNodeIsInSceneFn()
    {
        if (this.getRoot().scene)
        {
            return true;
        }
        return false;
    },

    //
    //removedFromScene
    //
    removedFromScene: function sceneNodeRemovedFromSceneFn(scene)
    {
        //private function

        if (this.aabbTreeIndex !== undefined)
        {
            if (this.dynamic)
            {
                scene.dynamicSpatialMap.remove(this);
            }
            else
            {
                scene.staticSpatialMap.remove(this);
                scene.staticNodesChangeCounter += 1;
            }
        }

        var children = this.children;
        if (children)
        {
            var numChildren = children.length;
            for (var childIndex = 0; childIndex < numChildren; childIndex += 1)
            {
                children[childIndex].removedFromScene(scene);
            }
        }
    },

    //
    //setLocalTransform
    //
    setLocalTransform: function sceneNodeSetLocalTransformFn(matrix)
    {
        if (matrix !== this.local)
        {
            this.local = this.mathDevice.m43Copy(matrix, this.local);
        }

        //inlined non-recursive setDirtyWorldTransform()
        function setDirtyWorldTransformHelperFn(nodes)
        {
            var numRemainingNodes = nodes.length;
            var node, index, child;
            do
            {
                numRemainingNodes -= 1;
                node = nodes[numRemainingNodes];

                node.dirtyWorld = true;

                if (!node.customWorldExtents && node.localExtents)
                {
                    node.dirtyWorldExtents = true;
                }

                var children = node.children;
                if (children)
                {
                    var numChildren = children.length;

                    if (!node.childNeedsUpdateCount)
                    {
                        // Common case of propagating down to clean children
                        node.childNeedsUpdateCount = numChildren;
                        for (index = 0; index < numChildren; index += 1)
                        {
                            child = children[index];
                            child.notifiedParent = true;

                            nodes[numRemainingNodes] = child;
                            numRemainingNodes += 1;
                        }
                    }
                    else
                    {
                        // One or more children dirty
                        for (index = 0; index < numChildren; index += 1)
                        {
                            child = children[index];
                            if (!child.dirtyWorld)
                            {
                                if (!child.notifiedParent)
                                {
                                    child.notifiedParent = true;
                                    node.childNeedsUpdateCount += 1;
                                }

                                nodes[numRemainingNodes] = child;
                                numRemainingNodes += 1;
                            }
                        }
                    }
                }
            }
            while (0 < numRemainingNodes);
        }

        if (!this.dirtyWorld)
        {
            //inlined updateRequired()
            var parent = this.parent;
            if (parent)
            {
                if (!this.notifiedParent)
                {
                    this.notifiedParent = true;
                    parent.childNeedsUpdate();
                }
            }
            else
            {
                //Root nodes
                var scene = this.scene;
                if (scene)
                {
                    var dirtyRoots = scene.dirtyRoots;
                    if (!dirtyRoots)
                    {
                        dirtyRoots = {};
                        scene.dirtyRoots = dirtyRoots;
                    }
                    dirtyRoots[this.name] = this;
                }
            }

            setDirtyWorldTransformHelperFn([this]);
        }
    },

    //
    //getLocalTransform
    //
    getLocalTransform: function sceneNodeSetLocalTransformFn()
    {
        return this.local;
    },

    //
    //setDirtyWorldTransform
    //
    setDirtyWorldTransform: function sceneNodeSetDirtyWorldTransformFn()
    {
        //private function
        if (this.dirtyWorld)
        {
            return;
        }

        function setDirtyWorldTransformHelperFn()
        {
            this.dirtyWorld = true;

            if (!this.customWorldExtents && this.localExtents)
            {
                this.dirtyWorldExtents = true;
            }

            var children = this.children;
            if (children)
            {
                var numChildren = children.length;
                var index;
                var child;

                if (!this.childNeedsUpdateCount)
                {
                    // Common case of propagating down to clean children
                    this.childNeedsUpdateCount = numChildren;
                    for (index = 0; index < numChildren; index += 1)
                    {
                        child = children[index];
                        child.notifiedParent = true;
                        setDirtyWorldTransformHelperFn.call(child);
                    }
                }
                else
                {
                    // One or more children dirty
                    for (index = 0; index < numChildren; index += 1)
                    {
                        child = children[index];
                        if (!child.dirtyWorld)
                        {
                            if (!child.notifiedParent)
                            {
                                child.notifiedParent = true;
                                this.childNeedsUpdateCount += 1;
                            }
                            setDirtyWorldTransformHelperFn.call(child);
                        }
                    }
                }
            }
        }

        //inlined updateRequired()
        if (this.parent)
        {
            if (!this.notifiedParent)
            {
                this.parent.childNeedsUpdate();
                this.notifiedParent = true;
            }
        }
        else
        {
            //Root nodes
            var scene = this.scene;
            if (scene)
            {
                if (!scene.dirtyRoots)
                {
                    scene.dirtyRoots = {};
                }
                scene.dirtyRoots[this.name] = this;
            }
        }

        setDirtyWorldTransformHelperFn.call(this);
    },

    //
    //getWorldTransform
    //
    getWorldTransform: function sceneNodeGetWorldTransformFn()
    {
        if (this.dirtyWorld)
        {
            this.dirtyWorld = false;
            this.worldUpdate += 1;
            this.checkUpdateRequired();

            var parent = this.parent;
            var local = this.local;
            if (parent)
            {
                var parentWorld = parent.getWorldTransform();
                if (local)
                {
                    this.world = this.mathDevice.m43Mul(local, parentWorld, this.world);
                }
                else
                {
                    this.world = this.mathDevice.m43Copy(parentWorld, this.world);
                }
            }
            else
            {
                this.world =  this.mathDevice.m43Copy(local, this.world);
            }
        }
        return this.world;
    },

    //
    //setDynamic
    //
    setDynamic: function sceneNodeSetDynamicFn()
    {
        if (!this.dynamic)
        {
            if (this.aabbTreeIndex !== undefined)
            {
                var scene = this.getRoot().scene;
                scene.staticSpatialMap.remove(this);
                scene.staticNodesChangeCounter += 1;
                delete this.aabbTreeIndex;
            }
            delete this.setLocalTransform; //Allowed to move again.

            var worldExtents = this.getWorldExtents();  //If there is any dirty state then its possible that even if it still has an aabbTreeIndex it may no longer.
            if (worldExtents)
            {
                this.getRoot().scene.dynamicSpatialMap.update(this, worldExtents);
            }
            this.dynamic = true;
        }

        var children = this.children;
        if (children)
        {
            var numChildren = children.length;
            for (var n = 0; n < numChildren; n += 1)
            {
                children[n].setDynamic();
            }
        }
    },

    //
    //setStatic
    //
    setStatic: function sceneNodeSetStaticFn()
    {
        if (this.dynamic)
        {
            if (this.aabbTreeIndex !== undefined)
            {
                this.getRoot().scene.dynamicSpatialMap.remove(this);
                delete this.aabbTreeIndex;
            }

            this.setLocalTransform = SceneNode.invalidSetLocalTransform;

            var worldExtents = this.getWorldExtents();  //If there is any dirty state then its possible that even if it still has an aabbTreeIndex it may no longer.
            if (worldExtents)
            {
                var scene = this.getRoot().scene;
                if (scene)
                {
                    scene.staticSpatialMap.update(this, worldExtents);
                    scene.staticNodesChangeCounter += 1;
                }
            }

            delete this.dirtyWorldExtents;
            delete this.worldExtentsUpdate;
            delete this.dirtyWorld;
            delete this.worldExtentsUpdate;
            delete this.notifiedParent;
            delete this.dynamic;
        }

        var children = this.children;
        if (children)
        {
            var numChildren = children.length;
            for (var n = 0; n < numChildren; n += 1)
            {
                children[n].setStatic();
            }
        }
    },

    //
    //setDisabled
    //
    setDisabled: function sceneNodeSetDisabled(disabled)
    {
        if (disabled)
        {
            this.disabled = true;
        }
        else
        {
            delete this.disabled;
        }
    },

    //
    //getDisabled
    //
    getDisabled: function sceneNodeGetDisabled()
    {
        return this.disabled ? true : false;
    },

    //
    //enableHierarchy
    //
    enableHierarchy: function sceneNodeDisableHierarchyFn(enabled)
    {
        this.setDisabled(!enabled);

        var children = this.children;
        if (children)
        {
            var numChildren = children.length;
            for (var c = 0; c < numChildren; c += 1)
            {
                children[c].enableHierarchy(enabled);
            }
        }
    },

    //
    //childUpdated
    //
    childUpdated: function sceneNodeChildUpdatedFn()
    {
        //Private function
        //Utilities.assert(this.childNeedsUpdateCount >= 0, "Child update logic incorrect");
        this.childNeedsUpdateCount -= 1;
        if (this.childNeedsUpdateCount === 0 && this.dirtyWorld === false && this.dirtyWorldExtents === false)
        {   //no longer dirty
            if (this.parent)
            {
                this.parent.childUpdated();
                this.notifiedParent = false;
            }
        }
    },

    //
    //childNeedsUpdate
    //
    childNeedsUpdate: function sceneNodeChildNeedsUpdateFn()
    {
        //Private function
        this.updateRequired();        //propagate to the root node.
        this.childNeedsUpdateCount += 1;
    },

    //
    //updateRequired
    //
    updateRequired: function sceneNodeUpdateRequiredFn()
    {
        //Private function
        var parent = this.parent;
        if (parent)
        {
            if (!this.notifiedParent)
            {
                this.notifiedParent = true;
                parent.childNeedsUpdate();
            }
        }
        else
        {
            //Root nodes
            var scene = this.scene;
            if (scene)
            {
                var dirtyRoots = scene.dirtyRoots;
                if (!dirtyRoots)
                {
                    dirtyRoots = {};
                    scene.dirtyRoots = dirtyRoots;
                }
                dirtyRoots[this.name] = this;
            }
        }
    },

    //
    //checkUpdateRequired
    //
    checkUpdateRequired: function sceneNodeCheckUpdateRequiredFn()
    {
        //private function
        if (this.notifiedParent)
        {
            if (!this.dirtyWorldExtents &&
               !this.dirtyWorld &&
               !this.childNeedsUpdateCount)
            {
                this.parent.childUpdated();
                this.notifiedParent = false;
            }
        }
    },

    //
    //update
    //
    update: function sceneNodeUpdateFn(scene)
    {
        this.updateHelper(this.mathDevice, (scene || this.scene), [this]);
    },

    // PRIVATE
    updateHelper: function sceneNodeUpdateHelperFn(mathDevice, scene, nodes)
    {
        var node, parent, index, worldExtents;
        var numNodes = nodes.length;
        var m43Copy = mathDevice.m43Copy;
        var m43Mul = mathDevice.m43Mul;
        do
        {
            numNodes -= 1;
            node = nodes[numNodes];

            if (node.dirtyWorld)
            {
                node.dirtyWorld = false;
                node.worldUpdate += 1;

                parent = node.parent;
                if (parent)
                {
                    var local = node.local;
                    if (local)
                    {
                        node.world = m43Mul.call(mathDevice, local, parent.world, node.world);
                    }
                    else
                    {
                        node.world = m43Copy.call(mathDevice, parent.world, node.world);
                    }
                }
                else
                {
                    node.world = m43Copy.call(mathDevice, node.local, node.world);
                }
            }

            if (node.dirtyWorldExtents)
            {
                if (node.customWorldExtents)
                {
                    node.worldExtents = node.customWorldExtents;
                }
                else
                {
                    if (node.dirtyLocalExtents)
                    {
                        node.updateLocalExtents();
                    }

                    if (node.numCustomRenderableWorldExtents)
                    {
                        var renderable, extents, minX, minY, minZ, maxX, maxY, maxZ;
                        var renderables = node.renderables;
                        var numRenderables = renderables.length;
                        var empty = true;

                        for (index = 0; index < numRenderables; index += 1)
                        {
                            renderable = renderables[index];
                            if (renderable.hasCustomWorldExtents())
                            {
                                extents = renderable.getCustomWorldExtents();
                                minX = extents[0];
                                minY = extents[1];
                                minZ = extents[2];
                                maxX = extents[3];
                                maxY = extents[4];
                                maxZ = extents[5];
                                index += 1;
                                empty = false;
                                break;
                            }
                        }

                        for (; index < numRenderables; index += 1)
                        {
                            renderable = renderables[index];
                            if (renderable.hasCustomWorldExtents())
                            {
                                extents = renderable.getCustomWorldExtents();

                                if (minX > extents[0])
                                {
                                    minX = extents[0];
                                }
                                if (minY > extents[1])
                                {
                                    minY = extents[1];
                                }
                                if (minZ > extents[2])
                                {
                                    minZ = extents[2];
                                }

                                if (maxX < extents[3])
                                {
                                    maxX = extents[3];
                                }
                                if (maxY < extents[4])
                                {
                                    maxY = extents[4];
                                }
                                if (maxZ < extents[5])
                                {
                                    maxZ = extents[5];
                                }
                            }
                        }

                        if (empty)
                        {
                            // This should not happen...
                            delete node.worldExtents;
                        }
                        else
                        {
                            worldExtents = node.worldExtents;
                            if (!worldExtents)
                            {
                                worldExtents = [];
                                node.worldExtents = worldExtents;
                            }
                            worldExtents[0] = minX;
                            worldExtents[1] = minY;
                            worldExtents[2] = minZ;
                            worldExtents[3] = maxX;
                            worldExtents[4] = maxY;
                            worldExtents[5] = maxZ;
                        }
                    }
                    else if (node.localExtents)
                    {
                        //get center and half extents
                        var localExtentsCenter = node.localExtentsCenter;
                        var localHalfExtents = node.localHalfExtents;
                        var c0 = localExtentsCenter[0];
                        var c1 = localExtentsCenter[1];
                        var c2 = localExtentsCenter[2];
                        var h0 = localHalfExtents[0];
                        var h1 = localHalfExtents[1];
                        var h2 = localHalfExtents[2];

                        var world = node.world;
                        var m0 = world[0];
                        var m1 = world[1];
                        var m2 = world[2];
                        var m3 = world[3];
                        var m4 = world[4];
                        var m5 = world[5];
                        var m6 = world[6];
                        var m7 = world[7];
                        var m8 = world[8];

                        var ct0 = world[9];
                        var ct1 = world[10];
                        var ct2 = world[11];
                        if (c0 !== 0 ||
                            c1 !== 0 ||
                            c2 !== 0)
                        {
                            ct0 += (m0 * c0 + m3 * c1 + m6 * c2);
                            ct1 += (m1 * c0 + m4 * c1 + m7 * c2);
                            ct2 += (m2 * c0 + m5 * c1 + m8 * c2);
                        }

                        var ht0 = ((m0 < 0 ? -m0 : m0) * h0 + (m3 < 0 ? -m3 : m3) * h1 + (m6 < 0 ? -m6 : m6) * h2);
                        var ht1 = ((m1 < 0 ? -m1 : m1) * h0 + (m4 < 0 ? -m4 : m4) * h1 + (m7 < 0 ? -m7 : m7) * h2);
                        var ht2 = ((m2 < 0 ? -m2 : m2) * h0 + (m5 < 0 ? -m5 : m5) * h1 + (m8 < 0 ? -m8 : m8) * h2);

                        worldExtents = node.worldExtents;
                        if (!worldExtents)
                        {
                            worldExtents = [];
                            node.worldExtents = worldExtents;
                        }
                        worldExtents[0] = (ct0 - ht0);
                        worldExtents[1] = (ct1 - ht1);
                        worldExtents[2] = (ct2 - ht2);
                        worldExtents[3] = (ct0 + ht0);
                        worldExtents[4] = (ct1 + ht1);
                        worldExtents[5] = (ct2 + ht2);
                    }
                    else
                    {
                        //no object with size so no extents.
                        delete node.worldExtents;
                    }
                }

                node.dirtyWorldExtents = false;
                node.worldExtentsUpdate = true;
            }

            if (node.worldExtentsUpdate)
            {
                node.worldExtentsUpdate = false;

                worldExtents = node.worldExtents;
                if (worldExtents)
                {
                    if (node.dynamic)
                    {
                        scene.dynamicSpatialMap.update(node, worldExtents);
                    }
                    else
                    {
                        scene.staticSpatialMap.update(node, worldExtents);
                        scene.staticNodesChangeCounter += 1;
                        //Remove things that are no longer relevant.
                        node.setLocalTransform = SceneNode.invalidSetLocalTransform;  //no longer allowed to move it.
                        delete node.dirtyWorldExtents;
                        delete node.worldExtentsUpdate;
                        delete node.dirtyWorld;
                        delete node.notifiedParent;
                    }
                }
                else if (node.aabbTreeIndex !== undefined)
                {
                    if (node.dynamic)
                    {
                        scene.dynamicSpatialMap.remove(node);
                    }
                    else
                    {
                        scene.staticSpatialMap.remove(node);
                        scene.staticNodesChangeCounter += 1;
                    }
                }
            }

            if (node.childNeedsUpdateCount)
            {
                node.childNeedsUpdateCount = 0;

                var children = node.children;
                if (children)
                {
                    var numChildren = children.length;
                    for (index = 0; index < numChildren; index += 1)
                    {
                        var child = children[index];
                        if (child.notifiedParent)
                        {
                            nodes[numNodes] = child;
                            numNodes += 1;
                        }
                    }
                }
            }

            if (node.notifiedParent)
            {
                node.notifiedParent = false;
            }
        }
        while (0 < numNodes);
    },

    //
    //updateLocalExtents
    //
    updateLocalExtents: function sceneNodeUpdateLocalExtentsFn()
    {
        var localExtents;
        var hasExtents = false;
        if (this.customLocalExtents)
        {
            this.localExtents = this.customLocalExtents;
            hasExtents = true;
        }
        else
        {
            var renderables = this.renderables;
            var lights = this.lightInstances;
            if (renderables || lights)
            {
                var maxValue = Number.MAX_VALUE;
                var minValue = -maxValue;
                var min = Math.min;
                var max = Math.max;
                var center, halfExtents;

                localExtents = [maxValue, maxValue, maxValue, minValue, minValue, minValue];
                this.localExtents = localExtents;
                hasExtents = true;

                if (renderables)
                {
                    var numRenderables = renderables.length;
                    for (var index = 0; index < numRenderables; index += 1)
                    {
                        var renderable = renderables[index];
                        halfExtents = renderable.halfExtents;
                        if (halfExtents && !renderable.hasCustomWorldExtents())
                        {
                            center = renderable.center;
                            if (center)
                            {
                                localExtents[0] = min(localExtents[0], (center[0] - halfExtents[0]));
                                localExtents[1] = min(localExtents[1], (center[1] - halfExtents[1]));
                                localExtents[2] = min(localExtents[2], (center[2] - halfExtents[2]));

                                localExtents[3] = max(localExtents[3], (center[0] + halfExtents[0]));
                                localExtents[4] = max(localExtents[4], (center[1] + halfExtents[1]));
                                localExtents[5] = max(localExtents[5], (center[2] + halfExtents[2]));
                            }
                            else
                            {
                                localExtents[0] = min(localExtents[0], - halfExtents[0]);
                                localExtents[1] = min(localExtents[1], - halfExtents[1]);
                                localExtents[2] = min(localExtents[2], - halfExtents[2]);

                                localExtents[3] = max(localExtents[3], + halfExtents[0]);
                                localExtents[4] = max(localExtents[4], + halfExtents[1]);
                                localExtents[5] = max(localExtents[5], + halfExtents[2]);
                            }
                        }
                    }
                }

                if (lights)
                {
                    var numLights = lights.length;
                    for (var lindex = 0; lindex < numLights; lindex += 1)
                    {
                        var light = lights[lindex].light;
                        halfExtents = light.halfExtents;
                        if (halfExtents)
                        {
                            center = light.center;
                            if (center)
                            {
                                localExtents[0] = min(localExtents[0], (center[0] - halfExtents[0]));
                                localExtents[1] = min(localExtents[1], (center[1] - halfExtents[1]));
                                localExtents[2] = min(localExtents[2], (center[2] - halfExtents[2]));

                                localExtents[3] = max(localExtents[3], (center[0] + halfExtents[0]));
                                localExtents[4] = max(localExtents[4], (center[1] + halfExtents[1]));
                                localExtents[5] = max(localExtents[5], (center[2] + halfExtents[2]));
                            }
                            else
                            {
                                localExtents[0] = min(localExtents[0], - halfExtents[0]);
                                localExtents[1] = min(localExtents[1], - halfExtents[1]);
                                localExtents[2] = min(localExtents[2], - halfExtents[2]);

                                localExtents[3] = max(localExtents[3], + halfExtents[0]);
                                localExtents[4] = max(localExtents[4], + halfExtents[1]);
                                localExtents[5] = max(localExtents[5], + halfExtents[2]);
                            }
                        }
                    }
                }
            }
        }
        if (hasExtents)
        {
            localExtents = this.localExtents;
            var cX = (localExtents[3] + localExtents[0]) * 0.5;
            var cY = (localExtents[4] + localExtents[1]) * 0.5;
            var cZ = (localExtents[5] + localExtents[2]) * 0.5;
            this.localExtentsCenter = [cX, cY, cZ];
            this.localHalfExtents = [(localExtents[3] - cX), (localExtents[4] - cY), (localExtents[5] - cZ)];
        }
        else
        {
            delete this.localExtents;
            delete this.localExtentsCenter;
            delete this.localHalfExtents;
        }

        this.dirtyLocalExtents = false;
    },

    //
    //getLocalExtents
    //
    getLocalExtents: function sceneNodeGetLocalExtentsFn()
    {
        if (this.dirtyLocalExtents)
        {
            this.updateLocalExtents();
        }
        return this.localExtents; //Can be undefined if no local extents. These are not transformed by the local transform matrix.
    },

    //
    //updateWorldExtents
    //
    updateWorldExtents: function sceneNodeUpdateWorldExtentsFn()
    {
        if (this.dirtyWorldExtents)
        {
            if (this.customWorldExtents)
            {
                this.worldExtents = this.customWorldExtents;
            }
            else
            {
                if (this.dirtyLocalExtents)
                {
                    this.updateLocalExtents();
                }

                var worldExtents;

                if (this.numCustomRenderableWorldExtents)
                {
                    var index, renderable, extents, minX, minY, minZ, maxX, maxY, maxZ;
                    var renderables = this.renderables;
                    var numRenderables = renderables.length;
                    var empty = true;

                    for (index = 0; index < numRenderables; index += 1)
                    {
                        renderable = renderables[index];
                        if (renderable.hasCustomWorldExtents())
                        {
                            extents = renderable.getCustomWorldExtents();
                            minX = extents[0];
                            minY = extents[1];
                            minZ = extents[2];
                            maxX = extents[3];
                            maxY = extents[4];
                            maxZ = extents[5];
                            index += 1;
                            empty = false;
                            break;
                        }
                    }

                    for (; index < numRenderables; index += 1)
                    {
                        renderable = renderables[index];
                        if (renderable.hasCustomWorldExtents())
                        {
                            extents = renderable.getCustomWorldExtents();

                            if (minX > extents[0])
                            {
                                minX = extents[0];
                            }
                            if (minY > extents[1])
                            {
                                minY = extents[1];
                            }
                            if (minZ > extents[2])
                            {
                                minZ = extents[2];
                            }

                            if (maxX < extents[3])
                            {
                                maxX = extents[3];
                            }
                            if (maxY < extents[4])
                            {
                                maxY = extents[4];
                            }
                            if (maxZ < extents[5])
                            {
                                maxZ = extents[5];
                            }
                        }
                    }

                    if (empty)
                    {
                        // This should not happen...
                        delete this.worldExtents;
                    }
                    else
                    {
                        worldExtents = this.worldExtents;
                        if (!worldExtents)
                        {
                            worldExtents = [];
                            this.worldExtents = worldExtents;
                        }
                        worldExtents[0] = minX;
                        worldExtents[1] = minY;
                        worldExtents[2] = minZ;
                        worldExtents[3] = maxX;
                        worldExtents[4] = maxY;
                        worldExtents[5] = maxZ;
                    }
                }
                else if (this.localExtents)
                {
                    //get center and half extents
                    var localExtentsCenter = this.localExtentsCenter;
                    var localHalfExtents = this.localHalfExtents;
                    var c0 = localExtentsCenter[0];
                    var c1 = localExtentsCenter[1];
                    var c2 = localExtentsCenter[2];
                    var h0 = localHalfExtents[0];
                    var h1 = localHalfExtents[1];
                    var h2 = localHalfExtents[2];

                    var world = this.world;
                    var m0 = world[0];
                    var m1 = world[1];
                    var m2 = world[2];
                    var m3 = world[3];
                    var m4 = world[4];
                    var m5 = world[5];
                    var m6 = world[6];
                    var m7 = world[7];
                    var m8 = world[8];

                    var ct0 = world[9];
                    var ct1 = world[10];
                    var ct2 = world[11];
                    if (c0 !== 0 ||
                        c1 !== 0 ||
                        c2 !== 0)
                    {
                        ct0 += (m0 * c0 + m3 * c1 + m6 * c2);
                        ct1 += (m1 * c0 + m4 * c1 + m7 * c2);
                        ct2 += (m2 * c0 + m5 * c1 + m8 * c2);
                    }

                    var ht0 = ((m0 < 0 ? -m0 : m0) * h0 + (m3 < 0 ? -m3 : m3) * h1 + (m6 < 0 ? -m6 : m6) * h2);
                    var ht1 = ((m1 < 0 ? -m1 : m1) * h0 + (m4 < 0 ? -m4 : m4) * h1 + (m7 < 0 ? -m7 : m7) * h2);
                    var ht2 = ((m2 < 0 ? -m2 : m2) * h0 + (m5 < 0 ? -m5 : m5) * h1 + (m8 < 0 ? -m8 : m8) * h2);

                    worldExtents = this.worldExtents;
                    if (!worldExtents)
                    {
                        worldExtents = [];
                        this.worldExtents = worldExtents;
                    }
                    worldExtents[0] = (ct0 - ht0);
                    worldExtents[1] = (ct1 - ht1);
                    worldExtents[2] = (ct2 - ht2);
                    worldExtents[3] = (ct0 + ht0);
                    worldExtents[4] = (ct1 + ht1);
                    worldExtents[5] = (ct2 + ht2);
                }
                else
                {
                    //no object with size so no extents.
                    delete this.worldExtents;
                }
            }

            this.dirtyWorldExtents = false;
            this.worldExtentsUpdate = true;

            this.checkUpdateRequired();
        }
    },

    //
    //getWorldExtents
    //
    getWorldExtents: function sceneNodeGetWorldExtentsFn()
    {   //This is its own extents, not it and all its children.
        if (this.dirtyWorldExtents)
        {
            this.updateWorldExtents();
        }
        return this.worldExtents;
    },

    //
    //addCustomLocalExtents
    //
    addCustomLocalExtents: function sceneNodeAddCustomLocalExtentsFn(localExtents)
    {
        var customWorldExtents = this.customWorldExtents;
        if (!customWorldExtents)
        {
            this.customWorldExtents = localExtents.slice();
        }
        else
        {
            customWorldExtents[0] = localExtents[0];
            customWorldExtents[1] = localExtents[1];
            customWorldExtents[2] = localExtents[2];
            customWorldExtents[3] = localExtents[3];
            customWorldExtents[4] = localExtents[4];
            customWorldExtents[5] = localExtents[5];
        }
        this.dirtyWorldExtents = true;
        this.dirtyLocalExtents = true;
        this.updateRequired();
    },

    //
    //removeCustomLocalExtents
    //
    removeCustomLocalExtents: function sceneNodeRemoveCustomLocalExtentsFn()
    {
        delete this.customLocalExtents;
        this.dirtyWorldExtents = true;
        this.dirtyLocalExtents = true;
        this.updateRequired();
    },

    //
    //getCustomLocalExtents
    //
    getCustomLocalExtents: function sceneNodeGetCustomLocalExtentsFn()
    {
        return this.customLocalExtents;
    },

    //
    //addCustomWorldExtents
    //
    addCustomWorldExtents: function sceneNodeAddCustomWorldExtentsFn(worldExtents)
    {
        var customWorldExtents = this.customWorldExtents;
        if (!customWorldExtents)
        {
            this.customWorldExtents = worldExtents.slice();
        }
        else
        {
            customWorldExtents[0] = worldExtents[0];
            customWorldExtents[1] = worldExtents[1];
            customWorldExtents[2] = worldExtents[2];
            customWorldExtents[3] = worldExtents[3];
            customWorldExtents[4] = worldExtents[4];
            customWorldExtents[5] = worldExtents[5];
        }
        this.dirtyWorldExtents = true;
        this.updateRequired();
    },

    //
    //removeCustomWorldExtents
    //
    removeCustomWorldExtents: function sceneNodeRemoveCustomWorldExtentsFn()
    {
        delete this.customWorldExtents;
        this.dirtyWorldExtents = true;
        this.updateRequired();
    },

    //
    //getCustomWorldExtents
    //
    getCustomWorldExtents: function sceneNodeGetCustomWorldExtentsFn()
    {
        return this.customWorldExtents;
    },

    //
    //renderableWorldExtentsUpdated
    //
    renderableWorldExtentsUpdated: function sceneRenderableWorldExtentsUpdatedFn(wasAlreadyCustom)
    {
        if (!this.customWorldExtents)
        {
            this.dirtyWorldExtents = true;
            this.updateRequired();
        }

        if (!wasAlreadyCustom)
        {
            this.dirtyLocalExtents = true;
            this.numCustomRenderableWorldExtents = this.numCustomRenderableWorldExtents ? this.numCustomRenderableWorldExtents + 1 : 1;
        }
    },

    //
    //renderableWorldExtentsRemoved
    //
    renderableWorldExtentsRemoved: function sceneRenderableWorldExtentsRemovedFn()
    {
        if (!this.customWorldExtents)
        {
            this.dirtyWorldExtents = true;
            this.updateRequired();
        }
        this.dirtyLocalExtents = true;
        this.numCustomRenderableWorldExtents -= 1;
    },

    //
    //calculateHierarchyWorldExtents
    //
    calculateHierarchyWorldExtents: function sceneNodeCalculateHierarchyWorldExtentsFn()
    {
        var min = Math.min;
        var max = Math.max;
        var maxValue = Number.MAX_VALUE;
        var totalExtents = [];
        totalExtents[0] = maxValue;
        totalExtents[1] = maxValue;
        totalExtents[2] = maxValue;
        totalExtents[3] = -maxValue;
        totalExtents[4] = -maxValue;
        totalExtents[5] = -maxValue;

        function calculateNodeExtentsFn(sceneNode)
        {
            var worldExtents = sceneNode.getWorldExtents();
            if (worldExtents)
            {
                totalExtents[0] = min(totalExtents[0], worldExtents[0]);
                totalExtents[1] = min(totalExtents[1], worldExtents[1]);
                totalExtents[2] = min(totalExtents[2], worldExtents[2]);
                totalExtents[3] = max(totalExtents[3], worldExtents[3]);
                totalExtents[4] = max(totalExtents[4], worldExtents[4]);
                totalExtents[5] = max(totalExtents[5], worldExtents[5]);
            }

            var children = sceneNode.children;
            if (children)
            {
                var numChildren = children.length;
                for (var n = 0; n < numChildren; n += 1)
                {
                    calculateNodeExtentsFn(children[n]);
                }
            }
        }
        calculateNodeExtentsFn(this);

        if (totalExtents[0] === maxValue)
        {
            return undefined;
        }
        return totalExtents;
    },

    //
    //addRenderable
    //
    addRenderable: function sceneNodeAddRenderableFn(renderable)
    {
        this.dirtyWorldExtents = true;
        this.updateRequired();
        if (!this.renderables)
        {
            this.renderables = [];
        }
        this.renderables.push(renderable);
        renderable.setNode(this);
        this.dirtyLocalExtents = true;
    },

    //
    //addRenderableArray
    //
    addRenderableArray: function sceneNodeAddRenderableArrayFn(additionalRenderables)
    {
        this.dirtyWorldExtents = true;
        this.updateRequired();
        if (!this.renderables)
        {
            this.renderables = [];
        }
        var renderables = this.renderables;
        var length = additionalRenderables.length;
        for (var index = 0; index < length; index += 1)
        {
            renderables.push(additionalRenderables[index]);
            additionalRenderables[index].setNode(this);
        }
        this.dirtyLocalExtents = true;
    },

    //
    //removeRenderable
    //
    removeRenderable: function sceneNodeRemoveRenderableFn(renderable)
    {
        this.dirtyWorldExtents = true;
        this.updateRequired();
        var renderables = this.renderables;
        var numRenderables = renderables.length;
        for (var index = 0; index < numRenderables; index += 1)
        {
            if (renderables[index] === renderable)
            {
                renderables[index].setNode(null);
                renderables.splice(index, 1);
                this.dirtyLocalExtents = true;
                return;
            }
        }
        Utilities.assert(false, "Invalid renderable");
    },

    //
    //hasRenderables
    //
    hasRenderables: function sceneNodeHasRenderables()
    {
        return this.renderables && this.renderables.length;
    },

    //
    //addLightInstance
    //
    addLightInstance: function sceneNodeAddLightInstance(lightInstance)
    {
        this.dirtyWorldExtents = true;
        this.updateRequired();
        if (!this.lightInstances)
        {
            this.lightInstances = [];
        }
        this.lightInstances.push(lightInstance);
        lightInstance.setNode(this);
        this.dirtyLocalExtents = true;
    },

    //
    //addLightInstanceArray
    //
    addLightInstanceArray: function sceneNodeAddLightInstanceArray(additionalLightInstances)
    {
        this.dirtyWorldExtents = true;
        this.updateRequired();
        if (!this.lightInstances)
        {
            this.lightInstances = [];
        }

        var lightInstances = this.lightInstances;
        var length = additionalLightInstances.length;
        for (var index = 0; index < length; index += 1)
        {
            additionalLightInstances[index].setNode(this);
            lightInstances.push(additionalLightInstances[index]);
        }

        this.dirtyLocalExtents = true;
    },

    //
    //removeLightInstance
    //
    removeLightInstance: function sceneNodeRemoveLightInstance(lightInstance)
    {
        this.dirtyWorldExtents = true;
        this.updateRequired();
        var lightInstances = this.lightInstances;
        var numLights = lightInstances.length;
        for (var index = 0; index < numLights; index += 1)
        {
            if (lightInstances[index] === lightInstance)
            {
                lightInstance.setNode(null);
                lightInstances.splice(index, 1);
                this.dirtyLocalExtents = true;
                return;
            }
        }
        Utilities.assert(false, "Invalid light");
    },

    //
    //hasLightInstances
    //
    hasLightInstances: function sceneNodeHasLightInstances()
    {
        return this.lightInstances && this.lightInstances.length;
    },

    //
    //destroy
    //
    destroy: function sceneNodeDestroy()
    {
        //Should only be called when parent is null
        Utilities.assert(!this.parent, "SceneNode should be remove from parent before destroy is called");

        if (this.destroyedObserver)
        {
            this.destroyedObserver.notify({node: this});
        }

        var children = this.children;
        if (children)
        {
            var numChildren = children.length;
            for (var childIndex = numChildren - 1;  childIndex >= 0; childIndex -= 1)
            {
                var child = children[childIndex];
                this.removeChild(child);
                child.destroy();
            }
        }

        var renderables = this.renderables;
        if (renderables)
        {
            var numRenderables = renderables.length;
            for (var renderableIndex = numRenderables - 1; renderableIndex >= 0; renderableIndex -= 1)
            {
                var renderable = renderables[renderableIndex];
                if (renderable.destroy)
                {
                    renderable.destroy();
                }
            }
            this.renderables = [];
        }

        if (this.lightInstances)
        {
            this.lightInstances = [];
        }

        delete this.scene;
    },

    //
    //subscribeCloned
    //
    subscribeCloned: function sceneNodeSubscribeClonedFn(observerFunction)
    {
        if (!this.clonedObserver)
        {
            this.clonedObserver = Observer.create();
        }
        this.clonedObserver.subscribe(observerFunction);
    },

    //
    //unsubscribeCloned
    //
    unsubscribeCloned: function sceneNodeUnsubscribeClonedFn(observerFunction)
    {
        this.clonedObserver.unsubscribe(observerFunction);
    },

    //
    //subscribeDestroyed
    //
    subscribeDestroyed: function sceneNodeSubscribeDestroyedFn(observerFunction)
    {
        if (!this.destroyedObserver)
        {
            this.destroyedObserver = Observer.create();
        }
        this.destroyedObserver.subscribe(observerFunction);
    },

    //
    //unsubscribeDestroyed
    //
    unsubscribeDestroyed: function sceneNodeDestroyedFn(observerFunction)
    {
        this.destroyedObserver.unsubscribe(observerFunction);
    }
};

//
//SceneNode.create
//
SceneNode.create = function sceneNodeCreateFn(params)
{
    var sceneNode = new SceneNode();
    sceneNode.name = params.name;

    var md = TurbulenzEngine.getMathDevice();
    sceneNode.mathDevice = md;

    if (params.dynamic)
    {
        sceneNode.dynamic = params.dynamic;
    }
    if (params.disabled)
    {
        sceneNode.disabled = params.disabled;
    }

    sceneNode.dirtyWorldExtents = true;
    sceneNode.dirtyLocalExtents = true;
    sceneNode.worldUpdate = 0; //Counter of number of times modified.

    var local = params.local;
    if (local)
    {
        sceneNode.local = md.m43Copy(local);
    }
    else
    {
        sceneNode.local = md.m43BuildIdentity();
    }
    local = sceneNode.local;
    sceneNode.world = md.m43Copy(local);

    return sceneNode;
};

// Copyright (c) 2009-2012 Turbulenz Limited

/*global Observer: false*/
/*global TurbulenzEngine: false*/



/**
  @class  Shader manager
  @private

  @since TurbulenzEngine 0.1.0
*/
function ShaderManager() {}
ShaderManager.prototype =
{
    /**
      Version number
      @memberOf ShaderManager
      @constant
      @type number
    */
    version : 1
};

/**
  @constructs Constructs a ShaderManager object.

  @param {GraphicsDevice} gd Graphics device
  @param {RequestHandler} rh RequestHandler device
  @param {Shader} ds Default shader
  @param {Element} log Logging element

  @return {ShaderManager} object, null if failed
*/
ShaderManager.create = function shaderManagerCreateFn(gd, rh, ds, errorCallback, log)
{
    if (!errorCallback)
    {
        errorCallback = function (e) {};
    }

    var defaultShaderName = "default";

    var defaultShader;
    if (ds)
    {
        defaultShader = ds;
    }
    else
    {
        /*jslint white: false*/
        var shaderParams =
        {
            "version": 1,
            "name": "default.cgfx",
            "parameters":
            {
                "worldViewProjection":
                {
                    "type": "float",
                    "rows": 4,
                    "columns": 4
                },
                "diffuse":
                {
                    "type": "sampler2D"
                }
            },
            "techniques":
            {
                "textured3D":
                [
                    {
                        "parameters": ["worldViewProjection","diffuse"],
                        "semantics": ["POSITION","TEXCOORD0"],
                        "states":
                        {
                            "DepthTestEnable": true,
                            "DepthFunc": 515,
                            "DepthMask": true,
                            "CullFaceEnable": true,
                            "CullFace": 1029,
                            "BlendEnable": false
                        },
                        "programs": ["vp","fp"]
                    }
                ]
            },
            "programs":
            {
                "fp":
                {
                    "type": "fragment",
                    "code": "#ifdef GL_ES\nprecision mediump float;precision mediump int;\n#endif\nvarying vec4 tz_TexCoord[1];vec4 _ret_0;uniform sampler2D diffuse;void main()\n{_ret_0=texture2D(diffuse,tz_TexCoord[0].xy);gl_FragColor=_ret_0;}"
                },
                "vp":
                {
                    "type": "vertex",
                    "code": "#ifdef GL_ES\nprecision mediump float;precision mediump int;\n#endif\nvarying vec4 tz_TexCoord[1];attribute vec4 ATTR8;attribute vec4 ATTR0;\nvec4 _OUTpos1;vec2 _OUTuv1;uniform vec4 worldViewProjection[4];void main()\n{_OUTpos1=ATTR0.xxxx*worldViewProjection[0]+ATTR0.yyyy*worldViewProjection[1]+ATTR0.zzzz*worldViewProjection[2]+worldViewProjection[3];_OUTuv1=ATTR8.xy;tz_TexCoord[0].xy=ATTR8.xy;gl_Position=_OUTpos1;}"
                }
            }
        };
        /*jslint white: true*/

        defaultShader = gd.createShader(shaderParams);
        if (!defaultShader)
        {
            errorCallback("Default shader not created.");
        }
    }

    var shaders = {};
    var loadingShader = {};
    var loadedObservers = {};
    var numLoadingShaders = 0;
    var pathRemapping = null;
    var pathPrefix = "";

    shaders[defaultShaderName] = defaultShader;

    /**
      Creates shader from an cgfx file

      @memberOf ShaderManager.prototype
      @public
      @function
      @name load

      @param {string} path Path to the cgfx file

      @return {Shader} object, returns the default shader if the file at given path is not yet loaded
    */
    function loadShaderFn(path, onShaderLoaded)
    {
        if (path === undefined)
        {
            errorCallback("Invalid texture path passed to ShaderManager.Load");
        }
        var shader = shaders[path];
        if (!shader)
        {
            if (!loadingShader[path])
            {
                loadingShader[path] = true;
                numLoadingShaders += 1;

                var observer = Observer.create();
                loadedObservers[path] = observer;
                if (onShaderLoaded)
                {
                    observer.subscribe(onShaderLoaded);
                }

                var shaderLoaded = function shaderLoadedFn(shaderText, status, callContext)
                {
                    if (shaderText)
                    {
                        var shaderParameters = JSON.parse(shaderText);
                        var s = gd.createShader(shaderParameters);
                        if (s)
                        {
                            shaders[path] = s;
                        }
                        else
                        {
                            delete shaders[path];
                        }

                        observer.notify(s);
                        delete loadedObservers[path];
                    }
                    else
                    {
                        if (log)
                        {
                            log.innerHTML += "ShaderManager.load:&nbsp;'" + path + "' failed to load<br>";
                        }
                        delete shaders[path];
                    }
                    delete loadingShader[path];

                    numLoadingShaders -= 1;
                };

                rh.request({
                    src: ((pathRemapping && pathRemapping[path]) || (pathPrefix + path)),
                    onload: shaderLoaded
                });
            }
            else if (onShaderLoaded)
            {
                loadedObservers[path].subscribe(onShaderLoaded);
            }

            return defaultShader;
        }
        else if (onShaderLoaded)
        {
            // the callback should always be called asynchronously
            TurbulenzEngine.setTimeout(function shaderAlreadyLoadedFn()
                {
                    onShaderLoaded(shader);
                }, 0);
        }

        return shader;
    }

    /**
      Alias one shader to another name

      @memberOf ShaderManager.prototype
      @public
      @function
      @name map

      @param {string} dst Name of the alias
      @param {string} src Name of the shader to be aliased
    */
    function mapShaderFn(dst, src)
    {
        shaders[dst] = shaders[src];
    }

    /**
      Get shader created from a given shader file or with the given name

      @memberOf ShaderManager.prototype
      @public
      @function
      @name get

      @param {string} path Path or name of the shader

      @return {Shader} object, returns the default shader if the shader is not yet loaded or the shader file didn't exist
    */
    function getShaderFn(path)
    {
        var shader = shaders[path];
        if (!shader)
        {
            return defaultShader;
        }
        return shader;
    }

    /**
      Removes a shader from the manager

      @memberOf ShaderManager.prototype
      @public
      @function
      @name remove

      @param {string} path Path or name of the shader
    */
    function removeShaderFn(path)
    {
        if (typeof shaders[path] !== 'undefined')
        {
            delete shaders[path];
        }
    }

    /**
      Reloads a shader

      @memberOf ShaderManager.prototype
      @public
      @function
      @name reload

      @param {string} path Path or name of the shader
    */
    function reloadShaderFn(path, callback)
    {
        removeShaderFn(path);
        loadShaderFn(path, callback);
    }

    var sm = new ShaderManager();

    if (log)
    {
        sm.load = function loadShaderLogFn(path, callback)
        {
            log.innerHTML += "ShaderManager.load:&nbsp;'" + path + "'<br>";
            return loadShaderFn(path, callback);
        };

        sm.map = function mapShaderLogFn(dst, src)
        {
            log.innerHTML += "ShaderManager.map:&nbsp;'" + src + "' -> '" + dst + "'<br>";
            mapShaderFn(dst, src);
        };

        sm.get = function getShaderLogFn(path)
        {
            log.innerHTML += "ShaderManager.get:&nbsp;'" + path + "'<br>";
            return getShaderFn(path);
        };

        sm.remove = function removeShaderLogFn(path)
        {
            log.innerHTML += "ShaderManager.remove:&nbsp;'" + path + "'<br>";
            removeShaderFn(path);
        };

        sm.reload = function reloadShaderLogFn(path, callback)
        {
            log.innerHTML += "ShaderManager. reload:&nbsp;'" + path + "'<br>";
            reloadShaderFn(path, callback);
        };
    }
    else
    {
        sm.load = loadShaderFn;
        sm.map = mapShaderFn;
        sm.get = getShaderFn;
        sm.remove = removeShaderFn;
        sm.reload = reloadShaderFn;
    }

    /**
      Reloads all shaders

      @memberOf ShaderManager.prototype
      @public
      @function
      @name reloadAll
    */
    sm.reloadAll = function reloadAllShadersFn()
    {
        for (var t in shaders)
        {
            if (shaders.hasOwnProperty(t) && t !== defaultShaderName)
            {
                reloadShaderFn(t);
            }
        }
    };

    /**
      Get object containing all loaded shaders

      @memberOf ShaderManager.prototype
      @public
      @function
      @name getAll

      @return {object}
    */
    sm.getAll = function getAllShadersFn()
    {
        return shaders;
    };

    /**
      Get number of shaders pending

      @memberOf ShaderManager.prototype
      @public
      @function
      @name getNumLoadingShaders

      @return {number}
    */
    sm.getNumPendingShaders = function getNumPendingShadersFn()
    {
        return numLoadingShaders;
    };

    /**
      Check if a shader is not pending

      @memberOf ShaderManager.prototype
      @public
      @function
      @name isShaderLoaded

      @param {string} path Path or name of the shader

      @return {boolean}
    */
    sm.isShaderLoaded = function isShaderLoadedFn(path)
    {
        return !loadingShader[path];
    };

    /**
      Check if a shader is missing

      @memberOf ShaderManager.prototype
      @public
      @function
      @name isShaderMissing

      @param {string} path Path or name of the shader

      @return {boolean}
    */
    sm.isShaderMissing = function isShaderMissingFn(path)
    {
        return !shaders[path];
    };

    /**
      Set path remapping dictionary

      @memberOf ShaderManager.prototype
      @public
      @function
      @name setPathRemapping

      @param {string} prm Path remapping dictionary
      @param {string} assetUrl Asset prefix for all assets loaded
    */
    sm.setPathRemapping = function setPathRemappingFn(prm, assetUrl)
    {
        pathRemapping = prm;
        pathPrefix = assetUrl;
    };

    sm.destroy = function shaderManagerDestroyFn()
    {
        if (shaders)
        {
            var p;
            for (p in shaders)
            {
                if (shaders.hasOwnProperty(p))
                {
                    var shader = shaders[p];
                    if (shader)
                    {
                        shader.destroy();
                    }
                }
            }
            shaders = null;
        }

        defaultShader = null;
        loadingShader = null;
        loadedObservers = null;
        numLoadingShaders = 0;
        pathRemapping = null;
        pathPrefix = null;
        rh = null;
        gd = null;
    };

    return sm;
};

// Copyright (c) 2009-2012 Turbulenz Limited



/*global Reference: false*/
/*global Observer: false*/
/*global TurbulenzEngine: false*/

function TextureInstance() {}
TextureInstance.prototype =
{
    version : 1,

    //
    // setTexture
    //
    setTexture: function textureInstanceSetTexture(texture)
    {
        this.texture = texture;
        if (this.textureChangedObserver)
        {
            this.textureChangedObserver.notify(this);
        }
    },

    //
    // getTexture
    //
    getTexture: function textureInstanceGetTexture()
    {
        return this.texture;
    },

    //
    // subscribeTextureChanged
    //
    subscribeTextureChanged: function textureInstanceSubscribeTextureChanged(observerFunction)
    {
        if (!this.textureChangedObserver)
        {
            this.textureChangedObserver = Observer.create();
        }
        this.textureChangedObserver.subscribe(observerFunction);
    },

    //
    // usubscribeTextureChanged
    //
    unsubscribeTextureChanged: function textureInstanceunsubscribeTextureChangedFn(observerFunction)
    {
        this.textureChangedObserver.unsubscribe(observerFunction);
    },

    //
    // destroy
    //
    destroy: function textureInstanceDestroy()
    {
        delete this.texture;
        delete this.textureChangedObserver;
    }
};

//
// TextureInstance.create
//
TextureInstance.create = function textureInstanceCreate(name, texture)
{
    var textureInstance = new TextureInstance();
    textureInstance.name = name;
    textureInstance.texture = texture;
    textureInstance.reference = Reference.create(textureInstance);

    return textureInstance;
};


/**
  @class  Texture manager
  @private

  @since TurbulenzEngine 0.1.0
*/
function TextureManager() {}
TextureManager.prototype =
{
    /**
      Version number
      @memberOf TextureManager
      @constant
      @type number
    */
    version : 1
};

/**
  @constructs Constructs a TextureManager object.

  @param {GraphicsDevice} gd Graphics device
  @param {Texture} dt Default texture
  @param {Element} log Logging element

  @return {TextureManager} object, null if failed
*/
TextureManager.create = function textureManagerCreateFn(gd, rh, dt, errorCallback, log)
{
    var tm = new TextureManager();

    if (!errorCallback)
    {
        errorCallback = function (e) {};
    }

    var defaultTextureName = "default";

    var defaultTexture;
    if (dt)
    {
        defaultTexture = dt;
    }
    else
    {
        defaultTexture = gd.createTexture({
            name    : defaultTextureName,
            width   : 2,
            height  : 2,
            depth   : 1,
            format  : 'R8G8B8A8',
            cubemap : false,
            mipmaps : true,
            dynamic : false,
            data    : [255,  20, 147, 255,
                       255,   0,   0, 255,
                       255, 255, 255, 255,
                       255,  20, 147, 255]
        });
        if (!defaultTexture)
        {
            errorCallback("Default texture not created.");
        }
    }

    var textureInstances = {};
    var loadingTexture = {};
    var loadedTextureObservers = {};
    var delayedTextures = {};
    var numLoadingTextures = 0;
    var archivesLoaded = {};
    var loadingArchives = {};
    var loadedArchiveObservers = {};
    var numLoadingArchives = 0;
    var internalTexture = {};
    var pathRemapping = null;
    var pathPrefix = "";

    //
    // onTextureInstanceDestroyed callback
    //
    function onTextureInstanceDestroyed(textureInstance)
    {
        textureInstance.reference.unsubscribeDestroyed(onTextureInstanceDestroyed);
        delete textureInstances[textureInstance.name];
    }

    /**
      Adds external texture

      @memberOf TextureManager.prototype
      @public
      @function
      @name add

      @param {string} name Name of the texture
      @param {Texture} texture Texture
    */
    function addTextureFn(name, texture, internal)
    {
        var textureInstance = textureInstances[name];
        if (!textureInstance)
        {
            textureInstances[name] = TextureInstance.create(name, texture);
            textureInstances[name].reference.subscribeDestroyed(onTextureInstanceDestroyed);
        }
        else
        {
            textureInstance.setTexture(texture);
        }

        if (internal)
        {
            internalTexture[name] = true;
            textureInstances[name].reference.add();
        }
    }

    /**
      Get texture created from a given file or with the given name

      @memberOf TextureManager.prototype
      @public
      @function
      @name get

      @param {string} path Path or name of the texture

      @return {Texture} object, returns the default texture if the texture is not yet loaded or the file didn't exist
    */
    function getTextureFn(path)
    {
        var tex = textureInstances[path];
        if (!tex)
        {
            return defaultTexture;
        }
        return tex.getTexture();
    }

    //
    // getTextureInstanceFn
    //
    function getTextureInstanceFn(path)
    {
        return textureInstances[path];
    }

    /**
      Creates texture from an image file

      @memberOf TextureManager.prototype
      @public
      @function
      @name load

      @param {string} path Path to the image file
      @param {boolean} nomipmaps True to disable mipmaps
      @param {function} onTextureLoaded function to call once the texture is loaded

      @return {Texture} object, returns the default texture if the file at given path is not yet loaded
    */

    function loadTextureFn(path, nomipmaps, onTextureLoaded)
    {
        if (path === undefined)
        {
            errorCallback("Invalid texture path passed to TextureManager.Load");
        }
        var textureInstance = textureInstances[path];
        if (!textureInstance || textureInstance.texture === defaultTexture)
        {
            if (!textureInstance)
            {
                addTextureFn(path, defaultTexture, false);
            }

            if (!(path in loadingTexture))
            {
                if (0 === numLoadingArchives)
                {
                    loadingTexture[path] = true;
                    numLoadingTextures += 1;

                    var mipmaps = true;
                    if (nomipmaps)
                    {
                        mipmaps = false;
                    }

                    var loadedObserver = Observer.create();
                    loadedTextureObservers[path] = loadedObserver;
                    if (onTextureLoaded)
                    {
                        loadedObserver.subscribe(onTextureLoaded);
                    }

                    var textureLoaded = function textureLoadedFn(texture, status)
                    {
                        if (status === 200 && texture)
                        {
                            addTextureFn(path, texture, false);
                        }

                        loadedObserver.notify(texture);
                        delete loadedTextureObservers[path];

                        //Missing textures are left with the previous, usually default, texture.
                        delete loadingTexture[path];
                        numLoadingTextures -= 1;
                    };

                    var textureRequest = function textureRequestFn(url, onload, callContext)
                    {
                        var texture = gd.createTexture({
                            src     : url,
                            mipmaps : mipmaps,
                            onload  : onload
                        });
                        if (!texture)
                        {
                            errorCallback("Texture '" + url + "' not created.");
                        }
                    };

                    rh.request({
                        src: ((pathRemapping && pathRemapping[path]) || (pathPrefix + path)),
                        requestFn: textureRequest,
                        onload: textureLoaded
                    });
                }
                else
                {
                    delayedTextures[path] = {
                        nomipmaps: nomipmaps,
                        onload: onTextureLoaded
                    };

                    return getTextureFn(path);
                }
            }
            else if (onTextureLoaded)
            {
                loadedTextureObservers[path].subscribe(onTextureLoaded);
            }

            return getTextureFn(path);
        }
        else
        {
            textureInstance = getTextureFn(path);
            if (onTextureLoaded)
            {
                // the callback should always be called asynchronously
                TurbulenzEngine.setTimeout(function textureAlreadyLoadedFn()
                    {
                        onTextureLoaded(textureInstance);
                    }, 0);
            }
            return textureInstance;
        }
    }

    /**
      Alias one texture to another name

      @memberOf TextureManager.prototype
      @public
      @function
      @name map

      @param {string} dst Name of the alias
      @param {string} src Name of the texture to be aliased
    */
    function mapTextureFn(dst, src)
    {
        if (!textureInstances[dst])
        {
            textureInstances[dst] = TextureInstance.create(dst, textureInstances[src].getTexture());
            textureInstances[dst].reference.subscribeDestroyed(onTextureInstanceDestroyed);
        }
        else
        {
            textureInstances[dst].setTexture(textureInstances[src].getTexture());
        }
        internalTexture[dst] = true;
    }

    /**
      Removes a texture from the manager

      @memberOf TextureManager.prototype
      @public
      @function
      @name remove

      @param {string} path Path or name of the texture
    */
    function removeTextureFn(path)
    {
        if (!internalTexture[path])
        {
            if (path in textureInstances)
            {
                textureInstances[path].reference.unsubscribeDestroyed(onTextureInstanceDestroyed);
                delete textureInstances[path];
            }
        }
    }

    /**
      Loads a textures archive

      @memberOf TextureManager.prototype
      @public
      @function
      @name loadArchive

      @param {string} path Path to the archive file
      @param {boolean} nomipmaps True to disable mipmaps
    */
    function loadArchiveFn(path, nomipmaps, onTextureLoaded, onArchiveLoaded)
    {
        var archive = archivesLoaded[path];
        if (!archive)
        {
            if (!(path in loadingArchives))
            {
                var mipmaps = true;
                if (nomipmaps)
                {
                    mipmaps = false;
                }
                loadingArchives[path] = { textures: {} };
                numLoadingArchives += 1;

                var observer = Observer.create();
                loadedArchiveObservers[path] = observer;
                if (onArchiveLoaded)
                {
                    observer.subscribe(onArchiveLoaded);
                }

                var textureArchiveLoaded = function textureArchiveLoadedFn(success, status)
                {
                    var loadedArchive;
                    if (status === 200 && success)
                    {
                        loadedArchive = { textures: loadingArchives[path].textures };
                        archivesLoaded[path] = loadedArchive;
                    }

                    observer.notify(loadedArchive);
                    delete loadedArchiveObservers[path];

                    delete loadingArchives[path];
                    numLoadingArchives -= 1;
                    if (0 === numLoadingArchives)
                    {
                        for (var name in delayedTextures)
                        {
                            if (delayedTextures.hasOwnProperty(name))
                            {
                                var delayedTexture = delayedTextures[name];
                                loadTextureFn(name,
                                              delayedTexture.nomipmaps,
                                              delayedTexture.onload);
                            }
                        }
                        delayedTextures = {};
                    }
                };

                var requestTextureArchive = function requestTextureArchiveFn(url, onload)
                {
                    var ontextureload = function ontextureloadFn(texture)
                    {
                        var name = texture.name;
                        if (!(name in textureInstances) || textureInstances[name].texture === defaultTexture)
                        {
                            addTextureFn(name, texture, false);
                            loadingArchives[path].textures[name] = texture;
                        }

                        if (onTextureLoaded)
                        {
                            onTextureLoaded(texture);
                        }

                        delete delayedTextures[name];
                        if (path in loadingTexture)
                        {
                            delete loadingTexture[path];
                            numLoadingTextures -= 1;
                        }
                    };

                    if (!gd.loadTexturesArchive({
                        src: url,
                        mipmaps: mipmaps,
                        ontextureload: ontextureload,
                        onload: onload
                    }))
                    {
                        errorCallback("Archive '" + path + "' not loaded.");
                    }
                };

                rh.request({
                    src: ((pathRemapping && pathRemapping[path]) || (pathPrefix + path)),
                    requestFn: requestTextureArchive,
                    onload: textureArchiveLoaded
                });
            }
            else if (onTextureLoaded)
            {
                loadedArchiveObservers[path].subscribe(function textureArchiveLoadedFn()
                    {
                        var archive = archivesLoaded[path];
                        var texturesInArchive = archive.textures;
                        for (var t in texturesInArchive)
                        {
                            if (texturesInArchive.hasOwnProperty(t))
                            {
                                // the texture has already been loaded so we call onload manaually
                                onTextureLoaded(texturesInArchive[t]);
                            }
                        }
                        if (onArchiveLoaded)
                        {
                            onArchiveLoaded(archive);
                        }
                    });
            }
        }
        else
        {
            if (onTextureLoaded)
            {
                var texturesInArchive = archive.textures;
                var numTexturesLoading = 0;

                var textureAlreadyLoadedWrapper = function textureAlreadyLoadedWrapper(texture)
                {
                    return function textureAlreadyLoadedFn()
                    {
                        onTextureLoaded(texture);
                        numTexturesLoading -= 1;
                        if (numTexturesLoading === 0 && onArchiveLoaded)
                        {
                            onArchiveLoaded(archive);
                        }
                    };
                };

                for (var t in texturesInArchive)
                {
                    if (texturesInArchive.hasOwnProperty(t))
                    {
                        numTexturesLoading += 1;
                        // the callback should always be called asynchronously
                        TurbulenzEngine.setTimeout(textureAlreadyLoadedWrapper(texturesInArchive[t]), 0);
                    }
                }
            }
        }
    }

    /**
      Check if an archive is not pending

      @memberOf TextureManager.prototype
      @public
      @function
      @name isArchiveLoaded

      @param {string} path Path or name of the archive

      @return {boolean}
    */
    function isArchiveLoadedFn(path)
    {
        return path in archivesLoaded;
    }

    /**
      Removes a textures archive and all the textures it references.

      @memberOf TextureManager.prototype
      @public
      @function
      @name removeArchive

      @param {string} path Path of the archive file
    */
    function removeArchiveFn(path)
    {
        if (path in archivesLoaded)
        {
            var archiveTextures = archivesLoaded[path].textures;
            for (var texture in archiveTextures)
            {
                if (archiveTextures.hasOwnProperty(texture))
                {
                    removeTextureFn(texture);
                }
            }
            delete archivesLoaded[path];
        }
    }


    if (log)
    {
        tm.add = function addTextureLogFn(name, tex)
        {
            log.innerHTML += "TextureManager.add:&nbsp;'" + name + "'";
            return addTextureFn(name, tex);
        };

        tm.load = function loadTextureLogFn(path, nomipmaps)
        {
            log.innerHTML += "TextureManager.load:&nbsp;'" + path + "'";
            return loadTextureFn(path, nomipmaps);
        };

        tm.loadArchive = function loadArchiveLogFn(path, nomipmaps)
        {
            log.innerHTML += "TextureManager.loadArchive:&nbsp;'" + path + "'";
            return loadArchiveFn(path, nomipmaps);
        };

        tm.isArchiveLoaded = function isArchiveLoadedLogFn(path)
        {
            log.innerHTML += "TextureManager.isArchiveLoaded:&nbsp;'" + path + "'";
            return isArchiveLoadedFn(path);
        };

        tm.removeArchive = function removeArchiveLogFn(path)
        {
            log.innerHTML += "TextureManager.removeArchive:&nbsp;'" + path + "'";
            return removeArchiveFn(path);
        };

        tm.map = function mapTextureLogFn(dst, src)
        {
            log.innerHTML += "TextureManager.map:&nbsp;'" + src + "' -> '" + dst + "'";
            mapTextureFn(dst, src);
        };

        tm.get = function getTextureLogFn(path)
        {
            log.innerHTML += "TextureManager.get:&nbsp;'" + path + "'";
            return getTextureFn(path);
        };

        tm.getInstance = function getTextureInstanceLogFn(path)
        {
            log.innerHTML += "TextureManager.getInstance:&nbsp;'" + path + "'";
            return getTextureInstanceFn(path);
        };

        tm.remove = function removeTextureLogFn(path)
        {
            log.innerHTML += "TextureManager.remove:&nbsp;'" + path + "'";
            removeTextureFn(path);
        };
    }
    else
    {
        tm.add = addTextureFn;
        tm.load = loadTextureFn;
        tm.loadArchive = loadArchiveFn;
        tm.isArchiveLoaded = isArchiveLoadedFn;
        tm.removeArchive = removeArchiveFn;
        tm.map = mapTextureFn;
        tm.get = getTextureFn;
        tm.getInstance = getTextureInstanceFn;
        tm.remove = removeTextureFn;
    }

    /**
      Get object containing all loaded textures

      @memberOf TextureManager.prototype
      @public
      @function
      @name getAll

      @return {object}
    */
    tm.getAll = function getAllTexturesFn()
    {
        return textureInstances;
    };

    /**
      Get number of textures pending

      @memberOf TextureManager.prototype
      @public
      @function
      @name getNumLoadingTextures

      @return {number}
    */
    tm.getNumPendingTextures = function getNumPendingTexturesFn()
    {
        return (numLoadingTextures + numLoadingArchives);
    };

    /**
      Check if a texture is not pending

      @memberOf TextureManager.prototype
      @public
      @function
      @name isTextureLoaded

      @param {string} path Path or name of the texture

      @return {boolean}
    */
    tm.isTextureLoaded = function isTextureLoadedFn(path)
    {
        return (!(path in loadingTexture) && !(path in delayedTextures));
    };

    /**
      Check if a texture is missing

      @memberOf TextureManager.prototype
      @public
      @function
      @name isTextureMissing

      @param {string} path Path or name of the texture

      @return {boolean}
    */
    tm.isTextureMissing = function isTextureMissingFn(path)
    {
        return !(path in textureInstances);
    };

    /**
      Set path remapping dictionary

      @memberOf TextureManager.prototype
      @public
      @function
      @name setPathRemapping

      @param {string} prm Path remapping dictionary
      @param {string} assetUrl Asset prefix for all assets loaded
    */
    tm.setPathRemapping = function setPathRemappingFn(prm, assetUrl)
    {
        pathRemapping = prm;
        pathPrefix = assetUrl;
    };

    // Add procedural textures
    addTextureFn(defaultTextureName, defaultTexture, true);

    function addProceduralTexture(params)
    {
        var name = params.name;
        var procTexture = gd.createTexture(params);
        if (!procTexture)
        {
            errorCallback("Failed to create '" + name + "' texture.");
        }
        else
        {
            addTextureFn(name, procTexture, true);
        }
    }

    addProceduralTexture({
        name    : "white",
        width   : 2,
        height  : 2,
        depth   : 1,
        format  : 'R8G8B8A8',
        cubemap : false,
        mipmaps : true,
        dynamic : false,
        data    : [255, 255, 255, 255,
                   255, 255, 255, 255,
                   255, 255, 255, 255,
                   255, 255, 255, 255]
    });

    addProceduralTexture({
        name    : "black",
        width   : 2,
        height  : 2,
        depth   : 1,
        format  : 'R8G8B8A8',
        cubemap : false,
        mipmaps : true,
        dynamic : false,
        data    : [0, 0, 0, 255,
                   0, 0, 0, 255,
                   0, 0, 0, 255,
                   0, 0, 0, 255]
    });

    addProceduralTexture({
        name    : "flat",
        width   : 2,
        height  : 2,
        depth   : 1,
        format  : 'R8G8B8A8',
        cubemap : false,
        mipmaps : true,
        dynamic : false,
        data    : [128, 128, 255, 255,
                   128, 128, 255, 255,
                   128, 128, 255, 255,
                   128, 128, 255, 255]
    });

    var abs = Math.abs;
    var x, y;
    var quadraticData = [];
    for (y = 0; y < 4; y += 1)
    {
        for (x = 0; x < 32; x += 1)
        {
            var s = ((x + 0.5) * (2.0 / 32.0) - 1.0);
            s = abs(s) - (1.0 / 32.0);
            var value = (1.0 - (s * 2.0) + (s * s));
            if (value <= 0)
            {
                quadraticData.push(0);
            }
            else if (value >= 1)
            {
                quadraticData.push(255);
            }
            else
            {
                quadraticData.push(value * 255);
            }
        }
    }
    addProceduralTexture({
        name    : "quadratic",
        width   : 32,
        height  : 4,
        depth   : 1,
        format  : 'L8',
        cubemap : false,
        mipmaps : true,
        dynamic : false,
        data    : quadraticData
    });
    quadraticData = null;

    var nofalloffData = [];
    for (y = 0; y < 4; y += 1)
    {
        nofalloffData.push(0);
        for (x = 1; x < 31; x += 1)
        {
            nofalloffData.push(255);
        }
        nofalloffData.push(0);
    }
    addProceduralTexture({
        name    : "nofalloff",
        width   : 32,
        height  : 4,
        depth   : 1,
        format  : 'L8',
        cubemap : false,
        mipmaps : true,
        dynamic : false,
        data    : nofalloffData
    });
    nofalloffData = null;

    tm.destroy = function textureManagerDestroyFn()
    {
        if (textureInstances)
        {
            var p;
            for (p in textureInstances)
            {
                if (textureInstances.hasOwnProperty(p))
                {
                    var textureInstance = textureInstances[p];
                    if (textureInstance)
                    {
                        var texture = textureInstance.getTexture();
                        if (texture)
                        {
                            texture.destroy();
                        }

                        textureInstance.destroy();
                    }
                }
            }
            textureInstances = null;
        }

        if (defaultTexture)
        {
            defaultTexture.destroy();
            defaultTexture = null;
        }

        loadingTexture = null;
        loadedTextureObservers = null;
        delayedTextures = null;
        numLoadingTextures = 0;
        archivesLoaded = null;
        loadingArchives = null;
        loadedArchiveObservers = null;
        numLoadingArchives = 0;
        internalTexture = null;
        pathRemapping = null;
        pathPrefix = null;
        rh = null;
        gd = null;
    };

    return tm;
};

// Copyright (c) 2010-2011 Turbulenz Limited

/*global window: false*/
/*global Observer: false*/
/*global TurbulenzEngine: false*/

var Utilities = {};

//
// assert
//
Utilities.skipAsserts = false;
Utilities.assert = function assertFn(test, message)
{
    if (!test)
    {
        if (!this.skipAsserts)
        {
            this.breakInDebugger.doesNotExist(); //Use a function that does not exist. This is caught in the debuggers.
        }
    }
};

//
// beget
//
Utilities.beget = function begetFn(o)
{
    var F = function () { };
    F.prototype = o;
    return new F();
};

//
// log
//
Utilities.log = function logFn()
{
    var console = window.console;
    if (console)
    {
        // "console.log.apply" will crash when using the plugin on Chrome...
        switch (arguments.length)
        {
        case 1:
            console.log(arguments[0]);
            break;
        case 2:
            console.log(arguments[0], arguments[1]);
            break;
        case 3:
            console.log(arguments[0], arguments[1], arguments[2]);
            break;
        case 4:
            console.log(arguments[0], arguments[1], arguments[2], arguments[3]);
            break;
        default:
            // Note: this will fail if using printf-style string formatting
            var args = [].splice.call(arguments, 0);
            console.log(args.join(' '));
            break;
        }
    }
};

var MathDeviceConvert =
{
    v3ToArray : function v3ToJavaScriptArrayFn(v3)
    {
        return [v3[0], v3[1], v3[2]];
    },

    arrayToV3 : function arrayToV3Fn(mathDevice, v3Array, v3Dest)
    {
        return mathDevice.v3Build(v3Array[0], v3Array[1], v3Array[2], v3Dest);
    },

    v4ToArray : function v4ToJavaScriptArrayFn(v4)
    {
        return [v4[0], v4[1], v4[2], v4[3]];
    },

    arrayToV4 : function arrayToV4Fn(mathDevice, v4Array, v4Dest)
    {
        return mathDevice.v4Build(v4Array[0], v4Array[1], v4Array[2], v4Array[3], v4Dest);
    },

    quatToArray : function quatToJavaScriptArrayFn(quat)
    {
        return [quat[0], quat[1], quat[2], quat[3]];
    },

    arrayToQuat : function arrayToQuatFn(mathDevice, quatArray, quatDest)
    {
        return mathDevice.quatBuild(quatArray[0], quatArray[1], quatArray[2], quatArray[3], quatDest);
    },

    aabbToArray : function aabbToJavaScriptArrayFn(aabb)
    {
        return [aabb[0], aabb[1], aabb[2],
                aabb[3], aabb[4], aabb[5]];
    },

    arrayToAABB : function arrayToQuatFn(mathDevice, aabbArray, aabbDest)
    {
        return mathDevice.aabbBuild(aabbArray[0], aabbArray[1], aabbArray[2],
                                    aabbArray[3], aabbArray[4], aabbArray[5], aabbDest);
    },

    quatPosToArray : function quatPosToJavaScriptArrayFn(quatPos)
    {
        return [quatPos[0], quatPos[1], quatPos[2], quatPos[3],
                quatPos[4], quatPos[5], quatPos[6]];
    },

    arrayToQuatPos : function arrayToQuatPosFn(mathDevice, quatPosArray, quatPosDest)
    {
        return mathDevice.quatPosBuild(quatPosArray[0], quatPosArray[1], quatPosArray[2], quatPosArray[3],
                                       quatPosArray[4], quatPosArray[5], quatPosArray[6], quatPosDest);
    },

    m33ToArray : function m33ToJavaScriptArrayFn(m33)
    {
        return [m33[0], m33[1], m33[2],
                m33[3], m33[4], m33[5],
                m33[6], m33[7], m33[8]];
    },

    arrayToM33 : function arrayToM33Fn(mathDevice, m33Array, m33Dest)
    {
        return mathDevice.m33Build(m33Array[0], m33Array[1], m33Array[2],
                                   m33Array[3], m33Array[4], m33Array[5],
                                   m33Array[6], m33Array[7], m33Array[8], m33Dest);
    },

    /*jslint white: false*/
    m43ToArray : function m43ToJavaScriptArrayFn(m43)
    {
        return [m43[0], m43[ 1], m43[ 2],
                m43[3], m43[ 4], m43[ 5],
                m43[6], m43[ 7], m43[ 8],
                m43[9], m43[10], m43[11]];
    },

    arrayToM43 : function arrayToM43Fn(mathDevice, m43Array, m43Dest)
    {
        return mathDevice.m43Build(m43Array[0], m43Array[ 1], m43Array[ 2],
                                   m43Array[3], m43Array[ 4], m43Array[ 5],
                                   m43Array[6], m43Array[ 7], m43Array[ 8],
                                   m43Array[9], m43Array[10], m43Array[11], m43Dest);
    },

    m34ToArray : function m34ToJavaScriptArrayFn(m34)
    {
        return [m34[0], m34[1], m34[ 2], m34[ 3],
                m34[4], m34[5], m34[ 6], m34[ 7],
                m34[8], m34[9], m34[10], m34[11]];
    },

    m44ToArray : function m44ToJavaScriptArrayFn(m44)
    {
        return [m44[ 0], m44[ 1], m44[ 2], m44[ 3],
                m44[ 4], m44[ 5], m44[ 6], m44[ 7],
                m44[ 8], m44[ 9], m44[10], m44[11],
                m44[12], m44[13], m44[14], m44[15]];
    },

    arrayToM44 : function arrayToM44Fn(mathDevice, m44Array, m44Dest)
    {
        return mathDevice.m44Build(m44Array[ 0], m44Array[ 1], m44Array[ 2], m44Array[ 3],
                                   m44Array[ 4], m44Array[ 5], m44Array[ 6], m44Array[ 7],
                                   m44Array[ 8], m44Array[ 9], m44Array[10], m44Array[11],
                                   m44Array[12], m44Array[13], m44Array[14], m44Array[15], m44Dest);
    }
    /*jslint white: true*/
};

//
// ajax
//
Utilities.ajax = function utilitiesAjaxFn(params)
{
    // parameters
    var requestText = "";
    var method = params.method;
    var data = params.data || {};
    var encrypted = params.encrypt;
    var signature = null;
    var async = params.async || true;
    var url = params.url;
    var requestHandler = params.requestHandler;
    var callbackFn = params.callback;

    if (encrypted)
    {
        data.requestUrl = url;

        var str = JSON.stringify(data);

        if (method === "POST")
        {
            str = TurbulenzEngine.encrypt(str);
        }

        requestText += "data=" + encodeURIComponent(str) + "&";

        requestText += "gameSessionId=" + encodeURIComponent(data.gameSessionId);

        signature = TurbulenzEngine.generateSignature(str);
    }
    else if (data)
    {
        for (var key in data)
        {
            if (data.hasOwnProperty(key))
            {
                if (requestText.length !== 0)
                {
                    requestText += "&";
                }
                if (method === "POST")
                {
                    requestText += key + "=" + data[key];
                }
                else
                {
                    requestText += encodeURIComponent(key) + "=" + encodeURIComponent(data[key]);
                }
            }
        }
    }

    var httpResponseCallback = function httpResponseCallbackFn(xhrResponseText, xhrStatus)
    {
        var sig = this.xhr.getResponseHeader("X-TZ-Signature");

        // break circular reference
        this.xhr.onreadystatechange = null;
        this.xhr = null;

        var response;

        if (encrypted)
        {
            response = JSON.parse(xhrResponseText);
            var validSignature = TurbulenzEngine.verifySignature(xhrResponseText, sig);
            xhrResponseText = null;

            TurbulenzEngine.setTimeout(function () {
                var receivedUrl = response.requestUrl;

                if (validSignature)
                {
                    if (!TurbulenzEngine.encryptionEnabled || receivedUrl === url)
                    {
                        callbackFn(response, xhrStatus);
                        callbackFn = null;
                        return;
                    }
                }

                // If it was a server-side verification fail then pass through the actual message
                if (xhrStatus === 400)
                {
                    callbackFn(response, xhrStatus, "Verification Failed");
                }
                else
                {
                    // Else drop reply
                    callbackFn({msg: "Verification failed", ok: false}, 400, "Verification Failed");
                }
                callbackFn = null;
            }, 0);
        }
        else
        {
            response = JSON.parse(xhrResponseText);
            xhrResponseText = null;

            TurbulenzEngine.setTimeout(function () {
                callbackFn(response, xhrStatus);
                callbackFn = null;
            }, 0);
        }
    };

    var httpRequest = function httpRequestFn(url, onload, callContext)
    {
        var xhr;
        if (window.XMLHttpRequest)
        {
            xhr = new window.XMLHttpRequest();
        }
        else if (window.ActiveXObject)
        {
            xhr = new window.ActiveXObject("Microsoft.XMLHTTP");
        }
        else
        {
            if (params.error)
            {
                params.error("No XMLHTTPRequest object could be created");
            }
            return;
        }
        callContext.xhr = xhr;

        var httpCallback = function httpCallbackFn()
        {
            if (xhr.readyState === 4 && !TurbulenzEngine.isUnloading()) /* 4 == complete */
            {
                var xhrResponseText = xhr.responseText;
                var xhrStatus = xhr.status;
                // Checking xhrStatusText when xhrStatus is 0 causes a silent error!
                var xhrStatusText = (xhrStatus !== 0 && xhr.statusText) || "No connection or cross domain request";

                // Sometimes the browser sets status to 200 OK when the connection is closed
                // before the message is sent (weird!).
                // In order to address this we fail any completely empty responses.
                // Hopefully, nobody will get a valid response with no headers and no body!
                if (xhr.getAllResponseHeaders() === "" && xhrResponseText === "" && xhrStatus === 200 && xhrStatusText === 'OK')
                {
                    onload('', 0);
                    return;
                }

                onload.call(callContext, xhrResponseText, xhrStatus);
            }
        };

        // Send request
        xhr.open(method, ((requestText && (method !== "POST")) ? url + "?" + requestText : url), async);
        if (callbackFn)
        {
            xhr.onreadystatechange = httpCallback;
        }

        if (signature)
        {
            xhr.setRequestHeader("X-TZ-Signature", signature);
        }

        if (method === "POST")
        {
            xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
            xhr.send(requestText);
        }
        else // method === 'GET'
        {
            xhr.send();
        }
    };

    if (requestHandler)
    {
        requestHandler.request({
            src: url,
            requestFn: httpRequest,
            customErrorHandler: params.customErrorHandler,
            onload: httpResponseCallback
        });
    }
    else
    {
        var callContext = {
            src: url
        };
        httpRequest(url, httpResponseCallback, callContext);
    }
};


//
// ajaxStatusCodes
//

// http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1
Utilities.ajaxStatusCodes = {
    0: "No Connection, Timeout Or Cross Domain Request",
    100: "Continue",
    101: "Switching Protocols",
    200: "OK",
    201: "Created",
    202: "Accepted",
    203: "Non-Authoritative Information",
    204: "No Content",
    205: "Reset Content",
    206: "Partial Content",
    300: "Multiple Choices",
    301: "Moved Permanently",
    302: "Found",
    303: "See Other",
    304: "Not Modified",
    305: "Use Proxy",
    307: "Temporary Redirect",
    400: "Bad Request",
    401: "Unauthorized",
    402: "Payment Required",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    406: "Not Acceptable",
    407: "Proxy Authentication Required",
    408: "Request Time-out",
    409: "Conflict",
    410: "Gone",
    411: "Length Required",
    412: "Precondition Failed",
    413: "Request Entity Too Large",
    414: "Request-URI Too Large",
    415: "Unsupported Media Type",
    416: "Requested range not satisfiable",
    417: "Expectation Failed",
    480: "Temporarily Unavailable",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable",
    504: "Gateway Time-out",
    505: "HTTP Version not supported"
};

//
//Reference
//

// Proxy reference class allowing weak reference to the object
function Reference() {}

Reference.prototype =
{
    version: 1,

    //
    // add
    //
    add: function referenceAddFn()
    {
        this.referenceCount += 1;
    },

    //
    // remove
    //
    remove: function referenceRemovefn()
    {
        this.referenceCount -= 1;
        if (this.referenceCount === 0)
        {
            if (this.destroyedObserver)
            {
                this.destroyedObserver.notify(this.object);
            }
            this.object.destroy();
            this.object = null;
        }
    },

    //
    //subscribeDestroyed
    //
    subscribeDestroyed: function referenceSubscribeDestroyedFn(observerFunction)
    {
        if (!this.destroyedObserver)
        {
            this.destroyedObserver = Observer.create();
        }
        this.destroyedObserver.subscribe(observerFunction);
    },

    //
    //unsubscribeDestroyed
    //
    unsubscribeDestroyed: function referenceDestroyedFn(observerFunction)
    {
        this.destroyedObserver.unsubscribe(observerFunction);
    }
};

//
// create
//
Reference.create = function referenceCreate(object)
{
    var result = new Reference();
    result.object = object;
    result.referenceCount = 0;
    return result;
};


//
// Profile
//
var Profile =
{
    profiles: [],

    sortMode: {alphabetical: 0, duration: 1, max: 2, min: 3, calls: 4},

    //
    // start
    //
    start: function profileStartFn(name)
    {
        var data = this.profiles[name];
        if (!data)
        {
            data = {name: name, calls: 0, duration: 0.0, min: Number.MAX_VALUE, max: 0.0, sumOfSquares: 0.0};
            this.profiles[name] = data;
        }
        data.start = TurbulenzEngine.time;
    },

    //
    // stop
    //
    stop: function profileStopFn(name)
    {
        var end = TurbulenzEngine.time;
        var data = this.profiles[name];
        if (data)
        {
            var duration = end - data.start;
            data.duration += duration;
            data.calls += 1;
            var delta = duration - data.duration / data.calls; // This is an approximation, it should use the mean of all samples (or N random ones) but thats requries samples to be stored
            data.sumOfSquares += delta * delta;

            if (duration > data.max)
            {
                data.max = duration;
            }

            if (duration < data.min)
            {
                data.min = duration;
            }
        }
    },

    //
    // reset
    //
    reset: function profileResetFn()
    {
        this.profiles = [];
    },

    //
    // getReport
    //
    getReport: function profileGetReportFn(sortMode, format)
    {
        var dataArray = [];
        var data;
        var maxDuration = 0.0;
        for (var name in this.profiles)
        {
            if (this.profiles.hasOwnProperty(name))
            {
                data = this.profiles[name];
                if (maxDuration < data.duration)
                {
                    maxDuration = data.duration;
                }
                dataArray.push(data);
            }
        }

        var compareFunction;

        if (sortMode === Profile.sortMode.alphabetical)
        {
            compareFunction = function compareName(left, right)
                            {
                                return (left.name < right.name) ? -1 : (left.name > right.name) ? 1 : 0;
                            };
        }
        else if (sortMode === Profile.sortMode.max)
        {
            compareFunction = function compareMax(left, right)
                            {
                                return right.max - left.max;
                            };
        }
        else if (sortMode === Profile.sortMode.min)
        {
            compareFunction = function compareMin(left, right)
                            {
                                return right.min - left.min;
                            };
        }
        else if (sortMode === Profile.sortMode.calls)
        {
            compareFunction = function compareCalls(left, right)
                            {
                                return right.calls - left.calls;
                            };
        }
        else // Profile.sortMode.duration or undefined
        {
            compareFunction = function compareDuration(left, right)
                            {
                                return right.duration - left.duration;
                            };
        }

        dataArray.sort(compareFunction);

        var line;
        var text = "";
        var precision = format ? format.precision : 8;
        var percentagePrecision = format ? format.percentagePrecision : 1;
        var seperator = format ? format.seperator : " ";
        var length = dataArray.length;
        for (var index = 0; index < length; index += 1)
        {
            data = dataArray[index];
            line = data.name;
            line += seperator + data.calls;
            line += seperator + data.duration.toFixed(precision);
            line += seperator + data.max.toFixed(precision);
            line += seperator + data.min.toFixed(precision);
            line += seperator + (data.duration / data.calls).toFixed(precision); // average
            line += seperator + Math.sqrt(data.sumOfSquares / data.calls).toFixed(precision); // approximate standard deviation
            line += seperator + (100 * data.duration / maxDuration).toFixed(percentagePrecision) + "%\n";
            text += line;
        }
        return text;
    }
};

//
// Utilities to use with TurbulenzEngine.stopProfiling() object.
//
var JSProfiling = {};

//
// createArray
//      Creates an array of nodes by merging all duplicate function references in the call profile tree together.
JSProfiling.createArray = function JSProfilingCreateArrayFn(rootNode)
{
    var map = {};
    var array = [];

    if (rootNode.head)
    {
        rootNode = rootNode.head; // Chrome native profiler.
    }

    var processNode = function processNodeFn(node)
    {
        var urlObject = map[node.url];
        if (!urlObject)
        {
            urlObject = {};
            map[node.url] = urlObject;
        }

        var functionName = node.functionName === "" ? "(anonymous)" : node.functionName;

        var functionObject = urlObject[functionName];
        if (!functionObject)
        {
            functionObject = {};
            urlObject[functionName] = functionObject;
        }

        var existingNode = functionObject[node.lineNumber];
        if (!existingNode)
        {
            var newNode = { functionName : functionName,
                            numberOfCalls : node.numberOfCalls,
                            totalTime : node.totalTime,
                            selfTime : node.selfTime,
                            url : node.url,
                            lineNumber : node.lineNumber
                           };

            array[array.length] = newNode;
            functionObject[node.lineNumber] = newNode;
        }
        else
        {
            existingNode.totalTime += node.totalTime;
            existingNode.selfTime += node.selfTime;
            existingNode.numberOfCalls += node.numberOfCalls;
        }

        var children = node.children;
        if (children)
        {
            var numberOfChildren = children.length;
            for (var childIndex = 0; childIndex < numberOfChildren; childIndex += 1)
            {
                processNode(children[childIndex]);
            }
        }
    };

    processNode(rootNode);

    return array;
};

//
// sort
//
JSProfiling.sort = function JSProfilingSortFn(array, propertyName, descending)
{
    if (!propertyName)
    {
        propertyName = "totalTime";
    }

    var sorterAscending = function (left, right)
    {
        return left[propertyName] - right[propertyName];
    };

    var sorterDescending = function (left, right)
    {
        return right[propertyName] - left[propertyName];
    };

    if (descending === false)
    {
        array.sort(sorterAscending);
    }
    else
    {
        array.sort(sorterDescending);
    }
};

// Copyright (c) 2011-2012 Turbulenz Limited

/*global TurbulenzEngine*/
/*global Observer*/

function RequestHandler() {}
RequestHandler.prototype =
{
    reasonConnectionLost: 0,
    reasonServiceBusy: 1,

    retryExponential: function requestHandlerExponentialRetryFn(callContext, requestFn, status)
    {
        if (!this.notifiedConnectionLost &&
            TurbulenzEngine.time - this.connectionLostTime > (this.notifyTime * 0.001))
        {
            this.notifiedConnectionLost = true;

            var reason;
            if (status === 0)
            {
                reason = this.reasonConnectionLost;
            }
            else
            {
                reason = this.reasonServiceBusy;
            }
            callContext.reason = reason;
            this.onRequestTimeout(reason, callContext);
        }

        // only the first request with a lost connection continues
        // all following requests wait for a reconnection
        if (this.connected)
        {
            this.connectionLostTime = TurbulenzEngine.time;
            this.notifiedConnectionLost = false;
            this.connected = false;
            this.reconnectTest = callContext;

            callContext.status = status;
        }
        else if (this.reconnectTest !== callContext)
        {
            var reconnectedObserver = this.reconnectedObserver;
            reconnectedObserver.subscribe(function onReconnected()
                {
                    reconnectedObserver.unsubscribe(onReconnected);
                    requestFn();
                });
            return;
        }

        if (callContext.expTime)
        {
            callContext.expTime = 2 * callContext.expTime;
            if (callContext.expTime > this.maxRetryTime)
            {
                callContext.expTime = this.maxRetryTime;
            }
        }
        else
        {
            callContext.expTime = this.initialRetryTime;
        }

        if (callContext.retries)
        {
            callContext.retries += 1;
        }
        else
        {
            callContext.retries = 1;
        }
        TurbulenzEngine.setTimeout(requestFn, callContext.expTime);
    },

    retryAfter: function requestHandlerRetryAfterFn(callContext, retryAfter, requestFn, status)
    {
        if (callContext.retries)
        {
            callContext.retries += 1;
        }
        else
        {
            callContext.firstRetry = TurbulenzEngine.time;
            callContext.retries = 1;
        }

        if (!callContext.notifiedMaxRetries &&
            TurbulenzEngine.time - callContext.firstRetry + retryAfter > this.notifyTime)
        {
            callContext.notifiedMaxRetries = true;

            var reason = this.reasonServiceBusy;
            callContext.reason = reason;
            this.onRequestTimeout(reason, callContext);
        }

        TurbulenzEngine.setTimeout(requestFn, retryAfter * 1000);
    },

    request: function requestHandlerRequestFn(callContext)
    {
        var makeRequest;
        var that = this;

        var responseCallback = function responseCallbackFn(responseAsset, status)
        {
            var xhr = callContext.xhr;
            if (xhr)
            {
                var retryAfterHeader = xhr.getResponseHeader("Retry-After");
                if (retryAfterHeader)
                {
                    var retryAfter = parseInt(retryAfterHeader, 10);
                    if (retryAfter > 0)
                    {
                        that.retryAfter(callContext, retryAfter, makeRequest, status);
                        return;
                    }
                }
            }

            // 0 Connection Lost
            // 408 Request Timeout
            // 480 Temporarily Unavailable
            if (status === 0 || status === 408 || status === 480)
            {
                that.retryExponential(callContext, makeRequest, status);
                return;
            }

            if (!that.connected)
            {
                // Reconnected!
                that.connected = true;
                if (that.reconnectTest === callContext && that.notifiedConnectionLost)
                {
                    that.onReconnected(that.reconnectTest.reason, that.reconnectTest);
                }
                that.reconnectTest = null;
                that.reconnectedObserver.notify();
            }

            if (callContext.customErrorHandler &&
                !callContext.customErrorHandler.call(this, callContext, makeRequest, responseAsset, status))
            {
                return;
            }

            if (that.customErrorHandler &&
                !that.customErrorHandler(callContext, makeRequest, responseAsset, status))
            {
                return;
            }

            if (callContext.onload)
            {
                callContext.onload(responseAsset, status, callContext);
                callContext.onload = null;
            }
            callContext = null;
        };

        makeRequest = function makeRequestFn()
        {
            if (callContext.requestFn)
            {
                if (callContext.requestOwner)
                {
                    callContext.requestFn.call(callContext.requestOwner, callContext.src, responseCallback, callContext);
                }
                else
                {
                    callContext.requestFn(callContext.src, responseCallback, callContext);
                }
            }
            else if (callContext.requestOwner)
            {
                callContext.requestOwner.request(callContext.src, responseCallback, callContext);
            }
            else
            {
                TurbulenzEngine.request(callContext.src, responseCallback, callContext);
            }
        };

        makeRequest();
    }
};

RequestHandler.create = function requestHandlerCreateFn(params)
{
    var rh = new RequestHandler();

    rh.initialRetryTime = params.initialRetryTime || 0.5 * 1000;
    rh.notifyTime = params.notifyTime || 4 * 1000;
    rh.maxRetryTime = params.maxRetryTime || 8 * 1000;

    rh.notifiedConnectionLost = false;
    rh.connected = true;
    rh.reconnectedObserver = Observer.create();
    rh.reconnectTest = null;

    rh.onReconnected = params.onReconnected || function onReconnectedFn() {};
    rh.onRequestTimeout = params.onRequestTimeout || function onRequestTimeoutFn(callContext) {};

    return rh;
};

// Copyright (c) 2010-2012 Turbulenz Limited

/*global Utilities: false*/

//
// VertexBufferManager
//

function VertexBufferManager() {}

VertexBufferManager.prototype =
{
    version: 1,

    maxVerticesPerVertexBuffer: 65535,

    numBuckets: 10,

    //
    // bucket
    //
    bucket: function bucketFn(numVertices)
    {
        if (numVertices <= 64)
        {
            if (numVertices <= 16)
            {
                if (numVertices <= 8)
                {
                    return 0;
                }
                return 1;
            }

            if (numVertices <= 32)
            {
                return 2;
            }
            return 3;
        }

        if (numVertices <= 512)
        {
            if (numVertices <= 256)
            {
                if (numVertices <= 128)
                {
                    return 4;
                }
                return 5;
            }
            return 6;
        }

        if (numVertices <= 2048)
        {
            if (numVertices <= 1024)
            {
                return 7;
            }
            return 8;
        }
        return 9;
    },

    //
    // makeBuckets
    //
    makeBuckets: function makeBucketsFn()
    {
        var result = [];

        for (var index = 0; index < this.numBuckets; index += 1)
        {
            result.push({headChunk: null});
        }
        return result;
    },

    //
    // allocate
    //
    allocate: function vertexBufferManagerAllocate(numVertices, attributes)
    {
        var vertexbuffer = null;
        var baseIndex = 0;

        var vertexbufferParameters =
        {
            attributes: attributes,
            dynamic: this.dynamicVertexBuffers
        };

        var poolIndex;
        var maxVerticesPerVertexBuffer = this.maxVerticesPerVertexBuffer;

        var attributesHash = attributes.join();
        var numVertexBuffersPools = this.vertexBuffersPools.length;
        var vertexBuffersPool;

        //Find the pool to allocate from
        for (poolIndex = 0; poolIndex < numVertexBuffersPools; poolIndex += 1)
        {
            if (this.vertexBuffersPools[poolIndex].attributesHash === attributesHash)
            {
                vertexBuffersPool = this.vertexBuffersPools[poolIndex];
                break;
            }
        }

        if (!vertexBuffersPool)
        {
            vertexBuffersPool = { attributesHash: attributesHash,
                                  vertexBufferData: [] };
            this.vertexBuffersPools.push(vertexBuffersPool);
        }

        var vertexBufferData;
        if (numVertices < maxVerticesPerVertexBuffer)
        {
            //Start at the correct size bucket and then look in bigger buckets if there is no suitable space
            //TODO: track last allocation as start point - but needs to be valid.
            for (var bucketIndex = this.bucket(numVertices); !vertexbuffer && bucketIndex < this.numBuckets; bucketIndex += 1)
            {
                var previousChunk;
                for (var vertexBufferIndex = 0; !vertexbuffer && (vertexBufferIndex < vertexBuffersPool.vertexBufferData.length); vertexBufferIndex += 1)
                {
                    vertexBufferData = vertexBuffersPool.vertexBufferData[vertexBufferIndex];

                    //Now find a to chunk allocate from
                    previousChunk = null;

                    for (var chunk = vertexBufferData.bucket[bucketIndex].headChunk; chunk;  chunk = chunk.nextChunk)
                    {
                        if (numVertices <= chunk.length)
                        {
                            vertexbuffer = vertexBufferData.vertexBuffer;
                            baseIndex = chunk.baseIndex;
                            if (numVertices < chunk.length)
                            {
                                chunk.baseIndex = (baseIndex + numVertices);
                                chunk.length -= numVertices;
                                var newBucketIndex = this.bucket(chunk.length);
                                if (newBucketIndex !== bucketIndex)
                                {
                                    if (previousChunk)
                                    {
                                        previousChunk.nextChunk =  chunk.nextChunk;
                                    }
                                    else
                                    {
                                        vertexBufferData.bucket[bucketIndex].headChunk = chunk.nextChunk;
                                    }
                                    //Add to new bucket
                                    chunk.nextChunk = vertexBufferData.bucket[newBucketIndex].headChunk;
                                    vertexBufferData.bucket[newBucketIndex].headChunk = chunk;
                                }
                            }
                            else
                            {
                                //Allocated whole chunk so remove it.
                                if (previousChunk)
                                {
                                    previousChunk.nextChunk =  chunk.nextChunk;
                                }
                                else
                                {
                                    vertexBufferData.bucket[bucketIndex].headChunk = chunk.nextChunk;
                                }
                                chunk.vertexBuffer = null;
                            }
                            break;
                        }
                        previousChunk = chunk;
                    }
                }
            }

            if (!vertexbuffer)
            {
                vertexbufferParameters.numVertices = maxVerticesPerVertexBuffer;
                vertexbuffer = this.graphicsDevice.createVertexBuffer(vertexbufferParameters);
                this.debugCreatedVertexBuffers += 1;

                Utilities.assert(vertexbuffer, "VertexBuffer not created.");

                if (vertexbuffer)
                {
                    vertexBufferData = {vertexBuffer: vertexbuffer,
                                        bucket: this.makeBuckets()};

                    vertexBufferData.bucket[this.bucket(maxVerticesPerVertexBuffer - numVertices)].headChunk = {baseIndex: numVertices,
                                                                                                                length: maxVerticesPerVertexBuffer - numVertices,
                                                                                                                nextChunk: null };

                    vertexBuffersPool.vertexBufferData.push(vertexBufferData);
                }
            }
        }

        if (!vertexbuffer)
        {
            vertexbufferParameters.numVertices = numVertices;
            vertexbuffer = this.graphicsDevice.createVertexBuffer(vertexbufferParameters);
            this.debugCreatedVertexBuffers += 1;

            Utilities.assert(vertexbuffer, "VertexBuffer not created.");

            if (vertexbuffer)
            {
                vertexBuffersPool.vertexBufferData.push({vertexBuffer: vertexbuffer,
                                                         bucket: this.makeBuckets()});
            }
        }

        return {
            vertexBuffer: vertexbuffer,
            baseIndex: baseIndex,
            length: numVertices,
            poolIndex: poolIndex
        };
    },

    //
    // free
    //
    free: function vertexBufferManagerFree(allocation)
    {
        var vertexBuffersPool = this.vertexBuffersPools[allocation.poolIndex];
        var vertexBufferData;
        for (var vertexBufferIndex = 0; vertexBufferIndex < vertexBuffersPool.vertexBufferData.length; vertexBufferIndex += 1)
        {
            if (allocation.vertexBuffer === vertexBuffersPool.vertexBufferData[vertexBufferIndex].vertexBuffer)
            {
                vertexBufferData = vertexBuffersPool.vertexBufferData[vertexBufferIndex];
                break;
            }
        }
        //TODO: optimise
        var leftChunk;
        var leftChunkPrevious;
        var rightChunk;
        var rightChunkPrevious;
        var previous;
        for (var bucketIndex = 0; !(leftChunk && rightChunk) && (bucketIndex < this.numBuckets); bucketIndex += 1)
        {
            previous = null;
            for (var chunk = vertexBufferData.bucket[bucketIndex].headChunk; chunk && !(leftChunk && rightChunk);  chunk = chunk.nextChunk)
            {
                if (!leftChunk)
                {
                    if (chunk.baseIndex + chunk.length === allocation.baseIndex)
                    {
                        leftChunk = chunk;
                        leftChunkPrevious = previous;
                    }
                }
                if (!rightChunk)
                {
                    if (chunk.baseIndex === allocation.baseIndex + allocation.length)
                    {
                        rightChunk = chunk;
                        rightChunkPrevious = previous;
                    }
                }
                previous = chunk;
            }
        }

        var oldBucketIndex;
        var newBucketIndex;
        if (leftChunk && rightChunk)
        {
            oldBucketIndex = this.bucket(leftChunk.length);
            leftChunk.length += allocation.length + rightChunk.length;

            //destroy right - before any move of left, as it previous could be the left...
            if (rightChunkPrevious)
            {
                rightChunkPrevious.nextChunk = rightChunk.nextChunk;
                if (rightChunk === leftChunkPrevious)
                {
                    leftChunkPrevious = rightChunkPrevious;
                }
            }
            else
            {
                vertexBufferData.bucket[this.bucket(rightChunk.length)].headChunk = rightChunk.nextChunk;
                if (rightChunk === leftChunkPrevious)
                {
                    leftChunkPrevious = null;
                }
            }

            //move left if it needs to
            newBucketIndex = this.bucket(leftChunk.length);
            if (newBucketIndex !== oldBucketIndex)
            {
                if (leftChunkPrevious)
                {
                    leftChunkPrevious.nextChunk =  leftChunk.nextChunk;
                }
                else
                {
                    vertexBufferData.bucket[oldBucketIndex].headChunk = leftChunk.nextChunk;
                }
                //Add to new bucket
                leftChunk.nextChunk = vertexBufferData.bucket[newBucketIndex].headChunk;
                vertexBufferData.bucket[newBucketIndex].headChunk = leftChunk;
            }
        }
        else if (leftChunk)
        {
            oldBucketIndex = this.bucket(leftChunk.length);
            leftChunk.length += allocation.length;

            newBucketIndex = this.bucket(leftChunk.length);

            if (newBucketIndex !== oldBucketIndex)
            {
                if (leftChunkPrevious)
                {
                    leftChunkPrevious.nextChunk =  leftChunk.nextChunk;
                }
                else
                {
                    vertexBufferData.bucket[oldBucketIndex].headChunk = leftChunk.nextChunk;
                }
                //Add to new bucket
                leftChunk.nextChunk = vertexBufferData.bucket[newBucketIndex].headChunk;
                vertexBufferData.bucket[newBucketIndex].headChunk = leftChunk;
            }
        }
        else if (rightChunk)
        {
            oldBucketIndex = this.bucket(rightChunk.length);
            rightChunk.baseIndex = allocation.baseIndex;
            rightChunk.length += allocation.length;

            newBucketIndex = this.bucket(rightChunk.length);

            if (newBucketIndex !== oldBucketIndex)
            {
                if (rightChunkPrevious)
                {
                    rightChunkPrevious.nextChunk =  rightChunk.nextChunk;
                }
                else
                {
                    vertexBufferData.bucket[oldBucketIndex].headChunk = rightChunk.nextChunk;
                }
                //Add to new bucket
                rightChunk.nextChunk = vertexBufferData.bucket[newBucketIndex].headChunk;
                vertexBufferData.bucket[newBucketIndex].headChunk = rightChunk;
            }
        }
        else
        {
            var bucket = vertexBufferData.bucket[this.bucket(allocation.length)];
            bucket.headChunk = {baseIndex: allocation.baseIndex,
                                length: allocation.length,
                                nextChunk: bucket.headChunk};
        }

        //See if the whole thing is free and if so free the VB
        var lastChunk = vertexBufferData.bucket[this.numBuckets - 1].headChunk;
        if (lastChunk && lastChunk.length >= this.maxVerticesPerVertexBuffer)
        {
            vertexBuffersPool.vertexBufferData.splice(vertexBufferIndex, 1);
            vertexBufferData.vertexBuffer.destroy();
            vertexBufferData.vertexBuffer = null;
            vertexBufferData.bucket.length = 0;
            vertexBufferData.bucket = null;
        }
    },

    //
    // destroy
    //
    destroy: function vertexBufferManagerDestroyFn()
    {
        var vertexBuffersPools = this.vertexBuffersPools;
        if (vertexBuffersPools)
        {
            var numVertexBuffersPools = vertexBuffersPools.length;
            var i, j;
            for (i = 0; i < numVertexBuffersPools; i += 1)
            {
                var vertexBuffersPool = vertexBuffersPools[i];

                var vertexBufferDataArray = vertexBuffersPool.vertexBufferData;
                var numVertexBufferData = vertexBufferDataArray.length;
                for (j = 0; j < numVertexBufferData; j += 1)
                {
                    var vertexBufferData = vertexBufferDataArray[j];

                    var bucketArray = vertexBufferData.bucket;
                    if (bucketArray)
                    {
                        bucketArray.length = 0;
                        vertexBufferData.bucket = null;
                    }

                    var vertexbuffer = vertexBufferData.vertexBuffer;
                    if (vertexbuffer)
                    {
                        vertexbuffer.destroy();
                        vertexBufferData.vertexBuffer = null;
                    }
                }
                vertexBufferDataArray.length = 0;
            }
            vertexBuffersPools.length = 0;

            this.vertexBuffersPools = null;
        }

        this.graphicsDevice = null;
    }
};

//
// create
//
VertexBufferManager.create = function vertexBufferManagerCreateFn(graphicsDevice, dynamicVertexBuffers)
{
    var manager = new VertexBufferManager();

    manager.vertexBuffersPools = [];    //Array keyed-off attribute
    manager.debugCreatedVertexBuffers = 0;
    manager.graphicsDevice = graphicsDevice;
    manager.dynamicVertexBuffers = dynamicVertexBuffers ? true : false;

    return manager;
};

// Copyright (c) 2012 Turbulenz Limited

/*global Utilities: false*/

//
// IndexBufferManager
//

function IndexBufferManager() {}

IndexBufferManager.prototype =
{
    version: 1,

    maxIndicesPerIndexBuffer: 65535,

    numBuckets: 10,

    //
    // bucket
    //
    bucket: function bucketFn(numIndices)
    {
        if (numIndices <= 64)
        {
            if (numIndices <= 16)
            {
                if (numIndices <= 8)
                {
                    return 0;
                }
                return 1;
            }

            if (numIndices <= 32)
            {
                return 2;
            }
            return 3;
        }

        if (numIndices <= 512)
        {
            if (numIndices <= 256)
            {
                if (numIndices <= 128)
                {
                    return 4;
                }
                return 5;
            }
            return 6;
        }

        if (numIndices <= 2048)
        {
            if (numIndices <= 1024)
            {
                return 7;
            }
            return 8;
        }
        return 9;
    },

    //
    // makeBuckets
    //
    makeBuckets: function makeBucketsFn()
    {
        var result = [];

        for (var index = 0; index < this.numBuckets; index += 1)
        {
            result.push({headChunk: null});
        }
        return result;
    },

    //
    // allocate
    //
    allocate: function indexBufferManagerAllocate(numIndices, format)
    {
        var indexbuffer = null;
        var baseIndex = 0;

        if (typeof format === "string")
        {
            format = this.graphicsDevice['INDEXFORMAT_' + format];
        }

        var indexbufferParameters =
        {
            format: format,
            dynamic: this.dynamicIndexBuffers
        };

        var poolIndex;
        var maxIndicesPerIndexBuffer = this.maxIndicesPerIndexBuffer;

        var numIndexBuffersPools = this.indexBuffersPools.length;
        var indexBuffersPool;

        //Find the pool to allocate from
        for (poolIndex = 0; poolIndex < numIndexBuffersPools; poolIndex += 1)
        {
            if (this.indexBuffersPools[poolIndex].format === format)
            {
                indexBuffersPool = this.indexBuffersPools[poolIndex];
                break;
            }
        }

        if (!indexBuffersPool)
        {
            indexBuffersPool = { format: format,
                                  indexBufferData: [] };
            this.indexBuffersPools.push(indexBuffersPool);
        }

        var indexBufferData;
        if (numIndices < maxIndicesPerIndexBuffer)
        {
            //Start at the correct size bucket and then look in bigger buckets if there is no suitable space
            //TODO: track last allocation as start point - but needs to be valid.
            for (var bucketIndex = this.bucket(numIndices); !indexbuffer && bucketIndex < this.numBuckets; bucketIndex += 1)
            {
                var previousChunk;
                for (var indexBufferIndex = 0; !indexbuffer && (indexBufferIndex < indexBuffersPool.indexBufferData.length); indexBufferIndex += 1)
                {
                    indexBufferData = indexBuffersPool.indexBufferData[indexBufferIndex];

                    //Now find a to chunk allocate from
                    previousChunk = null;

                    for (var chunk = indexBufferData.bucket[bucketIndex].headChunk; chunk;  chunk = chunk.nextChunk)
                    {
                        if (numIndices <= chunk.length)
                        {
                            indexbuffer = indexBufferData.indexBuffer;
                            baseIndex = chunk.baseIndex;
                            if (numIndices < chunk.length)
                            {
                                chunk.baseIndex = (baseIndex + numIndices);
                                chunk.length -= numIndices;
                                var newBucketIndex = this.bucket(chunk.length);
                                if (newBucketIndex !== bucketIndex)
                                {
                                    if (previousChunk)
                                    {
                                        previousChunk.nextChunk =  chunk.nextChunk;
                                    }
                                    else
                                    {
                                        indexBufferData.bucket[bucketIndex].headChunk = chunk.nextChunk;
                                    }
                                    //Add to new bucket
                                    chunk.nextChunk = indexBufferData.bucket[newBucketIndex].headChunk;
                                    indexBufferData.bucket[newBucketIndex].headChunk = chunk;
                                }
                            }
                            else
                            {
                                //Allocated whole chunk so remove it.
                                if (previousChunk)
                                {
                                    previousChunk.nextChunk =  chunk.nextChunk;
                                }
                                else
                                {
                                    indexBufferData.bucket[bucketIndex].headChunk = chunk.nextChunk;
                                }
                                chunk.indexBuffer = null;
                            }
                            break;
                        }
                        previousChunk = chunk;
                    }
                }
            }

            if (!indexbuffer)
            {
                indexbufferParameters.numIndices = maxIndicesPerIndexBuffer;
                indexbuffer = this.graphicsDevice.createIndexBuffer(indexbufferParameters);
                this.debugCreatedIndexBuffers += 1;

                Utilities.assert(indexbuffer, "IndexBuffer not created.");

                if (indexbuffer)
                {
                    indexBufferData = {indexBuffer: indexbuffer,
                                        bucket: this.makeBuckets()};

                    indexBufferData.bucket[this.bucket(maxIndicesPerIndexBuffer - numIndices)].headChunk = {baseIndex: numIndices,
                                                                                                                length: maxIndicesPerIndexBuffer - numIndices,
                                                                                                                nextChunk: null };

                    indexBuffersPool.indexBufferData.push(indexBufferData);
                }
            }
        }

        if (!indexbuffer)
        {
            indexbufferParameters.numIndices = numIndices;
            indexbuffer = this.graphicsDevice.createIndexBuffer(indexbufferParameters);
            this.debugCreatedIndexBuffers += 1;

            Utilities.assert(indexbuffer, "IndexBuffer not created.");

            if (indexbuffer)
            {
                indexBuffersPool.indexBufferData.push({indexBuffer: indexbuffer,
                                                         bucket: this.makeBuckets()});
            }
        }

        return {
            indexBuffer: indexbuffer,
            baseIndex: baseIndex,
            length: numIndices,
            poolIndex: poolIndex
        };
    },

    //
    // free
    //
    free: function indexBufferManagerFree(allocation)
    {
        var indexBuffersPool = this.indexBuffersPools[allocation.poolIndex];
        var indexBufferData;
        for (var indexBufferIndex = 0; indexBufferIndex < indexBuffersPool.indexBufferData.length; indexBufferIndex += 1)
        {
            if (allocation.indexBuffer === indexBuffersPool.indexBufferData[indexBufferIndex].indexBuffer)
            {
                indexBufferData = indexBuffersPool.indexBufferData[indexBufferIndex];
                break;
            }
        }
        //TODO: optimise
        var leftChunk;
        var leftChunkPrevious;
        var rightChunk;
        var rightChunkPrevious;
        var previous;
        for (var bucketIndex = 0; !(leftChunk && rightChunk) && (bucketIndex < this.numBuckets); bucketIndex += 1)
        {
            previous = null;
            for (var chunk = indexBufferData.bucket[bucketIndex].headChunk; chunk && !(leftChunk && rightChunk);  chunk = chunk.nextChunk)
            {
                if (!leftChunk)
                {
                    if (chunk.baseIndex + chunk.length === allocation.baseIndex)
                    {
                        leftChunk = chunk;
                        leftChunkPrevious = previous;
                    }
                }
                if (!rightChunk)
                {
                    if (chunk.baseIndex === allocation.baseIndex + allocation.length)
                    {
                        rightChunk = chunk;
                        rightChunkPrevious = previous;
                    }
                }
                previous = chunk;
            }
        }

        var oldBucketIndex;
        var newBucketIndex;
        if (leftChunk && rightChunk)
        {
            oldBucketIndex = this.bucket(leftChunk.length);
            leftChunk.length += allocation.length + rightChunk.length;

            //destroy right - before any move of left, as it previous could be the left...
            if (rightChunkPrevious)
            {
                rightChunkPrevious.nextChunk = rightChunk.nextChunk;
                if (rightChunk === leftChunkPrevious)
                {
                    leftChunkPrevious = rightChunkPrevious;
                }
            }
            else
            {
                indexBufferData.bucket[this.bucket(rightChunk.length)].headChunk = rightChunk.nextChunk;
                if (rightChunk === leftChunkPrevious)
                {
                    leftChunkPrevious = null;
                }
            }

            //move left if it needs to
            newBucketIndex = this.bucket(leftChunk.length);
            if (newBucketIndex !== oldBucketIndex)
            {
                if (leftChunkPrevious)
                {
                    leftChunkPrevious.nextChunk =  leftChunk.nextChunk;
                }
                else
                {
                    indexBufferData.bucket[oldBucketIndex].headChunk = leftChunk.nextChunk;
                }
                //Add to new bucket
                leftChunk.nextChunk = indexBufferData.bucket[newBucketIndex].headChunk;
                indexBufferData.bucket[newBucketIndex].headChunk = leftChunk;
            }
        }
        else if (leftChunk)
        {
            oldBucketIndex = this.bucket(leftChunk.length);
            leftChunk.length += allocation.length;

            newBucketIndex = this.bucket(leftChunk.length);

            if (newBucketIndex !== oldBucketIndex)
            {
                if (leftChunkPrevious)
                {
                    leftChunkPrevious.nextChunk =  leftChunk.nextChunk;
                }
                else
                {
                    indexBufferData.bucket[oldBucketIndex].headChunk = leftChunk.nextChunk;
                }
                //Add to new bucket
                leftChunk.nextChunk = indexBufferData.bucket[newBucketIndex].headChunk;
                indexBufferData.bucket[newBucketIndex].headChunk = leftChunk;
            }
        }
        else if (rightChunk)
        {
            oldBucketIndex = this.bucket(rightChunk.length);
            rightChunk.baseIndex = allocation.baseIndex;
            rightChunk.length += allocation.length;

            newBucketIndex = this.bucket(rightChunk.length);

            if (newBucketIndex !== oldBucketIndex)
            {
                if (rightChunkPrevious)
                {
                    rightChunkPrevious.nextChunk =  rightChunk.nextChunk;
                }
                else
                {
                    indexBufferData.bucket[oldBucketIndex].headChunk = rightChunk.nextChunk;
                }
                //Add to new bucket
                rightChunk.nextChunk = indexBufferData.bucket[newBucketIndex].headChunk;
                indexBufferData.bucket[newBucketIndex].headChunk = rightChunk;
            }
        }
        else
        {
            var bucket = indexBufferData.bucket[this.bucket(allocation.length)];
            bucket.headChunk = {baseIndex: allocation.baseIndex,
                                length: allocation.length,
                                nextChunk: bucket.headChunk};
        }

        //See if the whole thing is free and if so free the VB
        var lastChunk = indexBufferData.bucket[this.numBuckets - 1].headChunk;
        if (lastChunk && lastChunk.length >= this.maxIndicesPerIndexBuffer)
        {
            indexBuffersPool.indexBufferData.splice(indexBufferIndex, 1);
            indexBufferData.indexBuffer.destroy();
            indexBufferData.indexBuffer = null;
            indexBufferData.bucket.length = 0;
            indexBufferData.bucket = null;
        }
    },

    //
    // destroy
    //
    destroy: function indexBufferManagerDestroyFn()
    {
        var indexBuffersPools = this.indexBuffersPools;
        if (indexBuffersPools)
        {
            var numIndexBuffersPools = indexBuffersPools.length;
            var i, j;
            for (i = 0; i < numIndexBuffersPools; i += 1)
            {
                var indexBuffersPool = indexBuffersPools[i];

                var indexBufferDataArray = indexBuffersPool.indexBufferData;
                var numIndexBufferData = indexBufferDataArray.length;
                for (j = 0; j < numIndexBufferData; j += 1)
                {
                    var indexBufferData = indexBufferDataArray[j];

                    var bucketArray = indexBufferData.bucket;
                    if (bucketArray)
                    {
                        bucketArray.length = 0;
                        indexBufferData.bucket = null;
                    }

                    var indexbuffer = indexBufferData.indexBuffer;
                    if (indexbuffer)
                    {
                        indexbuffer.destroy();
                        indexBufferData.indexBuffer = null;
                    }
                }
                indexBufferDataArray.length = 0;
            }
            indexBuffersPools.length = 0;

            this.indexBuffersPools = null;
        }

        this.graphicsDevice = null;
    }
};

//
// create
//
IndexBufferManager.create = function indexBufferManagerCreateFn(graphicsDevice, dynamicIndexBuffers)
{
    var manager = new IndexBufferManager();

    manager.indexBuffersPools = [];    //Array keyed-off attribute
    manager.debugCreatedIndexBuffers = 0;
    manager.graphicsDevice = graphicsDevice;
    manager.dynamicIndexBuffers = dynamicIndexBuffers ? true : false;

    return manager;
};

// Copyright (c) 2009-2012 Turbulenz Limited
/*global Float32Array: false*/

//
// Vector math library
//
var VMathArrayConstructor = [].constructor;

var VMath =
{
    version : 1,

    // Default precision for equality comparations
    precision : 1e-6,

    FLOAT_MAX : Number.MAX_VALUE,

    select : function selectFn(m, a, b)
    {
        if (m)
        {
            return a;
        }
        else
        {
            return b;
        }
    },

    reciprocal : function reciprocalFn(a)
    {
        if (a !== 0.0)
        {
            return (1.0 / a);
        }
        else
        {
            throw "Division by zero";
        }
    },

    truncate : function truncateFn(value)
    {
        return parseInt(value, 10);
    },

    //
    // Vector3
    //
    v3BuildZero : function v3BuildZeroFn(dst) {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = 0.0;
        dst[1] = 0.0;
        dst[2] = 0.0;
        return dst;
    },

    v3BuildOne  : function v3BuildOneFn(dst) {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = 1.0;
        dst[1] = 1.0;
        dst[2] = 1.0;
        return dst;
    },

    v3BuildXAxis : function v3BuildXAxisFn(dst) {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = 1.0;
        dst[1] = 0.0;
        dst[2] = 0.0;
        return dst;
    },

    v3BuildYAxis : function v3BuildYAxisFn(dst) {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = 0.0;
        dst[1] = 1.0;
        dst[2] = 0.0;
        return dst;
    },

    v3BuildZAxis : function v3BuildZAxisFn(dst) {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = 0.0;
        dst[1] = 0.0;
        dst[2] = 1.0;
        return dst;
    },

    v3Build : function v3Fn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = a;
        dst[1] = b;
        dst[2] = c;
        return dst;
    },

    v3Copy : function v3CopyFn(src, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = src[0];
        dst[1] = src[1];
        dst[2] = src[2];
        return dst;
    },

    v3Set : function v3SetFn(v, a)
    {
        v[0] = a[0];
        v[1] = a[1];
        v[2] = a[2];
    },

    v3Neg : function v3NegFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = -a[0];
        dst[1] = -a[1];
        dst[2] = -a[2];
        return dst;
    },

    v3Add : function v3AddFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = (a[0] + b[0]);
        dst[1] = (a[1] + b[1]);
        dst[2] = (a[2] + b[2]);
        return dst;
    },

    v3Add3 : function v3Add3Fn(a, b, c)
    {
        return [(a[0] + b[0] + c[0]),
                (a[1] + b[1] + c[1]),
                (a[2] + b[2] + c[2])];
    },

    v3Add4 : function v3Add4Fn(a, b, c, d)
    {
        return [(a[0] + b[0] + c[0] + d[0]),
                (a[1] + b[1] + c[1] + d[1]),
                (a[2] + b[2] + c[2] + d[2])];
    },

    v3Sub : function v3SubFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = (a[0] - b[0]);
        dst[1] = (a[1] - b[1]);
        dst[2] = (a[2] - b[2]);
        return dst;
    },

    v3Mul : function v3MulFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = (a[0] * b[0]);
        dst[1] = (a[1] * b[1]);
        dst[2] = (a[2] * b[2]);
        return dst;
    },

    v3MulAdd : function v3MulAddFn(a, b, c)
    {
        return [((a[0] * b[0]) + c[0]), ((a[1] * b[1]) + c[1]), ((a[2] * b[2]) + c[2])];
    },

    v3Dot : function v3DotFn(a, b)
    {
        return ((a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]));
    },

    v3Cross : function v3CrossFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var b0 = b[0];
        var b1 = b[1];
        var b2 = b[2];
        dst[0] = ((a1 * b2) - (a2 * b1));
        dst[1] = ((a2 * b0) - (a0 * b2));
        dst[2] = ((a0 * b1) - (a1 * b0));
        return dst;
    },

    v3LengthSq : function v3LengthSqFn(a)
    {
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        return ((a0 * a0) + (a1 * a1) + (a2 * a2));
    },

    v3Length : function v3LengthFn(a)
    {
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        return Math.sqrt((a0 * a0) + (a1 * a1) + (a2 * a2));
    },

    v3Reciprocal : function v3ReciprocalFn(a)
    {
        var rcp = VMath.reciprocal;
        return [rcp(a[0]), rcp(a[1]), rcp(a[2])];
    },

    v3Normalize : function v3NormalizeFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var lsq = ((a0 * a0) + (a1 * a1) + (a2 * a2));
        if (lsq > 0.0)
        {
            var lr = 1.0 / Math.sqrt(lsq);
            dst[0] = (a0 * lr);
            dst[1] = (a1 * lr);
            dst[2] = (a2 * lr);
        }
        else
        {
            dst[0] = 0;
            dst[1] = 0;
            dst[2] = 0;
        }
        return dst;
    },

    v3Abs : function v3AbsFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        var abs = Math.abs;
        dst[0] = abs(a[0]);
        dst[1] = abs(a[1]);
        dst[2] = abs(a[2]);
        return dst;
    },

    v3Max : function v3MaxFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        var max = Math.max;
        dst[0] = max(a[0], b[0]);
        dst[1] = max(a[1], b[1]);
        dst[2] = max(a[2], b[2]);
        return dst;
    },

    v3Min : function v3MinFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        var min = Math.min;
        dst[0] = min(a[0], b[0]);
        dst[1] = min(a[1], b[1]);
        dst[2] = min(a[2], b[2]);
        return dst;
    },

    v3Equal : function v3EqualFn(a, b, precision)
    {
        var abs = Math.abs;
        if (precision === undefined)
        {
            precision = this.precision;
        }
        return (abs(a[0] - b[0]) <= precision &&
                abs(a[1] - b[1]) <= precision &&
                abs(a[2] - b[2]) <= precision);
    },

    // Vector3 'masks'
    v3MaskEqual : function v3MaskEqualFn(a, b)
    {
        var abs = Math.abs;
        var precision = VMath.precision;
        return [(abs(a[0] - b[0]) <= precision),
                (abs(a[1] - b[1]) <= precision),
                (abs(a[2] - b[2]) <= precision)];
    },

    v3MaskLess : function v3MaskLessFn(a, b)
    {
        return [(a[0] < b[0]),
                (a[1] < b[1]),
                (a[2] < b[2])];
    },

    v3MaskGreater : function v3MaskGreaterFn(a, b)
    {
        return [(a[0] > b[0]),
                (a[1] > b[1]),
                (a[2] > b[2])];
    },

    v3MaskGreaterEq : function v3MaskGreaterEqFn(a, b)
    {
        return [(a[0] >= b[0]),
                (a[1] >= b[1]),
                (a[2] >= b[2])];
    },

    v3MaskNot : function v3MaskNotFn(a)
    {
        return [!a[0],
                !a[1],
                !a[2]];
    },

    v3MaskOr : function v3MaskOrFn(a, b)
    {
        return [(a[0] || b[0]),
                (a[1] || b[1]),
                (a[2] || b[2])];
    },

    v3MaskAnd : function v3MaskAndFn(a, b)
    {
        return [(a[0] && b[0]),
                (a[1] && b[1]),
                (a[2] && b[2])];
    },

    v3Select : function v3SelectFn(m, a, b)
    {
        var select = VMath.select;
        return [select(m[0], a[0], b[0]),
                select(m[1], a[1], b[1]),
                select(m[2], a[2], b[2])];
    },

    // Vector3 operations with scalar
    v3ScalarBuild : function v3ScalarBuildFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        dst[0] = a;
        dst[1] = a;
        dst[2] = a;

        return dst;
    },

    v3ScalarMax : function v3ScalarMaxFn(a, b)
    {
        var max = Math.max;
        return [max(a[0], b), max(a[1], b), max(a[2], b)];
    },

    v3ScalarMin : function v3ScalarMinFn(a, b)
    {
        var min = Math.min;
        return [min(a[0], b), min(a[1], b), min(a[2], b)];
    },

    v3ScalarAdd : function v3ScalarAddFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        dst[0] = (a[0] + b);
        dst[1] = (a[1] + b);
        dst[2] = (a[2] + b);

        return dst;
    },

    v3ScalarSub : function v3ScalarSubFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        dst[0] = (a[0] - b);
        dst[1] = (a[1] - b);
        dst[2] = (a[2] - b);

        return dst;
    },

    v3ScalarMul : function v3ScalarMulFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        if (b === 0)
        {
            dst[0] = 0;
            dst[1] = 0;
            dst[2] = 0;
        }
        else
        {
            dst[0] = (a[0] * b);
            dst[1] = (a[1] * b);
            dst[2] = (a[2] * b);
        }
        return dst;
    },

    v3AddScalarMul : function v3AddScalarMulFn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        dst[0] = a[0] + b[0] * c;
        dst[1] = a[1] + b[1] * c;
        dst[2] = a[2] + b[2] * c;

        return dst;
    },

    // Vector3 'masks' with scalars
    v3EqualScalarMask : function v3EqualScalarMaskFn(a, b)
    {
        var abs = Math.abs;
        var precision = VMath.precision;
        return [(abs(a[0] - b) <= precision),
                (abs(a[1] - b) <= precision),
                (abs(a[2] - b) <= precision)];
    },

    v3LessScalarMask : function v3LessScalarMaskFn(a, b)
    {
        return [(a[0] > b),
                (a[1] > b),
                (a[2] > b)];
    },

    v3GreaterScalarMask : function v3GreaterScalarMaskFn(a, b)
    {
        return [(a[0] > b),
                (a[1] > b),
                (a[2] > b)];
    },

    v3GreaterEqScalarMask : function v3GreaterEqScalarMaskFn(a, b)
    {
        return [(a[0] >= b),
                (a[1] >= b),
                (a[2] >= b)];
    },

    v3Lerp : function v3LerpFn(a, b, t, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        dst[0] =  (a[0] + ((b[0] - a[0]) * t));
        dst[1] =  (a[1] + ((b[1] - a[1]) * t));
        dst[2] =  (a[2] + ((b[2] - a[2]) * t));

        return dst;
    },

    //
    // Vector4
    //
    v4BuildZero : function v4BuildZeroFn(dst) {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = 0.0;
        dst[1] = 0.0;
        dst[2] = 0.0;
        dst[3] = 0.0;
        return dst;
    },

    v4BuildOne  : function v4BuildOneFn(dst) {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = 1.0;
        dst[1] = 1.0;
        dst[2] = 1.0;
        dst[3] = 1.0;
        return dst;
    },

    v4Build : function v4BuildFn(a, b, c, d, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = a;
        dst[1] = b;
        dst[2] = c;
        dst[3] = d;
        return dst;
    },

    v4Copy : function v4CopyFn(src, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = src[0];
        dst[1] = src[1];
        dst[2] = src[2];
        dst[3] = src[3];
        return dst;
    },

    v4Set : function v4SetFn(v, a)
    {
        v[0] = a[0];
        v[1] = a[1];
        v[2] = a[2];
        v[3] = a[3];
    },

    v4Neg : function v4NegFn(a)
    {
        return [-a[0], -a[1], -a[2], -a[3]];
    },

    v4Add : function v4AddFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = (a[0] + b[0]);
        dst[1] = (a[1] + b[1]);
        dst[2] = (a[2] + b[2]);
        dst[3] = (a[3] + b[3]);
        return dst;
    },

    v4Add3 : function v4Add3Fn(a, b, c)
    {
        return [(a[0] + b[0] + c[0]),
                (a[1] + b[1] + c[1]),
                (a[2] + b[2] + c[2]),
                (a[3] + b[3] + c[3])];
    },

    v4Add4 : function v4Add4Fn(a, b, c, d)
    {
        return [(a[0] + b[0] + c[0] + d[0]),
                (a[1] + b[1] + c[1] + d[1]),
                (a[2] + b[2] + c[2] + d[2]),
                (a[3] + b[3] + c[3] + d[3])];
    },

    v4Sub : function v4SubFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = (a[0] - b[0]);
        dst[1] = (a[1] - b[1]);
        dst[2] = (a[2] - b[2]);
        dst[3] = (a[3] - b[3]);
        return dst;
    },

    v4Mul : function v4MulFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = (a[0] * b[0]);
        dst[1] = (a[1] * b[1]);
        dst[2] = (a[2] * b[2]);
        dst[3] = (a[3] * b[3]);
        return dst;
    },

    v4MulAdd : function v4MulAddFn(a, b, c)
    {
        return [((a[0] * b[0]) + c[0]),
                ((a[1] * b[1]) + c[1]),
                ((a[2] * b[2]) + c[2]),
                ((a[3] * b[3]) + c[3])];
    },

    v4Dot : function v4DotFn(a, b)
    {
        return ((a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]));
    },

    v4LengthSq : function v4LengthSqFn(a)
    {
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var a3 = a[3];
        return ((a0 * a0) + (a1 * a1) + (a2 * a2) + (a3 * a3));
    },

    v4Length : function v4LengthFn(a)
    {
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var a3 = a[3];
        return Math.sqrt((a0 * a0) + (a1 * a1) + (a2 * a2) + (a3 * a3));
    },

    v4Reciprocal : function v4ReciprocalFn(a)
    {
        var rcp = VMath.reciprocal;
        return [rcp(a[0]), rcp(a[1]), rcp(a[2]), rcp(a[3])];
    },

    v4Normalize : function v4NormalizeFn(a)
    {
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var a3 = a[3];
        var lsq = ((a0 * a0) + (a1 * a1) + (a2 * a2) + (a3 * a3));
        if (lsq > 0.0)
        {
            var lr = 1.0 / Math.sqrt(lsq);
            return [(a0 * lr), (a1 * lr), (a2 * lr), (a3 * lr)];
        }
        else
        {
            return [0, 0, 0, 0];
        }
    },

    v4Abs : function v4AbsFn(a)
    {
        var abs = Math.abs;
        return [abs(a[0]), abs(a[1]), abs(a[2]), abs(a[3])];
    },

    v4Max : function v4MaxFn(a, b)
    {
        var max = Math.max;
        return [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]), max(a[3], b[3])];
    },

    v4Min : function v4MinFn(a, b)
    {
        var min = Math.min;
        return [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]), min(a[3], b[3])];
    },

    v4Equal : function v4EqualFn(a, b, precision)
    {
        var abs = Math.abs;
        if (precision === undefined)
        {
            precision = this.precision;
        }
        return (abs(a[0] - b[0]) <= precision &&
                abs(a[1] - b[1]) <= precision &&
                abs(a[2] - b[2]) <= precision &&
                abs(a[3] - b[3]) <= precision);
    },

    // Vector3 'masks'
    v4MaskEqual : function v4MaskEqualFn(a, b)
    {
        var abs = Math.abs;
        var precision = VMath.precision;
        return [(abs(a[0] - b[0]) <= precision),
                (abs(a[1] - b[1]) <= precision),
                (abs(a[2] - b[2]) <= precision),
                (abs(a[3] - b[3]) <= precision)];
    },

    v4MaskLess : function v4MaskLessFn(a, b)
    {
        return [(a[0] < b[0]),
                (a[1] < b[1]),
                (a[2] < b[2]),
                (a[3] < b[3])];
    },

    v4MaskGreater : function v4MaskGreaterFn(a, b)
    {
        return [(a[0] > b[0]),
                (a[1] > b[1]),
                (a[2] > b[2]),
                (a[3] > b[3])];
    },

    v4MaskGreaterEq : function v4MaskGreaterEqFn(a, b)
    {
        return [(a[0] >= b[0]),
                (a[1] >= b[1]),
                (a[2] >= b[2]),
                (a[3] >= b[3])];
    },

    v4MaskNot : function v4MaskNotFn(a)
    {
        return [!a[0],
                !a[1],
                !a[2],
                !a[3]];
    },

    v4MaskOr : function v4MaskOrFn(a, b)
    {
        return [(a[0] || b[0]),
                (a[1] || b[1]),
                (a[2] || b[2]),
                (a[3] || b[3])];
    },

    v4MaskAnd : function v4MaskAndFn(a, b)
    {
        return [(a[0] && b[0]),
                (a[1] && b[1]),
                (a[2] && b[2]),
                (a[3] && b[3])];
    },

    v4Many : function v4ManyFn(m)
    {
        return (m[0] || m[1] || m[2] || m[3]);
    },

    v4MaskAll : function v4MaskAllFn(m)
    {
        return (m[0] && m[1] && m[2] && m[3]);
    },

    v4Select : function v4SelectFn(m, a, b)
    {
        var select = VMath.select;
        return [select(m[0], a[0], b[0]),
                select(m[1], a[1], b[1]),
                select(m[2], a[2], b[2]),
                select(m[3], a[3], b[3])];
    },

    // Vector4 operations with scalar
    v4ScalarBuild : function v4ScalarBuildFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = a;
        dst[1] = a;
        dst[2] = a;
        dst[3] = a;

        return dst;
    },

    v4ScalarMax : function v4ScalarMaxFn(a, b)
    {
        var max = Math.max;
        return [max(a[0], b), max(a[1], b), max(a[2], b), max(a[3], b)];
    },

    v4ScalarMin : function v4ScalarMinFn(a, b)
    {
        var min = Math.min;
        return [min(a[0], b), min(a[1], b), min(a[2], b), min(a[3], b)];
    },

    v4ScalarAdd : function v4ScalarAddFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = (a[0] + b);
        dst[1] = (a[1] + b);
        dst[2] = (a[2] + b);
        dst[3] = (a[3] + b);

        return dst;
    },

    v4ScalarSub : function v4ScalarSubFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = (a[0] - b);
        dst[1] = (a[1] - b);
        dst[2] = (a[2] - b);
        dst[3] = (a[3] - b);

        return dst;
    },

    v4ScalarMul : function v4ScalarMulFn(a, b, dst)
    {
        if (b === 0)
        {
            return VMath.v4BuildZero(dst);
        }
        else
        {
            if (dst === undefined)
            {
                dst = new VMathArrayConstructor(4);
            }

            dst[0] = (a[0] * b);
            dst[1] = (a[1] * b);
            dst[2] = (a[2] * b);
            dst[3] = (a[3] * b);

            return dst;
        }
    },

    v4AddScalarMul : function v4AddScalarMulFn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = a[0] + b[0] * c;
        dst[1] = a[1] + b[1] * c;
        dst[2] = a[2] + b[2] * c;
        dst[3] = a[3] + b[3] * c;

        return dst;
    },

    v4ScalarEqual : function v4ScalarEqualFn(a, b)
    {
        var abs = Math.abs;
        var precision = VMath.precision;
        return (abs(a[0] - b) <= precision &&
                abs(a[1] - b) <= precision &&
                abs(a[2] - b) <= precision &&
                abs(a[3] - b) <= precision);
    },

    // Vector3 'masks' with scalars
    v4EqualScalarMask : function v4EqualScalarMaskFn(a, b)
    {
        var abs = Math.abs;
        var precision = VMath.precision;
        return [(abs(a[0] - b) <= precision),
                (abs(a[1] - b) <= precision),
                (abs(a[2] - b) <= precision),
                (abs(a[3] - b) <= precision)];
    },

    v4LessScalarMask : function v4LessScalarMaskFn(a, b)
    {
        return [(a[0] < b),
                (a[1] < b),
                (a[2] < b),
                (a[3] < b)];
    },

    v4GreaterScalarMask : function v4GreaterScalarMaskFn(a, b)
    {
        return [(a[0] > b),
                (a[1] > b),
                (a[2] > b),
                (a[3] > b)];
    },

    v4GreaterEqScalarMask : function v4GreaterEqScalarMaskFn(a, b)
    {
        return [(a[0] >= b),
                (a[1] >= b),
                (a[2] >= b),
                (a[3] >= b)];
    },

    v4Lerp : function v4LerpFn(a, b, t, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = (a[0] + ((b[0] - a[0]) * t));
        dst[1] = (a[1] + ((b[1] - a[1]) * t));
        dst[2] = (a[2] + ((b[2] - a[2]) * t));
        dst[3] = (a[3] + ((b[3] - a[3]) * t));
        return dst;
    },

    //
    // AABB
    //

    aabbBuild : function aabbBuildFn(a0, a1, a2, a3, a4, a5, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(6);
        }

        dst[0] = a0;
        dst[1] = a1;
        dst[2] = a2;
        dst[3] = a3;
        dst[4] = a4;
        dst[5] = a5;

        return dst;
    },

    aabbBuildEmpty : function aabbBuildEmptyFn(dst)
    {
        var float_max = this.FLOAT_MAX;

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(6);
        }

        dst[0] = float_max;
        dst[1] = float_max;
        dst[2] = float_max;
        dst[3] = -float_max;
        dst[4] = -float_max;
        dst[5] = -float_max;

        return dst;
    },

    aabbCopy : function aabbCopyFn(aabb, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(6);
        }

        dst[0] = aabb[0];
        dst[1] = aabb[1];
        dst[2] = aabb[2];
        dst[3] = aabb[3];
        dst[4] = aabb[4];
        dst[5] = aabb[5];

        return dst;
    },

    aabbSet : function aabbSet(dst, src)
    {
        dst[0] = src[0];
        dst[1] = src[1];
        dst[2] = src[2];
        dst[3] = src[3];
        dst[4] = src[4];
        dst[5] = src[5];
    },

    aabbIsEmpty : function aabbIsEmptyFn(aabb)
    {
        return aabb[0] > aabb[3];
    },

    aabbMin : function aabbMinFn(aabb)
    {
        return [aabb[0], aabb[1], aabb[2]];
    },

    aabbMax : function aabbMaxFn(aabb)
    {
        return [aabb[3], aabb[4], aabb[5]];
    },

    aabbGetCenterAndHalf : function aabbGetCenterAndHalfFn(aabb, center, half)
    {
        var cX = (aabb[0] + aabb[3]) * 0.5;
        var cY = (aabb[1] + aabb[4]) * 0.5;
        var cZ = (aabb[2] + aabb[5]) * 0.5;

        center[0] = cX;
        center[1] = cY;
        center[2] = cZ;

        half[0] = aabb[3] - cX;
        half[1] = aabb[4] - cY;
        half[2] = aabb[5] - cZ;
    },

    aabbIsInsidePlanes : function aabbIsInsidePlanesFn(aabb, planes)
    {
        var numPlanes = planes.length;
        var n = 0;
        do
        {
            var plane = planes[n];
            var d0 = plane[0];
            var d1 = plane[1];
            var d2 = plane[2];
            if ((d0 * (d0 < 0 ? aabb[0] : aabb[3]) + d1 * (d1 < 0 ? aabb[1] : aabb[4]) + d2 * (d2 < 0 ? aabb[2] : aabb[5])) < plane[3])
            {
                return false;
            }
            n += 1;
        }
        while (n < numPlanes);
        return true;
    },

    aabbIsFullyInsidePlanes : function aabbIsFullyInsidePlanesFn(aabb, planes)
    {
        var numPlanes = planes.length;
        var n = 0;
        do
        {
            var plane = planes[n];
            var d0 = plane[0];
            var d1 = plane[1];
            var d2 = plane[2];
            if ((d0 * (d0 > 0 ? aabb[0] : aabb[3]) + d1 * (d1 > 0 ? aabb[1] : aabb[4]) + d2 * (d2 > 0 ? aabb[2] : aabb[5])) < plane[3])
            {
                return false;
            }
            n += 1;
        }
        while (n < numPlanes);
        return true;
    },

    aabbUnion : function aabbUnionFn(a, b)
    {
        return [(a[0] < b[0] ? a[0] : b[0]),
                (a[1] < b[1] ? a[1] : b[1]),
                (a[2] < b[2] ? a[2] : b[2]),
                (a[3] > b[3] ? a[3] : b[3]),
                (a[4] > b[4] ? a[4] : b[4]),
                (a[5] > b[5] ? a[5] : b[5])];
    },

    aabbUnionArray : function aabbUnionArrayFn(aabbArray)
    {
        var union = VMath.aabbCopy(aabbArray[0]);

        var numAABBs = aabbArray.length;
        for (var i = 0; i < numAABBs; i += 1)
        {
            var aabb = aabbArray[i];
            union[0] = (union[0] < aabb[0] ? union[0] : aabb[0]);
            union[1] = (union[1] < aabb[1] ? union[1] : aabb[1]);
            union[2] = (union[2] < aabb[2] ? union[2] : aabb[2]);
            union[3] = (union[3] > aabb[3] ? union[3] : aabb[3]);
            union[4] = (union[4] > aabb[4] ? union[4] : aabb[4]);
            union[5] = (union[5] > aabb[5] ? union[5] : aabb[5]);
        }

        return union;
    },

    aabbAddPoints : function aabbAddPointFn(aabb, ps)
    {
        var i;
        var numPoints = ps.length;

        var r0 = aabb[0];
        var r1 = aabb[1];
        var r2 = aabb[2];
        var r3 = aabb[3];
        var r4 = aabb[4];
        var r5 = aabb[5];

        var p0, p1, p2;

        for (i = 0; i < numPoints; i += 1)
        {
            p0 = ps[i][0];
            p1 = ps[i][1];
            p2 = ps[i][2];

            r0 = (r0 < p0 ? r0 : p0);
            r1 = (r1 < p1 ? r1 : p1);
            r2 = (r2 < p2 ? r2 : p2);
            r3 = (r3 > p0 ? r3 : p0);
            r4 = (r4 > p1 ? r4 : p1);
            r5 = (r5 > p2 ? r5 : p2);
        }

        aabb[0] = r0;
        aabb[1] = r1;
        aabb[2] = r2;
        aabb[3] = r3;
        aabb[4] = r4;
        aabb[5] = r5;

    },

    aabbTransform : function aabbTransformFn(aabb, matrix)
    {
        var cX = (aabb[0] + aabb[3]) * 0.5;
        var cY = (aabb[1] + aabb[4]) * 0.5;
        var cZ = (aabb[2] + aabb[5]) * 0.5;

        var hX = aabb[3] - cX;
        var hY = aabb[4] - cY;
        var hZ = aabb[5] - cZ;

        var m0 = matrix[0];
        var m1 = matrix[1];
        var m2 = matrix[2];
        var m3 = matrix[3];
        var m4 = matrix[4];
        var m5 = matrix[5];
        var m6 = matrix[6];
        var m7 = matrix[7];
        var m8 = matrix[8];

        var ctX = matrix[9] +  (m0 * cX + m3 * cY + m6 * cZ);
        var ctY = matrix[10] + (m1 * cX + m4 * cY + m7 * cZ);
        var ctZ = matrix[11] + (m2 * cX + m5 * cY + m8 * cZ);

        var abs = Math.abs;

        var htX = (abs(m0) * hX + abs(m3) * hY + abs(m6) * hZ);
        var htY = (abs(m1) * hX + abs(m4) * hY + abs(m7) * hZ);
        var htZ = (abs(m2) * hX + abs(m5) * hY + abs(m8) * hZ);

        return [(ctX - htX),
                (ctY - htY),
                (ctZ - htZ),
                (ctX + htX),
                (ctY + htY),
                (ctZ + htZ)];

    },

    aabbIntercept : function aabbInterceptFn(a, b)
    {
        return [(a[0] > b[0] ? a[0] : b[0]),
                (a[1] > b[1] ? a[1] : b[1]),
                (a[2] > b[2] ? a[2] : b[2]),
                (a[3] < b[3] ? a[3] : b[3]),
                (a[4] < b[4] ? a[4] : b[4]),
                (a[5] < b[5] ? a[5] : b[5])];

    },

    aabbOverlaps : function aabbOverlapsFn(a, b)
    {
        return ((a[0] <= b[3]) &&
                (a[1] <= b[4]) &&
                (a[2] <= b[5]) &&
                (a[3] >= b[0]) &&
                (a[4] >= b[1]) &&
                (a[5] >= b[2]));
    },

    aabbSphereOverlaps : function aabbSphereOverlapsFn(aabb, center, radius)
    {
        var centerX = center[0];
        var centerY = center[1];
        var centerZ = center[2];
        var radiusSquared = radius * radius;

        var minX = aabb[0];
        var minY = aabb[1];
        var minZ = aabb[2];
        var maxX = aabb[3];
        var maxY = aabb[4];
        var maxZ = aabb[5];
        var totalDistance = 0, sideDistance;

        if (centerX < minX)
        {
            sideDistance = (minX - centerX);
            totalDistance += (sideDistance * sideDistance);
        }
        else if (centerX > maxX)
        {
            sideDistance = (centerX - maxX);
            totalDistance += (sideDistance * sideDistance);
        }
        if (centerY < minY)
        {
            sideDistance = (minY - centerY);
            totalDistance += (sideDistance * sideDistance);
        }
        else if (centerY > maxY)
        {
            sideDistance = (centerY - maxY);
            totalDistance += (sideDistance * sideDistance);
        }
        if (centerZ < minZ)
        {
            sideDistance = (minZ - centerZ);
            totalDistance += (sideDistance * sideDistance);
        }
        else if (centerZ > maxZ)
        {
            sideDistance = (centerZ - maxZ);
            totalDistance += (sideDistance * sideDistance);
        }
        return (totalDistance <= radiusSquared);
    },

    aabbIsInside : function aabbIsInsideFn(a, b)
    {
        return ((a[0] >= b[0]) &&
                (a[1] >= b[1]) &&
                (a[2] >= b[2]) &&
                (a[3] <= b[3]) &&
                (a[4] <= b[4]) &&
                (a[5] <= b[5]));
    },

    aabbTestInside : function aabbTestInsideFn(a, b)
    {
        if ((a[0] <= b[3]) &&
                (a[1] <= b[4]) &&
                (a[2] <= b[5]) &&
                (a[3] >= b[0]) &&
                (a[4] >= b[1]) &&
                (a[5] >= b[2]))
        {

            if ((a[0] >= b[0]) &&
                (a[1] >= b[1]) &&
                (a[2] >= b[2]) &&
                (a[3] <= b[3]) &&
                (a[4] <= b[4]) &&
                (a[5] <= b[5]))
            {
                return 2;
            }
            return 1;
        }

        return 0;
    },

    //
    // Matrix
    //
    m33BuildIdentity : function m33BuildIdentityFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }

        dst[0] = 1.0;
        dst[1] = 0.0;
        dst[2] = 0.0;
        dst[3] = 0.0;
        dst[4] = 1.0;
        dst[5] = 0.0;
        dst[6] = 0.0;
        dst[7] = 0.0;
        dst[8] = 1.0;

        return dst;
    },

    // Matrix33
    m33Build : function m33BuildFn(r, u, a, dst)
    {
        var length = arguments.length;
        if (length >= 9)
        {
            // Can NOT use dst because it will overwrite the input value...
            var res;

            if (length > 9)
            {
                res = arguments[9];
                if (res === undefined)
                {
                    res = new VMathArrayConstructor(9);
                }
            }
            else
            {
                res = new VMathArrayConstructor(9);
            }

            res[0] = arguments[0];
            res[1] = arguments[1];
            res[2] = arguments[2];
            res[3] = arguments[3];
            res[4] = arguments[4];
            res[5] = arguments[5];
            res[6] = arguments[6];
            res[7] = arguments[7];
            res[8] = arguments[8];

            return res;
        }
        else
        {
            if (dst === undefined)
            {
                dst = new VMathArrayConstructor(9);
            }

            dst[0] = r[0];
            dst[1] = r[1];
            dst[2] = r[2];
            dst[3] = u[0];
            dst[4] = u[1];
            dst[5] = u[2];
            dst[6] = a[0];
            dst[7] = a[1];
            dst[8] = a[2];

            return dst;
        }
    },

    m33Copy : function m33CopyFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }

        dst[0] = m[0];
        dst[1] = m[1];
        dst[2] = m[2];
        dst[3] = m[3];
        dst[4] = m[4];
        dst[5] = m[5];
        dst[6] = m[6];
        dst[7] = m[7];
        dst[8] = m[8];

        return dst;
    },

    m33FromAxisRotation : function m33FromAxisRotationFn(axis, angle, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }

        var s = Math.sin(angle);
        var c = Math.cos(angle);
        var t = 1.0 - c;
        var axisX = axis[0];
        var axisY = axis[1];
        var axisZ = axis[2];
        var tx = t * axisX;
        var ty = t * axisY;
        var tz = t * axisZ;
        var sx = s * axisX;
        var sy = s * axisY;
        var sz = s * axisZ;

        dst[0] = tx * axisX + c;
        dst[1] = tx * axisY - sz;
        dst[2] = tx * axisZ + sy;
        dst[3] = ty * axisX + sz;
        dst[4] = ty * axisY + c;
        dst[5] = ty * axisZ - sx;
        dst[6] = tz * axisX - sy;
        dst[7] = tz * axisY + sx;
        dst[8] = tz * axisZ + c;

        return dst;
    },

    m33FromQuat: function m33FromQuatFn(q)
    {
        var qx = q[0];
        var qy = q[1];
        var qz = q[2];
        var qw = q[3];

        var xx = 2.0 * qx * qx;
        var yy = 2.0 * qy * qy;
        var zz = 2.0 * qz * qz;
        var xy = 2.0 * qx * qy;
        var zw = 2.0 * qz * qw;
        var xz = 2.0 * qx * qz;
        var yw = 2.0 * qy * qw;
        var yz = 2.0 * qy * qz;
        var xw = 2.0 * qx * qw;

        return [1.0 - yy - zz, xy - zw, xz + yw,
                xy + zw, 1.0 - xx - zz, yz - xw,
                xz - yw, yz + xw, 1.0 - xx - yy];
    },

    m33Right : function m33RightFn(m)
    {
        return [m[0], m[1], m[2]];
    },

    m33Up : function m33UpFn(m)
    {
        return [m[3], m[4], m[5]];
    },

    m33At : function m33AtFn(m)
    {
        return [m[6], m[7], m[8]];
    },

    m33SetRight : function m33SetRightFn(m, v)
    {
        m[0] = v[0];
        m[1] = v[1];
        m[2] = v[2];
    },

    m33SetUp : function m33SetUpFn(m, v)
    {
        m[3] = v[0];
        m[4] = v[1];
        m[5] = v[2];
    },

    m33SetAt : function m33SetAtFn(m, v)
    {
        m[6] = v[0];
        m[7] = v[1];
        m[8] = v[2];
    },

    m33Transpose : function m33TransposeFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        dst[0] = m0;
        dst[1] = m3;
        dst[2] = m6;
        dst[3] = m1;
        dst[4] = m4;
        dst[5] = m7;
        dst[6] = m2;
        dst[7] = m5;
        dst[8] = m8;
        return dst;
    },

    m33Determinant : function m33DeterminantFn(m)
    {
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        return (m0 * (m4 * m8 - m5 * m7) +
                m1 * (m5 * m6 - m3 * m8) +
                m2 * (m3 * m7 - m4 * m6));
    },

    m33Inverse : function m33InverseFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }

        var det = VMath.m33Determinant(m);
        if (det === 0.0)
        {
            dst[0] = dst[1] = dst[2] = 0.0;
            dst[3] = dst[4] = dst[5] = 0.0;
            dst[6] = dst[7] = dst[8] = 0.0;
            return dst;
        }
        else
        {
            var detrecp = 1.0 / det;
            dst[0] = ((m[4] * m[8] + m[5] * (-m[7])) * detrecp);
            dst[1] = ((m[7] * m[2] + m[8] * (-m[1])) * detrecp);
            dst[2] = ((m[1] * m[5] - m[2] *   m[4])  * detrecp);
            dst[3] = ((m[5] * m[6] + m[3] * (-m[8])) * detrecp);
            dst[4] = ((m[8] * m[0] + m[6] * (-m[2])) * detrecp);
            dst[5] = ((m[3] * m[2] - m[0] *   m[5])  * detrecp);
            dst[6] = ((m[3] * m[7] + m[4] * (-m[6])) * detrecp);
            dst[7] = ((m[6] * m[1] + m[7] * (-m[0])) * detrecp);
            dst[8] = ((m[0] * m[4] - m[3] *   m[1])  * detrecp);
            return dst;
        }
    },

    m33InverseTranspose : function m33InverseTransposeFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }

        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var det = (m0 * (m4 * m8 - m5 * m7) +
                   m1 * (m5 * m6 - m3 * m8) +
                   m2 * (m3 * m7 - m4 * m6));
        if (det === 0.0)
        {
            dst[0] = dst[1] = dst[2] = 0.0;
            dst[3] = dst[4] = dst[5] = 0.0;
            dst[6] = dst[7] = dst[8] = 0.0;
            return dst;
        }
        else
        {
            var detrecp = 1.0 / det;
            dst[0] = ((m4 * m8 + m5 * (-m7)) * detrecp);
            dst[3] = ((m7 * m2 + m8 * (-m1)) * detrecp);
            dst[6] = ((m1 * m5 - m2 *   m4)  * detrecp);
            dst[1] = ((m5 * m6 + m3 * (-m8)) * detrecp);
            dst[4] = ((m8 * m0 + m6 * (-m2)) * detrecp);
            dst[7] = ((m3 * m2 - m0 *   m5)  * detrecp);
            dst[2] = ((m3 * m7 + m4 * (-m6)) * detrecp);
            dst[5] = ((m6 * m1 + m7 * (-m0)) * detrecp);
            dst[8] = ((m0 * m4 - m3 *   m1)  * detrecp);
            return dst;
        }
    },

    m33Mul : function m33MulFn(a, b, dst)
    {
        var a0  = a[0];
        var a1  = a[1];
        var a2  = a[2];
        var a3  = a[3];
        var a4  = a[4];
        var a5  = a[5];
        var a6  = a[6];
        var a7  = a[7];
        var a8  = a[8];

        var b0  = b[0];
        var b1  = b[1];
        var b2  = b[2];
        var b3  = b[3];
        var b4  = b[4];
        var b5  = b[5];
        var b6  = b[6];
        var b7  = b[7];
        var b8  = b[8];

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }

        dst[0] = (b0 * a0 + b3 * a1 + b6 * a2);
        dst[1] = (b1 * a0 + b4 * a1 + b7 * a2);
        dst[2] = (b2 * a0 + b5 * a1 + b8 * a2);

        dst[3] = (b0 * a3 + b3 * a4 + b6 * a5);
        dst[4] = (b1 * a3 + b4 * a4 + b7 * a5);
        dst[5] = (b2 * a3 + b5 * a4 + b8 * a5);

        dst[6] = (b0 * a6 + b3 * a7 + b6 * a8);
        dst[7] = (b1 * a6 + b4 * a7 + b7 * a8);
        dst[8] = (b2 * a6 + b5 * a7 + b8 * a8);

        return dst;
    },

    m33Transform : function m33TransformFn(m, v)
    {
        var v3ms = VMath.v3ScalarMul;
        return VMath.v3Add3(v3ms(VMath.m33Right(m), v[0]),
                            v3ms(VMath.m33Up(m),    v[1]),
                            v3ms(VMath.m33At(m),    v[2]));
    },

    m33Equal : function m33EqualFn(a, b, precision)
    {
        var abs = Math.abs;
        if (precision === undefined)
        {
            precision = this.precision;
        }
        return (abs(a[0] - b[0]) <= precision &&
                abs(a[1] - b[1]) <= precision &&
                abs(a[2] - b[2]) <= precision &&
                abs(a[3] - b[3]) <= precision &&
                abs(a[4] - b[4]) <= precision &&
                abs(a[5] - b[5]) <= precision &&
                abs(a[6] - b[6]) <= precision &&
                abs(a[7] - b[7]) <= precision &&
                abs(a[8] - b[8]) <= precision);
    },

    m33MulM43 : function m33MulM43Fn(a, b)
    {
        var a0  = a[0];
        var a1  = a[1];
        var a2  = a[2];
        var a3  = a[3];
        var a4  = a[4];
        var a5  = a[5];
        var a6  = a[6];
        var a7  = a[7];
        var a8  = a[8];

        var b0  = b[0];
        var b1  = b[1];
        var b2  = b[2];
        var b3  = b[3];
        var b4  = b[4];
        var b5  = b[5];
        var b6  = b[6];
        var b7  = b[7];
        var b8  = b[8];

        return [
            (b0 * a0 + b3 * a1 + b6 * a2),
            (b1 * a0 + b4 * a1 + b7 * a2),
            (b2 * a0 + b5 * a1 + b8 * a2),

            (b0 * a3 + b3 * a4 + b6 * a5),
            (b1 * a3 + b4 * a4 + b7 * a5),
            (b2 * a3 + b5 * a4 + b8 * a5),

            (b0 * a6 + b3 * a7 + b6 * a8),
            (b1 * a6 + b4 * a7 + b7 * a8),
            (b2 * a6 + b5 * a7 + b8 * a8),

            b[9], b[10], b[11]
        ];
    },

    m33MulM44 : function m33MulM44Fn(a, b)
    {
        var a0  = a[0];
        var a1  = a[1];
        var a2  = a[2];
        var a3  = a[3];
        var a4  = a[4];
        var a5  = a[5];
        var a6  = a[6];
        var a7  = a[7];
        var a8  = a[8];

        var b0  = b[0];
        var b1  = b[1];
        var b2  = b[2];
        var b3  = b[3];
        var b4  = b[4];
        var b5  = b[5];
        var b6  = b[6];
        var b7  = b[7];
        var b8  = b[8];
        var b9  = b[9];
        var b10 = b[10];
        var b11 = b[11];

        return [
                (b0 * a0 + b4 * a1 + b8  * a2),
                (b1 * a0 + b5 * a1 + b9  * a2),
                (b2 * a0 + b6 * a1 + b10 * a2),
                (b3 * a0 + b7 * a1 + b11 * a2),

                (b0 * a3 + b4 * a4 + b8  * a5),
                (b1 * a3 + b5 * a4 + b9  * a5),
                (b2 * a3 + b6 * a4 + b10 * a5),
                (b3 * a3 + b7 * a4 + b11 * a5),

                (b0 * a6 + b4 * a7 + b8  * a8),
                (b1 * a6 + b5 * a7 + b9  * a8),
                (b2 * a6 + b6 * a7 + b10 * a8),
                (b3 * a6 + b7 * a7 + b11 * a8),

                b[12], b[13], b[14], b[15]
            ];
    },

    // Matrix3 operations with scalar
    m33ScalarAdd : function m33ScalarAddFn(m, s)
    {
        var r = new VMathArrayConstructor(9);
        for (var n = 0; n < 9; n += 1)
        {
            r[n] = (m[n] + s);
        }
        return r;
    },

    m33ScalarSub : function m33ScalarSubFn(m, s)
    {
        var r = new VMathArrayConstructor(9);
        for (var n = 0; n < 9; n += 1)
        {
            r[n] = (m[n] - s);
        }
        return r;
    },

    m33ScalarMul : function m33ScalarMulFn(m, s)
    {
        var r = new VMathArrayConstructor(9);
        for (var n = 0; n < 9; n += 1)
        {
            r[n] = (m[n] * s);
        }
        return r;
    },

    // Matrix34
    m34BuildIdentity : function m34BuildIdentityFn()
    {
        return [1.0, 0.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0,
                0.0, 0.0, 1.0, 0.0];
    },

    m34Pos : function m34PosFn(m)
    {
        return [m[3], m[7], m[11]];
    },

    m34Scale : function m34ScaleFn(m, scale)
    {
        m[0] *= scale[0];
        m[1] *= scale[0];
        m[2] *= scale[0];

        m[4] *= scale[1];
        m[5] *= scale[1];
        m[6] *= scale[1];

        m[8] *= scale[2];
        m[9] *= scale[2];
        m[10] *= scale[2];
    },

    // Matrix43
    m43BuildIdentity : function m43BuildIdentityFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }
        dst[0] = 1.0;
        dst[1] = 0.0;
        dst[2] = 0.0;
        dst[3] = 0.0;
        dst[4] = 1.0;
        dst[5] = 0.0;
        dst[6] = 0.0;
        dst[7] = 0.0;
        dst[8] = 1.0;
        dst[9] = 0.0;
        dst[10] = 0.0;
        dst[11] = 0.0;
        return dst;
    },

    m43Build : function m43BuildFn(r, u, a, p, dst)
    {
        var length = arguments.length;
        if (length >= 12)
        {
            // Can NOT use dst because it will overwrite the input value...
            var res;

            if (length > 12)
            {
                res = arguments[12];
                if (res === undefined)
                {
                    res = new VMathArrayConstructor(12);
                }
            }
            else
            {
                res = new VMathArrayConstructor(12);
            }

            res[0] = arguments[0];
            res[1] = arguments[1];
            res[2] = arguments[2];
            res[3] = arguments[3];
            res[4] = arguments[4];
            res[5] = arguments[5];
            res[6] = arguments[6];
            res[7] = arguments[7];
            res[8] = arguments[8];
            res[9] = arguments[9];
            res[10] = arguments[10];
            res[11] = arguments[11];

            return res;
        }
        else
        {
            if (dst === undefined)
            {
                dst = new VMathArrayConstructor(12);
            }

            dst[0] = r[0];
            dst[1] = r[1];
            dst[2] = r[2];
            dst[3] = u[0];
            dst[4] = u[1];
            dst[5] = u[2];
            dst[6] = a[0];
            dst[7] = a[1];
            dst[8] = a[2];
            dst[9] = p[0];
            dst[10] = p[1];
            dst[11] = p[2];

            return dst;
        }
    },

    m43BuildTranslation : function m43BuildTranslationFn(p, dst)
    {
        // Can NOT use p or dst because it will overwrite the input value...
        var res, a;

        var length = arguments.length;
        if (length >= 3)
        {
            a = arguments;
            if (length === 4)
            {
                res = arguments[3];
            }
        }
        else
        {
            a = p;
            res = dst;
        }

        if (res === undefined)
        {
            res = new VMathArrayConstructor(12);
        }

        res[0] = 1;
        res[1] = 0;
        res[2] = 0;
        res[3] = 0;
        res[4] = 1;
        res[5] = 0;
        res[6] = 0;
        res[7] = 0;
        res[8] = 1;
        res[9] = a[0];
        res[10] = a[1];
        res[11] = a[2];

        return res;
    },

    m43Copy : function m43CopyFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] = m[0];
        dst[1] = m[1];
        dst[2] = m[2];
        dst[3] = m[3];
        dst[4] = m[4];
        dst[5] = m[5];
        dst[6] = m[6];
        dst[7] = m[7];
        dst[8] = m[8];
        dst[9] = m[9];
        dst[10] = m[10];
        dst[11] = m[11];

        return dst;
    },

    m43FromM33V3: function m43FromM33V3Fn(m, v)
    {
        return [m[0], m[1], m[2],
                m[3], m[4], m[5],
                m[6], m[7], m[8],
                v[0], v[1], v[2]];
    },

    m43FromAxisRotation : function m43FromAxisRotationFn(axis, angle, dst)
    {
        var s = Math.sin(angle);
        var c = Math.cos(angle);
        var t = 1.0 - c;
        var axisX = axis[0];
        var axisY = axis[1];
        var axisZ = axis[2];
        var tx = t * axisX;
        var ty = t * axisY;
        var tz = t * axisZ;
        var sx = s * axisX;
        var sy = s * axisY;
        var sz = s * axisZ;

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] = tx * axisX + c;
        dst[1] = tx * axisY - sz;
        dst[2] = tx * axisZ + sy;

        dst[3] = ty * axisX + sz;
        dst[4] = ty * axisY + c;
        dst[5] = ty * axisZ - sx;

        dst[6] = tz * axisX - sy;
        dst[7] = tz * axisY + sx;
        dst[8] = tz * axisZ + c;

        dst[9] = 0.0;
        dst[10] = 0.0;
        dst[11] = 0.0;

        return dst;
    },

    m43FromQuatPos : function m43FromQuatPosFn(qp, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var qx = qp[0];
        var qy = qp[1];
        var qz = qp[2];
        var qw = qp[3];
        var px = qp[4];
        var py = qp[5];
        var pz = qp[6];

        var xx = 2.0 * qx * qx;
        var yy = 2.0 * qy * qy;
        var zz = 2.0 * qz * qz;
        var xy = 2.0 * qx * qy;
        var zw = 2.0 * qz * qw;
        var xz = 2.0 * qx * qz;
        var yw = 2.0 * qy * qw;
        var yz = 2.0 * qy * qz;
        var xw = 2.0 * qx * qw;

        dst[0] = 1.0 - yy - zz;
        dst[1] = xy - zw;
        dst[2] = xz + yw;

        dst[3] = xy + zw;
        dst[4] = 1.0 - xx - zz;
        dst[5] = yz - xw;

        dst[6] = xz - yw;
        dst[7] = yz + xw;
        dst[8] = 1.0 - xx - yy;

        dst[9] = px;
        dst[10] = py;
        dst[11] = pz;

        return dst;
    },

    m43FromRTS : function m43FromRTSFn(quat, pos, scale, dst)
    {
        var qx = quat[0];
        var qy = quat[1];
        var qz = quat[2];
        var qw = quat[3];

        var xx = (2.0 * qx * qx);
        var yy = (2.0 * qy * qy);
        var zz = (2.0 * qz * qz);
        var xy = (2.0 * qx * qy);
        var zw = (2.0 * qz * qw);
        var xz = (2.0 * qx * qz);
        var yw = (2.0 * qy * qw);
        var yz = (2.0 * qy * qz);
        var xw = (2.0 * qx * qw);

        var sx = scale[0];
        var sy = scale[1];
        var sz = scale[2];

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] = sx * (1.0 - yy - zz);
        dst[1] = sx * (xy - zw);
        dst[2] = sx * (xz + yw);
        dst[3] = sy * (xy + zw);
        dst[4] = sy * (1.0 - xx - zz);
        dst[5] = sy * (yz - xw);
        dst[6] = sz * (xz - yw);
        dst[7] = sz * (yz + xw);
        dst[8] = sz * (1.0 - xx - yy);
        dst[9]  = pos[0];
        dst[10] = pos[1];
        dst[11] = pos[2];

        return dst;
    },

    m43FromRT : function m43FromRTFn(quat, pos, dst)
    {
        var qx = quat[0];
        var qy = quat[1];
        var qz = quat[2];
        var qw = quat[3];

        var xx = (2.0 * qx * qx);
        var yy = (2.0 * qy * qy);
        var zz = (2.0 * qz * qz);
        var xy = (2.0 * qx * qy);
        var zw = (2.0 * qz * qw);
        var xz = (2.0 * qx * qz);
        var yw = (2.0 * qy * qw);
        var yz = (2.0 * qy * qz);
        var xw = (2.0 * qx * qw);

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] =  1.0 - yy - zz;
        dst[1] =  xy - zw;
        dst[2] =  xz + yw;
        dst[3] =  xy + zw;
        dst[4] =  1.0 - xx - zz;
        dst[5] =  yz - xw;
        dst[6] =  xz - yw;
        dst[7] =  yz + xw;
        dst[8] =  1.0 - xx - yy;
        dst[9]  = pos[0];
        dst[10] = pos[1];
        dst[11] = pos[2];

        return dst;
    },

    m43Right : function m43RightFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = m[0];
        dst[1] = m[1];
        dst[2] = m[2];
        return dst;
    },

    m43Up : function m43UpFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = m[3];
        dst[1] = m[4];
        dst[2] = m[5];
        return dst;
    },

    m43At : function m43AtFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = m[6];
        dst[1] = m[7];
        dst[2] = m[8];
        return dst;
    },

    m43Pos : function m43PosFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = m[9];
        dst[1] = m[10];
        dst[2] = m[11];
        return dst;
    },

    m43SetRight : function m43SetRightFn(m, v)
    {
        m[0] = v[0];
        m[1] = v[1];
        m[2] = v[2];
    },

    m43SetUp : function m43SetUpFn(m, v)
    {
        m[3] = v[0];
        m[4] = v[1];
        m[5] = v[2];
    },

    m43SetAt : function m43SetAtFn(m, v)
    {
        m[6] = v[0];
        m[7] = v[1];
        m[8] = v[2];
    },

    m43SetPos : function m43SetPosFn(m, v)
    {
        m[9] = v[0];
        m[10] = v[1];
        m[11] = v[2];
    },

    m43SetAxisRotation : function m43SetAxisRotationFn(m, axis, angle)
    {
        var s = Math.sin(angle);
        var c = Math.cos(angle);
        var t = 1.0 - c;
        var axisX = axis[0];
        var axisY = axis[1];
        var axisZ = axis[2];
        var tx = t * axisX;
        var ty = t * axisY;
        var tz = t * axisZ;
        var sx = s * axisX;
        var sy = s * axisY;
        var sz = s * axisZ;
        m[0] = tx * axisX + c;
        m[1] = tx * axisY - sz;
        m[2] = tx * axisZ + sy;
        m[3] = ty * axisX + sz;
        m[4] = ty * axisY + c;
        m[5] = ty * axisZ - sx;
        m[6] = tz * axisX - sy;
        m[7] = tz * axisY + sx;
        m[8] = tz * axisZ + c;
    },

    m43InverseOrthonormal : function m43InverseOrthonormalFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var px = m[9];
        var py = m[10];
        var pz = m[11];
        dst[0] = m0;
        dst[1] = m3;
        dst[2] = m6;
        dst[3] = m1;
        dst[4] = m4;
        dst[5] = m7;
        dst[6] = m2;
        dst[7] = m5;
        dst[8] = m8;
        dst[9]  = -((px * m0) + (py * m1) + (pz * m2));
        dst[10] = -((px * m3) + (py * m4) + (pz * m5));
        dst[11] = -((px * m6) + (py * m7) + (pz * m8));
        return dst;
    },

    m43Orthonormalize : function m43OrthonormalizeFn(m, dst)
    {
        var normalize = VMath.v3Normalize;
        var length    = VMath.v3Length;
        var dot       = VMath.v3Dot;
        var cross     = VMath.v3Cross;
        var abs       = Math.abs;

        var right = VMath.m43Right(m);
        var up    = VMath.m43Up(m);
        var at    = VMath.m43At(m);
        var pos   = VMath.m43Pos(m);

        var innerX = length(right);
        var innerY = length(up);
        var innerZ = length(at);

        normalize(right, right);
        normalize(up, up);
        normalize(at, at);

        var vpU, vpV, vpW;
        if (innerX > 0.0)
        {
            if (innerY > 0.0)
            {
                if (innerZ > 0.0)
                {
                    var outerX = abs(dot(up, at));
                    var outerY = abs(dot(at, right));
                    var outerZ = abs(dot(right, up));
                    if (outerX < outerY)
                    {
                        if (outerX < outerZ)
                        {
                            vpU = up;
                            vpV = at;
                            vpW = right;
                        }
                        else
                        {
                            vpU = right;
                            vpV = up;
                            vpW = at;
                        }
                    }
                    else
                    {
                        if (outerY < outerZ)
                        {
                            vpU = at;
                            vpV = right;
                            vpW = up;
                        }
                        else
                        {
                            vpU = right;
                            vpV = up;
                            vpW = at;
                        }
                    }
                }
                else
                {
                    vpU = right;
                    vpV = up;
                    vpW = at;
                }
            }
            else
            {
                vpU = at;
                vpV = right;
                vpW = up;
            }
        }
        else
        {
            vpU = up;
            vpV = at;
            vpW = right;
        }

        cross(vpU, vpV, vpW);
        normalize(vpW, vpW);

        cross(vpW, vpU, vpV);
        normalize(vpV, vpV);

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] = right[0];
        dst[1] = right[1];
        dst[2] = right[2];
        dst[3] = up[0];
        dst[4] = up[1];
        dst[5] = up[2];
        dst[6] = at[0];
        dst[7] = at[1];
        dst[8] = at[2];
        dst[9] = pos[0];
        dst[10] = pos[1];
        dst[11] = pos[2];

        return dst;
    },

    m43Determinant : function m43DeterminantFn(m)
    {
        return (m[0] * (m[4] * m[8] - m[5] * m[7]) +
                m[1] * (m[5] * m[6] - m[3] * m[8]) +
                m[2] * (m[3] * m[7] - m[4] * m[6]));
    },

    m43Inverse : function m43InverseFn(m, dst)
    {
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var m9 = m[9];
        var m10 = m[10];
        var m11 = m[11];

        var det = (m0 * (m4 * m8 - m5 * m7) +
                   m1 * (m5 * m6 - m3 * m8) +
                   m2 * (m3 * m7 - m4 * m6));
        if (det === 0.0)
        {
            return [];
        }
        else
        {
            if (dst === undefined)
            {
                dst = new VMathArrayConstructor(12);
            }
            var detrecp = 1.0 / det;
            dst[0] = ((m4 * m8 + m5 * (-m7)) * detrecp);
            dst[1] = ((m7 * m2 + m8 * (-m1)) * detrecp);
            dst[2] = ((m1 * m5 - m2 *   m4)  * detrecp);
            dst[3] = ((m5 * m6 + m3 * (-m8)) * detrecp);
            dst[4] = ((m8 * m0 + m6 * (-m2)) * detrecp);
            dst[5] = ((m3 * m2 - m0 *   m5)  * detrecp);
            dst[6] = ((m3 * m7 + m4 * (-m6)) * detrecp);
            dst[7] = ((m6 * m1 + m7 * (-m0)) * detrecp);
            dst[8] = ((m0 * m4 - m3 *   m1)  * detrecp);
            dst[9]  = ((m3 * (m10 * m8  - m7 * m11) + m4  * (m6 * m11 - m9 * m8) + m5  * (m9 * m7 - m6 * m10)) * detrecp);
            dst[10] = ((m6 * (m2  * m10 - m1 * m11) + m7  * (m0 * m11 - m9 * m2) + m8  * (m9 * m1 - m0 * m10)) * detrecp);
            dst[11] = ((m9 * (m2  * m4  - m1 * m5)  + m10 * (m0 * m5  - m3 * m2) + m11 * (m3 * m1 - m0 * m4))  * detrecp);
            return dst;
        }
    },

    m43Translate : function m43TranslateFn(matrix, pos)
    {
        matrix[9]  += pos[0];
        matrix[10] += pos[1];
        matrix[11] += pos[2];
    },

    m43Scale : function m43ScaleFn(m, scale, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var sx = scale[0];
        var sy = scale[1];
        var sz = scale[2];

        dst[0] = m[0] * sx;
        dst[1] = m[1] * sx;
        dst[2] = m[2] * sx;
        dst[3] = m[3] * sy;
        dst[4] = m[4] * sy;
        dst[5] = m[5] * sy;
        dst[6] = m[6] * sz;
        dst[7] = m[7] * sz;
        dst[8] = m[8] * sz;
        dst[9] = m[9];
        dst[10] = m[10];
        dst[11] = m[11];

        return dst;
    },

    m43TransformVector : function m43TransformVectorFn(m, v, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        var v0 = v[0];
        var v1 = v[1];
        var v2 = v[2];
        dst[0] = (m[0] * v0 + m[3] * v1 + m[6] * v2);
        dst[1] = (m[1] * v0 + m[4] * v1 + m[7] * v2);
        dst[2] = (m[2] * v0 + m[5] * v1 + m[8] * v2);
        return dst;
    },

    m43TransformPoint : function m43TransformPointFn(m, v, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        var v0 = v[0];
        var v1 = v[1];
        var v2 = v[2];
        dst[0] = (m[0] * v0 + m[3] * v1 + m[6] * v2 + m[9]);
        dst[1] = (m[1] * v0 + m[4] * v1 + m[7] * v2 + m[10]);
        dst[2] = (m[2] * v0 + m[5] * v1 + m[8] * v2 + m[11]);
        return dst;
    },

    m43Mul : function m43MulFn(a, b, dst)
    {
        var a0  = a[0];
        var a1  = a[1];
        var a2  = a[2];
        var a3  = a[3];
        var a4  = a[4];
        var a5  = a[5];
        var a6  = a[6];
        var a7  = a[7];
        var a8  = a[8];
        var a9  = a[9];
        var a10 = a[10];
        var a11 = a[11];

        var b0  = b[0];
        var b1  = b[1];
        var b2  = b[2];
        var b3  = b[3];
        var b4  = b[4];
        var b5  = b[5];
        var b6  = b[6];
        var b7  = b[7];
        var b8  = b[8];

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] =  (b0 * a0 + b3 * a1 + b6 * a2);
        dst[1] =  (b1 * a0 + b4 * a1 + b7 * a2);
        dst[2] =  (b2 * a0 + b5 * a1 + b8 * a2);
        dst[3] =  (b0 * a3 + b3 * a4 + b6 * a5);
        dst[4] =  (b1 * a3 + b4 * a4 + b7 * a5);
        dst[5] =  (b2 * a3 + b5 * a4 + b8 * a5);
        dst[6] =  (b0 * a6 + b3 * a7 + b6 * a8);
        dst[7] =  (b1 * a6 + b4 * a7 + b7 * a8);
        dst[8] =  (b2 * a6 + b5 * a7 + b8 * a8);
        dst[9]  = (b0 * a9 + b3 * a10 + b6 * a11 + b[9]);
        dst[10] = (b1 * a9 + b4 * a10 + b7 * a11 + b[10]);
        dst[11] = (b2 * a9 + b5 * a10 + b8 * a11 + b[11]);

        return dst;
    },

    m43MulM44 : function m43MulM44Fn(a, b, dst)
    {
        var a0  = a[0];
        var a1  = a[1];
        var a2  = a[2];
        var a3  = a[3];
        var a4  = a[4];
        var a5  = a[5];
        var a6  = a[6];
        var a7  = a[7];
        var a8  = a[8];
        var a9  = a[9];
        var a10 = a[10];
        var a11 = a[11];

        var b0  = b[0];
        var b1  = b[1];
        var b2  = b[2];
        var b3  = b[3];
        var b4  = b[4];
        var b5  = b[5];
        var b6  = b[6];
        var b7  = b[7];
        var b8  = b[8];
        var b9  = b[9];
        var b10 = b[10];
        var b11 = b[11];

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }

        dst[0] =  (b0 * a0 + b4 * a1 + b8  * a2);
        dst[1] =  (b1 * a0 + b5 * a1 + b9  * a2);
        dst[2] =  (b2 * a0 + b6 * a1 + b10 * a2);
        dst[3] =  (b3 * a0 + b7 * a1 + b11 * a2);
        dst[4] =  (b0 * a3 + b4 * a4 + b8  * a5);
        dst[5] =  (b1 * a3 + b5 * a4 + b9  * a5);
        dst[6] =  (b2 * a3 + b6 * a4 + b10 * a5);
        dst[7] =  (b3 * a3 + b7 * a4 + b11 * a5);
        dst[8] =  (b0 * a6 + b4 * a7 + b8  * a8);
        dst[9]  = (b1 * a6 + b5 * a7 + b9  * a8);
        dst[10] = (b2 * a6 + b6 * a7 + b10 * a8);
        dst[11] = (b3 * a6 + b7 * a7 + b11 * a8);
        dst[12] = (b0 * a9 + b4 * a10 + b8  * a11 + b[12]);
        dst[13] = (b1 * a9 + b5 * a10 + b9  * a11 + b[13]);
        dst[14] = (b2 * a9 + b6 * a10 + b10 * a11 + b[14]);
        dst[15] = (b3 * a9 + b7 * a10 + b11 * a11 + b[15]);

        return dst;
    },

    m43Transpose : function m43TransposeFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var m9 = m[9];
        var m10 = m[10];
        var m11 = m[11];

        dst[0] =  m0;
        dst[1] =  m3;
        dst[2] =  m6;
        dst[3] =  m9;
        dst[4] =  m1;
        dst[5] =  m4;
        dst[6] =  m7;
        dst[7] =  m10;
        dst[8] =  m2;
        dst[9]  = m5;
        dst[10] = m8;
        dst[11] = m11;

        return dst;
    },

    m43MulTranspose: function m43MulTransposeFn(a, b, dst)
    {
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var a3 = a[3];
        var a4 = a[4];
        var a5 = a[5];
        var a6 = a[6];
        var a7 = a[7];
        var a8 = a[8];
        var a9 = a[9];
        var a10 = a[10];
        var a11 = a[11];

        var b0 = b[0];
        var b1 = b[1];
        var b2 = b[2];
        var b3 = b[3];
        var b4 = b[4];
        var b5 = b[5];
        var b6 = b[6];
        var b7 = b[7];
        var b8 = b[8];
        var b9 = b[9];
        var b10 = b[10];
        var b11 = b[11];

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] =  (b0 * a0 + b3 * a1 + b6 * a2);
        dst[1] =  (b0 * a3 + b3 * a4 + b6 * a5);
        dst[2] =  (b0 * a6 + b3 * a7 + b6 * a8);
        dst[3] =  (b0 * a9 + b3 * a10 + b6 * a11 + b9);
        dst[4] =  (b1 * a0 + b4 * a1 + b7 * a2);
        dst[5] =  (b1 * a3 + b4 * a4 + b7 * a5);
        dst[6] =  (b1 * a6 + b4 * a7 + b7 * a8);
        dst[7] =  (b1 * a9 + b4 * a10 + b7 * a11 + b10);
        dst[8] =  (b2 * a0 + b5 * a1 + b8 * a2);
        dst[9]  = (b2 * a3 + b5 * a4 + b8 * a5);
        dst[10] = (b2 * a6 + b5 * a7 + b8 * a8);
        dst[11] = (b2 * a9 + b5 * a10 + b8 * a11 + b11);

        return dst;
    },

    m43Offset: function m43OffsetFn(m, o, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var m9 = m[9];
        var m10 = m[10];
        var m11 = m[11];

        var o0 = o[0];
        var o1 = o[1];
        var o2 = o[2];

        dst[0] =  m0;
        dst[1] =  m1;
        dst[2] =  m2;
        dst[3] =  m3;
        dst[4] =  m4;
        dst[5] =  m5;
        dst[6] =  m6;
        dst[7] =  m7;
        dst[8] =  m8;
        dst[9]  = (m0 * o0 + m3 * o1 + m6 * o2 + m9);
        dst[10] = (m1 * o0 + m4 * o1 + m7 * o2 + m10);
        dst[11] = (m2 * o0 + m5 * o1 + m8 * o2 + m11);

        return dst;
    },

    m43NegOffset: function m43NegOffsetFn(m, o, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var m9 = m[9];
        var m10 = m[10];
        var m11 = m[11];

        var o0 = -o[0];
        var o1 = -o[1];
        var o2 = -o[2];

        dst[0] =  m0;
        dst[1] =  m1;
        dst[2] =  m2;
        dst[3] =  m3;
        dst[4] =  m4;
        dst[5] =  m5;
        dst[6] =  m6;
        dst[7] =  m7;
        dst[8] =  m8;
        dst[9]  = (m0 * o0 + m3 * o1 + m6 * o2 + m9);
        dst[10] = (m1 * o0 + m4 * o1 + m7 * o2 + m10);
        dst[11] = (m2 * o0 + m5 * o1 + m8 * o2 + m11);

        return dst;
    },

    m43InverseTransposeProjection: function m43InverseTransposeProjectionFn(m, s, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var xf = (0.5 / s[0]);
        var yf = (0.5 / s[1]);
        var zf = (0.5 / s[2]);
        var m0 = (m[0] * xf);
        var m1 = (m[1] * xf);
        var m2 = (m[2] * xf);
        var m3 = (m[3] * yf);
        var m4 = (m[4] * yf);
        var m5 = (m[5] * yf);
        var m6 = (m[6] * zf);
        var m7 = (m[7] * zf);
        var m8 = (m[8] * zf);
        var px = m[9];
        var py = m[10];
        var pz = m[11];

        dst[0] =  m0;
        dst[1] =  m1;
        dst[2] =  m2;
        dst[3] =  (0.5 - ((px * m0) + (py * m1) + (pz * m2)));
        dst[4] =  m3;
        dst[5] =  m4;
        dst[6] =  m5;
        dst[7] =  (0.5 - ((px * m3) + (py * m4) + (pz * m5)));
        dst[8] =  m6;
        dst[9]  = m7;
        dst[10] = m8;
        dst[11] = (0.5 - ((px * m6) + (py * m7) + (pz * m8)));

        return dst;
    },

    // Matrix 43 opeations with scalar
    m43ScalarAdd : function m43ScalarAddFn(m, s)
    {
        var r = new VMathArrayConstructor(12);
        for (var n = 0; n < 12; n += 1)
        {
            r[n] = (m[n] + s);
        }
        return r;
    },

    m43ScalarSub : function m43ScalarSubFn(m, s)
    {
        var r = new VMathArrayConstructor(12);
        for (var n = 0; n < 12; n += 1)
        {
            r[n] = (m[n] - s);
        }
        return r;
    },

    m43ScalarMul : function m43ScalarMulFn(m, s)
    {
        var r = new VMathArrayConstructor(12);
        for (var n = 0; n < 12; n += 1)
        {
            r[n] = (m[n] * s);
        }
        return r;
    },

    // Matrix44
    m44BuildIdentity : function m44BuildIdentityFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }

        dst[0] =  1.0;
        dst[1] =  0.0;
        dst[2] =  0.0;
        dst[3] =  0.0;
        dst[4] =  0.0;
        dst[5] =  1.0;
        dst[6] =  0.0;
        dst[7] =  0.0;
        dst[8] =  0.0;
        dst[9] =  0.0;
        dst[10] = 1.0;
        dst[11] = 0.0;
        dst[12] = 0.0;
        dst[13] = 0.0;
        dst[14] = 0.0;
        dst[15] = 1.0;

        return dst;
    },

    m44Build : function m44BuildFn(r, u, a, p, dst)
    {
        var length = arguments.length;
        if (length >= 16)
        {
            // Can NOT use dst because it will overwrite the input value...
            var res;

            if (length > 16)
            {
                res = arguments[16];
                if (res === undefined)
                {
                    res = new VMathArrayConstructor(16);
                }
            }
            else
            {
                res = new VMathArrayConstructor(16);
            }

            res[0] =  arguments[0];
            res[1] =  arguments[1];
            res[2] =  arguments[2];
            res[3] =  arguments[3];
            res[4] =  arguments[4];
            res[5] =  arguments[5];
            res[6] =  arguments[6];
            res[7] =  arguments[7];
            res[8] =  arguments[8];
            res[9] =  arguments[9];
            res[10] = arguments[10];
            res[11] = arguments[11];
            res[12] = arguments[12];
            res[13] = arguments[13];
            res[14] = arguments[14];
            res[15] = arguments[15];

            return res;
        }
        else
        {
            if (dst === undefined)
            {
                dst = new VMathArrayConstructor(16);
            }

            dst[0] =  r[0];
            dst[1] =  r[1];
            dst[2] =  r[2];
            dst[3] =  r[3];
            dst[4] =  u[0];
            dst[5] =  u[1];
            dst[6] =  u[2];
            dst[7] =  u[3];
            dst[8] =  a[0];
            dst[9] =  a[1];
            dst[10] = a[2];
            dst[11] = a[3];
            dst[12] = p[0];
            dst[13] = p[1];
            dst[14] = p[2];
            dst[15] = p[3];

            return dst;
        }
    },

    m44Copy : function m44CopyFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }

        dst[0] =  m[0];
        dst[1] =  m[1];
        dst[2] =  m[2];
        dst[3] =  m[3];
        dst[4] =  m[4];
        dst[5] =  m[5];
        dst[6] =  m[6];
        dst[7] =  m[7];
        dst[8] =  m[8];
        dst[9] =  m[9];
        dst[10] = m[10];
        dst[11] = m[11];
        dst[12] = m[12];
        dst[13] = m[13];
        dst[14] = m[14];
        dst[15] = m[15];

        return dst;
    },

    m44Right : function m44RightFn(m)
    {
        return [m[0], m[1], m[2], m[3]];
    },

    m44Up : function m44UpFn(m)
    {
        return [m[4], m[5], m[6], m[7]];
    },

    m44At : function m44AtFn(m)
    {
        return [m[8], m[9], m[10], m[11]];
    },

    m44Pos : function m44PosFn(m)
    {
        return [m[12], m[13], m[14], m[15]];
    },

    m44SetRight : function m44SetRightFn(m, v)
    {
        m[0] = v[0];
        m[1] = v[1];
        m[2] = v[2];
        m[3] = v[3];
    },

    m44SetUp : function m44SetUpFn(m, v)
    {
        m[4] = v[0];
        m[5] = v[1];
        m[6] = v[2];
        m[7] = v[3];
    },

    m44SetAt : function m44SetAtFn(m, v)
    {
        m[8] = v[0];
        m[9] = v[1];
        m[10] = v[2];
        m[11] = v[3];
    },

    m44SetPos : function m44SetPosFn(m, v)
    {
        m[12] = v[0];
        m[13] = v[1];
        m[14] = v[2];
        m[15] = v[3];
    },

    m44Translate : function m44TranslateFn(m, v)
    {
        m[12] += v[0];
        m[13] += v[1];
        m[14] += v[2];
        m[15] += v[3];
    },

    m44Scale : function m43ScaleFn(m, scale)
    {
        var r = new VMathArrayConstructor(16);

        /*jslint white: false */
        r[0] =  m[0]  * scale[0];
        r[1] =  m[1]  * scale[0];
        r[2] =  m[2]  * scale[0];
        r[3] =  m[3];
        r[4] =  m[4]  * scale[1];
        r[5] =  m[5]  * scale[1];
        r[6] =  m[6]  * scale[1];
        r[7] =  m[7];
        r[8] =  m[8]  * scale[2];
        r[9] =  m[9]  * scale[2];
        r[10] = m[10] * scale[2];
        r[11] = m[11];
        r[12] = m[12];
        r[13] = m[13];
        r[14] = m[14];
        r[15] = m[15];
        /*jslint white: true */

        return r;
    },

    m44Transform : function m44TransformFn(m, v, dst)
    {
        var v0 = v[0];
        var v1 = v[1];
        var v2 = v[2];
        var v3 = v[3];
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        if (v3 !== 1.0)
        {
            dst[0] = ((m[0] * v0) + (m[4] * v1) + (m[8]  * v2) + (m[12] * v3));
            dst[1] = ((m[1] * v0) + (m[5] * v1) + (m[9]  * v2) + (m[13] * v3));
            dst[2] = ((m[2] * v0) + (m[6] * v1) + (m[10] * v2) + (m[14] * v3));
            dst[3] = ((m[3] * v0) + (m[7] * v1) + (m[11] * v2) + (m[15] * v3));
        }
        else
        {
            dst[0] = ((m[0] * v0) + (m[4] * v1) + (m[8]  * v2) + m[12]);
            dst[1] = ((m[1] * v0) + (m[5] * v1) + (m[9]  * v2) + m[13]);
            dst[2] = ((m[2] * v0) + (m[6] * v1) + (m[10] * v2) + m[14]);
            dst[3] = ((m[3] * v0) + (m[7] * v1) + (m[11] * v2) + m[15]);
        }
        return dst;
    },

    m44Mul : function m44MulFn(a, b, dst)
    {
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var a3 = a[3];
        var a4 = a[4];
        var a5 = a[5];
        var a6 = a[6];
        var a7 = a[7];
        var a8 = a[8];
        var a9 = a[9];
        var a10 = a[10];
        var a11 = a[11];
        var a12 = a[12];
        var a13 = a[13];
        var a14 = a[14];
        var a15 = a[15];

        var b0 = b[0];
        var b1 = b[1];
        var b2 = b[2];
        var b3 = b[3];
        var b4 = b[4];
        var b5 = b[5];
        var b6 = b[6];
        var b7 = b[7];
        var b8 = b[8];
        var b9 = b[9];
        var b10 = b[10];
        var b11 = b[11];
        var b12 = b[12];
        var b13 = b[13];
        var b14 = b[14];
        var b15 = b[15];

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }

        dst[0] = (b0 * a0  + b4 * a1  + b8  * a2  + b12 * a3);
        dst[1] = (b1 * a0  + b5 * a1  + b9  * a2  + b13 * a3);
        dst[2] = (b2 * a0  + b6 * a1  + b10 * a2  + b14 * a3);
        dst[3] = (b3 * a0  + b7 * a1  + b11 * a2  + b15 * a3);
        dst[4] = (b0 * a4  + b4 * a5  + b8  * a6  + b12 * a7);
        dst[5] = (b1 * a4  + b5 * a5  + b9  * a6  + b13 * a7);
        dst[6] = (b2 * a4  + b6 * a5  + b10 * a6  + b14 * a7);
        dst[7] = (b3 * a4  + b7 * a5  + b11 * a6  + b15 * a7);
        dst[8] = (b0 * a8  + b4 * a9  + b8  * a10 + b12 * a11);
        dst[9] = (b1 * a8  + b5 * a9  + b9  * a10 + b13 * a11);
        dst[10] = (b2 * a8  + b6 * a9  + b10 * a10 + b14 * a11);
        dst[11] = (b3 * a8  + b7 * a9  + b11 * a10 + b15 * a11);
        dst[12] = (b0 * a12 + b4 * a13 + b8  * a14 + b12 * a15);
        dst[13] = (b1 * a12 + b5 * a13 + b9  * a14 + b13 * a15);
        dst[14] = (b2 * a12 + b6 * a13 + b10 * a14 + b14 * a15);
        dst[15] = (b3 * a12 + b7 * a13 + b11 * a14 + b15 * a15);

        return dst;
    },

    m44Inverse : function m44InverseFn(m, dst)
    {
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var m9 = m[9];
        var m10 = m[10];
        var m11 = m[11];
        var m12 = m[12];
        var m13 = m[13];
        var m14 = m[14];
        var m15 = m[15];

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }

        /*jslint white: false */
        var A0 = (( m0 *  m5) - ( m1 *  m4));
        var A1 = (( m0 *  m6) - ( m2 *  m4));
        var A2 = (( m0 *  m7) - ( m3 *  m4));
        var A3 = (( m1 *  m6) - ( m2 *  m5));
        var A4 = (( m1 *  m7) - ( m3 *  m5));
        var A5 = (( m2 *  m7) - ( m3 *  m6));
        var B0 = (( m8 * m13) - ( m9 * m12));
        var B1 = (( m8 * m14) - (m10 * m12));
        var B2 = (( m8 * m15) - (m11 * m12));
        var B3 = (( m9 * m14) - (m10 * m13));
        var B4 = (( m9 * m15) - (m11 * m13));
        var B5 = ((m10 * m15) - (m11 * m14));
        /*jslint white: true */

        var det = ((A0 * B5) - (A1 * B4) + (A2 * B3) + (A3 * B2) - (A4 * B1) + (A5 * B0));
        if (det === 0.0)
        {
            /*jslint white: false */
            dst[ 0] = 0.0;
            dst[ 1] = 0.0;
            dst[ 2] = 0.0;
            dst[ 3] = 0.0;
            dst[ 4] = 0.0;
            dst[ 5] = 0.0;
            dst[ 6] = 0.0;
            dst[ 7] = 0.0;
            dst[ 8] = 0.0;
            dst[ 9] = 0.0;
            dst[10] = 0.0;
            dst[11] = 0.0;
            dst[12] = 0.0;
            dst[13] = 0.0;
            dst[14] = 0.0;
            dst[15] = 0.0;
            /*jslint white: true */
        }
        else
        {
            var detrecp = 1.0 / det;
            /*jslint white: false */
            dst[ 0] = (+ ( m5 * B5) - ( m6 * B4) + ( m7 * B3)) * detrecp;
            dst[ 4] = (- ( m4 * B5) + ( m6 * B2) - ( m7 * B1)) * detrecp;
            dst[ 8] = (+ ( m4 * B4) - ( m5 * B2) + ( m7 * B0)) * detrecp;
            dst[12] = (- ( m4 * B3) + ( m5 * B1) - ( m6 * B0)) * detrecp;
            dst[ 1] = (- ( m1 * B5) + ( m2 * B4) - ( m3 * B3)) * detrecp;
            dst[ 5] = (+ ( m0 * B5) - ( m2 * B2) + ( m3 * B1)) * detrecp;
            dst[ 9] = (- ( m0 * B4) + ( m1 * B2) - ( m3 * B0)) * detrecp;
            dst[13] = (+ ( m0 * B3) - ( m1 * B1) + ( m2 * B0)) * detrecp;
            dst[ 2] = (+ (m13 * A5) - (m14 * A4) + (m15 * A3)) * detrecp;
            dst[ 6] = (- (m12 * A5) + (m14 * A2) - (m15 * A1)) * detrecp;
            dst[10] = (+ (m12 * A4) - (m13 * A2) + (m15 * A0)) * detrecp;
            dst[14] = (- (m12 * A3) + (m13 * A1) - (m14 * A0)) * detrecp;
            dst[ 3] = (- ( m9 * A5) + (m10 * A4) - (m11 * A3)) * detrecp;
            dst[ 7] = (+ ( m8 * A5) - (m10 * A2) + (m11 * A1)) * detrecp;
            dst[11] = (- ( m8 * A4) + ( m9 * A2) - (m11 * A0)) * detrecp;
            dst[15] = (+ ( m8 * A3) - ( m9 * A1) + (m10 * A0)) * detrecp;
            /*jsline white: true */
        }

        return dst;
    },

    m44Transpose : function m44TransposeFn(m)
    {
        return [m[0], m[4], m[8],  m[12],
                m[1], m[5], m[9],  m[13],
                m[2], m[6], m[10], m[14],
                m[3], m[7], m[11], m[15]];
    },

    // Matrix44 operations with scalars
    m44ScalarAdd : function m44ScalarAddFn(m, s)
    {
        var r = new VMathArrayConstructor(16);
        for (var n = 0; n < 16; n += 1)
        {
            r[n] = (m[n] + s);
        }
        return r;
    },

    m44ScalarSub : function m44ScalarSubFn(m, s)
    {
        var r = new VMathArrayConstructor(16);
        for (var n = 0; n < 16; n += 1)
        {
            r[n] = (m[n] - s);
        }
        return r;
    },

    m44ScalarMul : function m44ScalarMulFn(m, s)
    {
        var r = new VMathArrayConstructor(16);
        for (var n = 0; n < 16; n += 1)
        {
            r[n] = (m[n] * s);
        }
        return r;
    },

    // Quaternion
    quatBuild : function quatBuildFn(x, y, z, w, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = x;
        dst[1] = y;
        dst[2] = z;
        dst[3] = w;
        return dst;
    },

    quatCopy : function quatCopyFn(src, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = src[0];
        dst[1] = src[1];
        dst[2] = src[2];
        dst[3] = src[3];
        return dst;
    },

    quatIsSimilar : function quatIsSimilarFn(q1, q2, precision)
    {
        if (precision === undefined)
        {
            precision = this.precision;
        }
        // this compares for similar rotations not raw data
        var q1temp = q1;

        if (q1[3] * q2[3] < 0.0)
        {
            // quaternions in opposing hemispheres, negate one
            q1temp = VMath.v4Mul([-1, -1, -1, -1], q1);
        }

        var mag_sqrd = VMath.v4LengthSq(VMath.v4Sub(q1temp, q2));
        var epsilon_sqrd = (precision * precision);
        return mag_sqrd < epsilon_sqrd;
    },

    quatLength : function quatLengthFn(q)
    {
        return VMath.v4Length(q);
    },

    quatDot : function quatDotFn(q1, q2)
    {
        return VMath.v4Dot(q1, q2);
    },

    quatMul : function quatMulFn(q1, q2, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        // Note quaternion multiplication is the opposite way around from our matrix multiplication
        //var v1 = q1; // use full quats to avoid copy
        //var v2 = q2;

        /*
        // Calculate the imaginary part
        var quat = VMath.v3Add3(VMath.v3ScalarMul(v2, q1[3]), VMath.v3ScalarMul(v1, q2[3]), VMath.v3Cross(v1, v2));
        // And extend with the real part
        quat[3] = (q1[3] * q2[3]) - VMath.v3Dot(v1, v2);
        */

        // Inlined from above
        var q2x = q1[0];
        var q2y = q1[1];
        var q2z = q1[2];
        var q2w = q1[3];
        var q1x = q2[0];
        var q1y = q2[1];
        var q1z = q2[2];
        var q1w = q2[3];

        var cx = (q1z * q2y) - (q1y * q2z);
        var cy = (q1x * q2z) - (q1z * q2x);
        var cz = (q1y * q2x) - (q1x * q2y);

        dst[0] = (q2x * q1w) + (q1x * q2w) + cx;
        dst[1] = (q2y * q1w) + (q1y * q2w) + cy;
        dst[2] = (q2z * q1w) + (q1z * q2w) + cz;
        dst[3] = (q1w * q2w) - (q1x * q2x + q1y * q2y + q1z * q2z);

        return dst;
    },

    quatMulTranslate : function quatMulTranslateFn(qa, va, qb, vb, qr, vr)
    {
        var qax = qa[0];
        var qay = qa[1];
        var qaz = qa[2];
        var qaw = qa[3];
        var qbx = qb[0];
        var qby = qb[1];
        var qbz = qb[2];
        var qbw = qb[3];

        // Multiply together the two quaternions
        var cx = (qaz * qby) - (qay * qbz);
        var cy = (qax * qbz) - (qaz * qbx);
        var cz = (qay * qbx) - (qax * qby);
        qr[0] = (qbx * qaw) + (qax * qbw) + cx;
        qr[1] = (qby * qaw) + (qay * qbw) + cy;
        qr[2] = (qbz * qaw) + (qaz * qbw) + cz;
        qr[3] = (qaw * qbw) - (qax * qbx + qay * qby + qaz * qbz);

        // Transform the 2nd vector by the first quaternion and add in the first position
        var vax = va[0];
        var vay = va[1];
        var vaz = va[2];
        var vbx = vb[0];
        var vby = vb[1];
        var vbz = vb[2];

        var s = (qaw * qaw) - (qax * qax + qay * qay + qaz * qaz);
        var rx = vbx * s;
        var ry = vby * s;
        var rz = vbz * s;

        s = qax * vbx + qay * vby + qaz * vbz;

        var twoS = s + s;
        rx += qax * twoS;
        ry += qay * twoS;
        rz += qaz * twoS;

        cx = (qaz * vby) - (qay * vbz);
        cy = (qax * vbz) - (qaz * vbx);
        cz = (qay * vbx) - (qax * vby);
        var twoQw = qaw + qaw;
        rx += cx * twoQw;
        ry += cy * twoQw;
        rz += cz * twoQw;

        vr[0] = rx + vax;
        vr[1] = ry + vay;
        vr[2] = rz + vaz;
    },

    quatNormalize : function quatNormalizeFn(q, dst)
    {
        var norme = VMath.quatDot(q, q);
        if (norme === 0.0)
        {
            return VMath.v4BuildZero(dst);
        }
        else
        {
            var recip = 1.0 / Math.sqrt(norme);
            return VMath.v4ScalarMul(q, recip, dst);
        }
    },

    quatConjugate : function quatConjugateFn(q, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = -q[0];
        dst[1] = -q[1];
        dst[2] = -q[2];
        dst[3] =  q[3];

        return dst;
    },

    quatLerp : function quatLerpFn(q1, q2, t)
    {
        var q1x = q1[0];
        var q1y = q1[1];
        var q1z = q1[2];
        var q1w = q1[3];
        var q2x = q2[0];
        var q2y = q2[1];
        var q2z = q2[2];
        var q2w = q2[3];

        var qrx = ((q2x - q1x) * t) + q1x;
        var qry = ((q2y - q1y) * t) + q1y;
        var qrz = ((q2z - q1z) * t) + q1z;
        var qrw = ((q2w - q1w) * t) + q1w;

        return [qrx, qry, qrz, qrw];
    },

    cosMinSlerpAngle : Math.cos(Math.PI / 40.0), // use a lerp for angles <= 4.5 degrees

    quatSlerp : function quatSlerpFn(q1, q2, t, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        var q1x = q1[0];
        var q1y = q1[1];
        var q1z = q1[2];
        var q1w = q1[3];
        var q2x = q2[0];
        var q2y = q2[1];
        var q2z = q2[2];
        var q2w = q2[3];
        var dotq1q2 = (q1x * q2x) + (q1y * q2y) + (q1z * q2z) + (q1w * q2w);

        var cosom = dotq1q2;
        if (cosom < 0.0)
        {
            q1x = -q1x;
            q1y = -q1y;
            q1z = -q1z;
            q1w = -q1w;
            cosom = -cosom;
        }

        if (cosom > VMath.cosMinSlerpAngle)
        {
            var delta = t;
            if (dotq1q2 <= 0.0)
            {
                delta = -t;
            }

            var qrx = ((q2x - q1x) * delta) + q1x;
            var qry = ((q2y - q1y) * delta) + q1y;
            var qrz = ((q2z - q1z) * delta) + q1z;
            var qrw = ((q2w - q1w) * delta) + q1w;

            var mag = Math.sqrt((qrx * qrx) + (qry * qry) + (qrz * qrz) + (qrw * qrw));
            var recip = 1.0 / mag;

            dst[0] =  qrx * recip;
            dst[1] =  qry * recip;
            dst[2] =  qrz * recip;
            dst[3] =  qrw * recip;

            return dst;
        }

        var sinFn = Math.sin;
        var omega = Math.acos(cosom);
        var inv_sin_omega = 1.0 / sinFn(omega);

        var scalar = sinFn((1.0 - t) * omega) * inv_sin_omega;
        q1x = q1x * scalar;
        q1y = q1y * scalar;
        q1z = q1z * scalar;
        q1w = q1w * scalar;

        scalar = sinFn(t * omega) * inv_sin_omega;
        q2x = q2x * scalar;
        q2y = q2y * scalar;
        q2z = q2z * scalar;
        q2w = q2w * scalar;

        dst[0] =  q1x + q2x;
        dst[1] =  q1y + q2y;
        dst[2] =  q1z + q2z;
        dst[3] =  q1w + q2w;

        return dst;
    },

    quatFromM43 : function quatFromM43Fn(m, dst)
    {
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];

        var x, y, z, w, s;
        var trace = m0 + m4 + m8 + 1;
        if (trace > VMath.precision)
        {
            w = Math.sqrt(trace) / 2;
            x = (m5 - m7) / (4 * w);
            y = (m6 - m2) / (4 * w);
            z = (m1 - m3) / (4 * w);
        }
        else
        {
            if ((m0 > m4) && (m0 > m8))
            {
                s = Math.sqrt(1.0 + m0 - m4 - m8) * 2; // S=4*qx
                w = (m5 - m7) / s;
                x = 0.25 * s;
                y = (m3 + m1) / s;
                z = (m6 + m2) / s;
            }
            else if (m4 > m8)
            {
                s = Math.sqrt(1.0 + m4 - m0 - m8) * 2; // S=4*qy
                w = (m6 - m2) / s;
                x = (m3 + m1) / s;
                y = 0.25 * s;
                z = (m7 + m5) / s;
            }
            else
            {
                s = Math.sqrt(1.0 + m8 - m0 - m4) * 2; // S=4*qz
                w = (m1 - m3) / s;
                x = (m6 + m2) / s;
                y = (m7 + m5) / s;
                z = 0.25 * s;
            }
        }

        var q = VMath.quatNormalize([x, y, z, w], dst);

        return VMath.quatConjugate(q, dst);
    },

    quatFromAxisRotation : function quatFromAxisRotationFn(axis, angle, dst)
    {
        var omega = 0.5 * angle;
        var s = Math.sin(omega);
        var c = Math.cos(omega);

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = axis[0] * s;
        dst[1] = axis[1] * s;
        dst[2] = axis[2] * s;
        dst[3] = c;

        return VMath.quatNormalize(dst, dst);
    },

    quatToAxisRotation : function quatToAxisRotation(q)
    {
        var angle = Math.acos(q[3]) * 2.0;

        var sin_sqrd = 1.0 - q[3] * q[3];

        if (sin_sqrd < VMath.precision)
        {
            // we can return any axis
            return [1.0, 0.0, 0.0, angle];
        }
        else
        {
            var scale = 1.0 / Math.sqrt(sin_sqrd);
            return [q[0] * scale, q[1] * scale, q[2] * scale, angle];
        }
    },

    quatTransformVector : function quatTransformVectorFn(q, v, dst)
    {
        /*
        var qimaginary = q; // Use full quat directly to avoid copy
        var qw = q[3];

        var s = (qw * qw) - VMath.v3Dot(qimaginary, qimaginary);

        var r = VMath.v3ScalarMul(v, s);

        s = VMath.v3Dot(qimaginary, v);
        r = VMath.v3Add(r, VMath.v3ScalarMul(qimaginary, s + s));
        r = VMath.v3Add(r, VMath.v3ScalarMul(VMath.v3Cross(qimaginary, v), qw + qw));
        */

        // Inlined from above
        var qx = q[0];
        var qy = q[1];
        var qz = q[2];
        var qw = q[3];

        var vx = v[0];
        var vy = v[1];
        var vz = v[2];

        //var s = (qw * qw) - VMath.v3Dot(qimaginary, qimaginary);
        var s = (qw * qw) - (qx * qx + qy * qy + qz * qz);

        //var r = VMath.v3ScalarMul(v, s);
        var rx = vx * s;
        var ry = vy * s;
        var rz = vz * s;

        //s = VMath.v3Dot(qimaginary, v);
        s = qx * vx + qy * vy + qz * vz;

        //r = VMath.v3Add(r, VMath.v3ScalarMul(qimaginary, s + s));
        var twoS = s + s;
        rx += qx * twoS;
        ry += qy * twoS;
        rz += qz * twoS;

        //r = VMath.v3Add(r, VMath.v3ScalarMul(VMath.v3Cross(VMath.v3Neg(qimaginary), v), qw + qw));
        var cx = (qz * vy) - (qy * vz);
        var cy = (qx * vz) - (qz * vx);
        var cz = (qy * vx) - (qx * vy);
        var twoQw = qw + qw;
        rx += cx * twoQw;
        ry += cy * twoQw;
        rz += cz * twoQw;

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = rx;
        dst[1] = ry;
        dst[2] = rz;

        return dst;
    },

    quatEqual : function quatEqual(q1, q2, precision)
    {
        if (precision === undefined)
        {
            precision = this.precision;
        }
        var abs = Math.abs;
        return (abs(q1[0] - q2[0]) <= precision &&
                abs(q1[1] - q2[1]) <= precision &&
                abs(q1[2] - q2[2]) <= precision &&
                abs(q1[3] - q2[3]) <= precision);
    },

    // quatPos
    quatPosBuild : function quatPosBuildFn(x, y, z, w, px, py, pz, dst)
    {
        if (arguments.length < 7)
        {
            if (z === undefined)
            {
                z = new VMathArrayConstructor(7);
            }
            z[0] = x[0];
            z[1] = x[1];
            z[2] = x[2];
            z[3] = x[3];
            z[4] = y[0];
            z[5] = y[1];
            z[6] = y[2];
            return z;
        }
        else
        {
            if (dst === undefined)
            {
                dst = new VMathArrayConstructor(7);
            }
            dst[0] = x;
            dst[1] = y;
            dst[2] = z;
            dst[3] = w;
            dst[4] = px;
            dst[5] = py;
            dst[6] = pz;
            return dst;
        }
    },

    quatPosTransformVector : function quatPosTransformVectorFn(qp, n)
    {
        return VMath.quatTransformVector(qp, n);
    },

    quatPosTransformPoint : function quatPosTransformPointFn(qp, p)
    {
        var offset = qp.slice(4, 7);

        var rotatedp = VMath.quatTransformVector(qp, p);
        return VMath.v3Add(rotatedp, offset);
    },

    quatPosMul : function quatPosMulFn(qp1, qp2)
    {
        var v2 = qp2.slice(4, 7);

        var qr = VMath.quatMul(qp1, qp2);
        var pr = VMath.quatPosTransformPoint(qp1, v2);
        qr[4] = pr[0];
        qr[5] = pr[1];
        qr[6] = pr[2];

        return qr;
    },

    //
    // Visibility queries
    //
    isVisibleBox : function isVisibleBoxFn(center, halfDimensions, vpm)
    {
        var abs = Math.abs;

        var c0 = center[0];
        var c1 = center[1];
        var c2 = center[2];

        var h0 = halfDimensions[0];
        var h1 = halfDimensions[1];
        var h2 = halfDimensions[2];

        var m0  = vpm[0];
        var m1  = vpm[1];
        var m2  = vpm[2];
        var m3  = vpm[3];
        var m4  = vpm[4];
        var m5  = vpm[5];
        var m6  = vpm[6];
        var m7  = vpm[7];
        var m8  = vpm[8];
        var m9  = vpm[9];
        var m10 = vpm[10];
        var m11 = vpm[11];

        var I0 = (m0  * h0);
        var I1 = (m1  * h0);
        var I2 = (m2  * h0);
        var I3 = (m3  * h0);
        var J0 = (m4  * h1);
        var J1 = (m5  * h1);
        var J2 = (m6  * h1);
        var J3 = (m7  * h1);
        var K0 = (m8  * h2);
        var K1 = (m9  * h2);
        var K2 = (m10 * h2);
        var K3 = (m11 * h2);

        var T0 = (m0 * c0 + m4 * c1 + m8  * c2 + vpm[12]);
        var T1 = (m1 * c0 + m5 * c1 + m9  * c2 + vpm[13]);
        var T2 = (m2 * c0 + m6 * c1 + m10 * c2 + vpm[14]);
        var T3 = (m3 * c0 + m7 * c1 + m11 * c2 + vpm[15]);

        return !(((T0 - T3) >  (abs(I0 - I3) + abs(J0 - J3) + abs(K0 - K3))) ||
                 ((T0 + T3) < -(abs(I0 + I3) + abs(J0 + J3) + abs(K0 + K3))) ||
                 ((T1 - T3) >  (abs(I1 - I3) + abs(J1 - J3) + abs(K1 - K3))) ||
                 ((T1 + T3) < -(abs(I1 + I3) + abs(J1 + J3) + abs(K1 + K3))) ||
                 ((T2 - T3) >  (abs(I2 - I3) + abs(J2 - J3) + abs(K2 - K3))) ||
                 ((T2 + T3) < -(abs(I2 + I3) + abs(J2 + J3) + abs(K2 + K3))) ||
               //((T3 - T3) >  (abs(I3 - I3) + abs(J3 - J3) + abs(K3 - K3))) ||
                 ((T3 + T3) < -(abs(I3 + I3) + abs(J3 + J3) + abs(K3 + K3))));
    },

    isVisibleBoxOrigin : function isVisibleBoxOriginFn(halfDimensions, vpm)
    {
        var abs = Math.abs;

        var h0 = halfDimensions[0];
        var h1 = halfDimensions[1];
        var h2 = halfDimensions[2];

        var I0 = (vpm[0]  * h0);
        var I1 = (vpm[1]  * h0);
        var I2 = (vpm[2]  * h0);
        var I3 = (vpm[3]  * h0);
        var J0 = (vpm[4]  * h1);
        var J1 = (vpm[5]  * h1);
        var J2 = (vpm[6]  * h1);
        var J3 = (vpm[7]  * h1);
        var K0 = (vpm[8]  * h2);
        var K1 = (vpm[9]  * h2);
        var K2 = (vpm[10] * h2);
        var K3 = (vpm[11] * h2);
        var T0 = vpm[12];
        var T1 = vpm[13];
        var T2 = vpm[14];
        var T3 = vpm[15];

        return !(((T0 - T3) >  (abs(I0 - I3) + abs(J0 - J3) + abs(K0 - K3))) ||
                 ((T0 + T3) < -(abs(I0 + I3) + abs(J0 + J3) + abs(K0 + K3))) ||
                 ((T1 - T3) >  (abs(I1 - I3) + abs(J1 - J3) + abs(K1 - K3))) ||
                 ((T1 + T3) < -(abs(I1 + I3) + abs(J1 + J3) + abs(K1 + K3))) ||
                 ((T2 - T3) >  (abs(I2 - I3) + abs(J2 - J3) + abs(K2 - K3))) ||
                 ((T2 + T3) < -(abs(I2 + I3) + abs(J2 + J3) + abs(K2 + K3))) ||
               //((T3 - T3) >  (abs(I3 - I3) + abs(J3 - J3) + abs(K3 - K3))) ||
                 ((T3 + T3) < -(abs(I3 + I3) + abs(J3 + J3) + abs(K3 + K3))));
    },

    isVisibleSphere : function isVisibleSphereFn(center, radius, vpm)
    {
        var abs = Math.abs;

        var c0 = center[0];
        var c1 = center[1];
        var c2 = center[2];

        var m0  = vpm[0];
        var m1  = vpm[1];
        var m2  = vpm[2];
        var m3  = vpm[3];
        var m4  = vpm[4];
        var m5  = vpm[5];
        var m6  = vpm[6];
        var m7  = vpm[7];
        var m8  = vpm[8];
        var m9  = vpm[9];
        var m10 = vpm[10];
        var m11 = vpm[11];

        var I0 = m0;
        var I1 = m1;
        var I2 = m2;
        var I3 = m3;
        var J0 = m4;
        var J1 = m5;
        var J2 = m6;
        var J3 = m7;
        var K0 = m8;
        var K1 = m9;
        var K2 = m10;
        var K3 = m11;

        var T0 = (m0 * c0 + m4 * c1 + m8  * c2 + vpm[12]);
        var T1 = (m1 * c0 + m5 * c1 + m9  * c2 + vpm[13]);
        var T2 = (m2 * c0 + m6 * c1 + m10 * c2 + vpm[14]);
        var T3 = (m3 * c0 + m7 * c1 + m11 * c2 + vpm[15]);

        var nradius = -radius;

        return !(((T0 - T3) >  radius * (abs(I0 - I3) + abs(J0 - J3) + abs(K0 - K3))) ||
                 ((T0 + T3) < nradius * (abs(I0 + I3) + abs(J0 + J3) + abs(K0 + K3))) ||
                 ((T1 - T3) >  radius * (abs(I1 - I3) + abs(J1 - J3) + abs(K1 - K3))) ||
                 ((T1 + T3) < nradius * (abs(I1 + I3) + abs(J1 + J3) + abs(K1 + K3))) ||
                 ((T2 - T3) >  radius * (abs(I2 - I3) + abs(J2 - J3) + abs(K2 - K3))) ||
                 ((T2 + T3) < nradius * (abs(I2 + I3) + abs(J2 + J3) + abs(K2 + K3))) ||
               //((T3 - T3) >  radius * (abs(I3 - I3) + abs(J3 - J3) + abs(K3 - K3))) ||
                 ((T3 + T3) < nradius * (abs(I3 + I3) + abs(J3 + J3) + abs(K3 + K3))));
    },

    isVisibleSphereOrigin : function isVisibleSphereOriginFn(radius, vpm)
    {
        var abs = Math.abs;

        var I0 = vpm[0];
        var I1 = vpm[1];
        var I2 = vpm[2];
        var I3 = vpm[3];
        var J0 = vpm[4];
        var J1 = vpm[5];
        var J2 = vpm[6];
        var J3 = vpm[7];
        var K0 = vpm[8];
        var K1 = vpm[9];
        var K2 = vpm[10];
        var K3 = vpm[11];
        var T0 = vpm[12];
        var T1 = vpm[13];
        var T2 = vpm[14];
        var T3 = vpm[15];

        var nradius = -radius;

        return !(((T0 - T3) >  radius * (abs(I0 - I3) + abs(J0 - J3) + abs(K0 - K3))) ||
                 ((T0 + T3) < nradius * (abs(I0 + I3) + abs(J0 + J3) + abs(K0 + K3))) ||
                 ((T1 - T3) >  radius * (abs(I1 - I3) + abs(J1 - J3) + abs(K1 - K3))) ||
                 ((T1 + T3) < nradius * (abs(I1 + I3) + abs(J1 + J3) + abs(K1 + K3))) ||
                 ((T2 - T3) >  radius * (abs(I2 - I3) + abs(J2 - J3) + abs(K2 - K3))) ||
                 ((T2 + T3) < nradius * (abs(I2 + I3) + abs(J2 + J3) + abs(K2 + K3))) ||
               //((T3 - T3) >  radius * (abs(I3 - I3) + abs(J3 - J3) + abs(K3 - K3))) ||
                 ((T3 + T3) < nradius * (abs(I3 + I3) + abs(J3 + J3) + abs(K3 + K3))));
    },

    isVisibleSphereUnit : function isVisibleSphereUnitFn(vpm)
    {
        var abs = Math.abs;

        var I0 = vpm[0];
        var I1 = vpm[1];
        var I2 = vpm[2];
        var I3 = vpm[3];
        var J0 = vpm[4];
        var J1 = vpm[5];
        var J2 = vpm[6];
        var J3 = vpm[7];
        var K0 = vpm[8];
        var K1 = vpm[9];
        var K2 = vpm[10];
        var K3 = vpm[11];
        var T0 = vpm[12];
        var T1 = vpm[13];
        var T2 = vpm[14];
        var T3 = vpm[15];

        return !(((T0 - T3) >  (abs(I0 - I3) + abs(J0 - J3) + abs(K0 - K3))) ||
                 ((T0 + T3) < -(abs(I0 + I3) + abs(J0 + J3) + abs(K0 + K3))) ||
                 ((T1 - T3) >  (abs(I1 - I3) + abs(J1 - J3) + abs(K1 - K3))) ||
                 ((T1 + T3) < -(abs(I1 + I3) + abs(J1 + J3) + abs(K1 + K3))) ||
                 ((T2 - T3) >  (abs(I2 - I3) + abs(J2 - J3) + abs(K2 - K3))) ||
                 ((T2 + T3) < -(abs(I2 + I3) + abs(J2 + J3) + abs(K2 + K3))) ||
               //((T3 - T3) >  (abs(I3 - I3) + abs(J3 - J3) + abs(K3 - K3))) ||
                 ((T3 + T3) < -(abs(I3 + I3) + abs(J3 + J3) + abs(K3 + K3))));
    },

    transformBox : function transformBoxFn(center, halfExtents, matrix)
    {
        var abs = Math.abs;
        var m0  = matrix[0];
        var m1  = matrix[1];
        var m2  = matrix[2];
        var m3  = matrix[3];
        var m4  = matrix[4];
        var m5  = matrix[5];
        var m6  = matrix[6];
        var m7  = matrix[7];
        var m8  = matrix[8];
        var c0 = center[0];
        var c1 = center[1];
        var c2 = center[2];
        var h0 = halfExtents[0];
        var h1 = halfExtents[1];
        var h2 = halfExtents[2];

        return {
                center : [(m0 * c0 + m3 * c1 + m6 * c2 + matrix[9]),
                          (m1 * c0 + m4 * c1 + m7 * c2 + matrix[10]),
                          (m2 * c0 + m5 * c1 + m8 * c2 + matrix[11])],

                halfExtents : [(abs(m0) * h0 + abs(m3) * h1 + abs(m6) * h2),
                               (abs(m1) * h0 + abs(m4) * h1 + abs(m7) * h2),
                               (abs(m2) * h0 + abs(m5) * h1 + abs(m8) * h2)]
            };
    },

    //
    // Planes
    //
    planeNormalize : function planeNormalizeFn(plane)
    {
        var a = plane[0];
        var b = plane[1];
        var c = plane[2];
        var lsq = ((a * a) + (b * b) + (c * c));
        if (lsq > 0.0)
        {
            var lr = 1.0 / Math.sqrt(lsq);
            return [(a * lr), (b * lr), (c * lr), (plane[3] * lr)];
        }
        else
        {
            return [0, 0, 0, 0];
        }
    },

    extractFrustumPlanes : function extractFrustumPlanesFn(m, p)
    {
        var planeNormalize = VMath.planeNormalize;
        var m0  = m[0];
        var m1  = m[1];
        var m2  = m[2];
        var m3  = m[3];
        var m4  = m[4];
        var m5  = m[5];
        var m6  = m[6];
        var m7  = m[7];
        var m8  = m[8];
        var m9  = m[9];
        var m10 = m[10];
        var m11 = m[11];
        var m12 = m[12];
        var m13 = m[13];
        var m14 = m[14];
        var m15 = m[15];
        var planes = (p || []);

        // Negate 'd' here to avoid doing it on the isVisible functions
        planes[0] = planeNormalize([(m3  + m0), (m7  + m4), (m11 + m8),  -(m15 + m12)]); // left
        planes[1] = planeNormalize([(m3  - m0), (m7  - m4), (m11 - m8),  -(m15 - m12)]); // right
        planes[2] = planeNormalize([(m3  - m1), (m7  - m5), (m11 - m9),  -(m15 - m13)]); // top
        planes[3] = planeNormalize([(m3  + m1), (m7  + m5), (m11 + m9),  -(m15 + m13)]); // bottom
        planes[4] = planeNormalize([(m3  + m2), (m7  + m6), (m11 + m10), -(m15 + m14)]);  // near
        planes[5] = planeNormalize([(m3  - m2), (m7  - m6), (m11 - m10), -(m15 - m14)]); // far

        return planes;
    },

    isInsidePlanesPoint : function isInsidePlanesPointFn(p, planes)
    {
        var p0 = p[0];
        var p1 = p[1];
        var p2 = p[2];
        var numPlanes = planes.length;
        var n = 0;
        do
        {
            var plane = planes[n];
            if ((plane[0] * p0 + plane[1] * p1 + plane[2] * p2) < plane[3])
            {
                return false;
            }
            n += 1;
        }
        while (n < numPlanes);
        return true;
    },

    isInsidePlanesSphere : function isInsidePlanesSphereFn(c, r, planes)
    {
        var c0 = c[0];
        var c1 = c[1];
        var c2 = c[2];
        var numPlanes = planes.length;
        var n = 0;
        do
        {
            var plane = planes[n];
            if ((plane[0] * c0 + plane[1] * c1 + plane[2] * c2) < (plane[3] - r))
            {
                return false;
            }
            n += 1;
        }
        while (n < numPlanes);
        return true;
    },

    isInsidePlanesBox : function isInsidePlanesBoxFn(c, h, planes)
    {
        var c0 = c[0];
        var c1 = c[1];
        var c2 = c[2];
        var h0 = h[0];
        var h1 = h[1];
        var h2 = h[2];
        var p0 = (c0 + h0);
        var p1 = (c1 + h1);
        var p2 = (c2 + h2);
        var n0 = (c0 - h0);
        var n1 = (c1 - h1);
        var n2 = (c2 - h2);
        var numPlanes = planes.length;
        var n = 0;
        do
        {
            var plane = planes[n];
            var d0 = plane[0];
            var d1 = plane[1];
            var d2 = plane[2];
            if ((d0 * (d0 < 0 ? n0 : p0) + d1 * (d1 < 0 ? n1 : p1) + d2 * (d2 < 0 ? n2 : p2)) < plane[3])
            {
                return false;
            }
            n += 1;
        }
        while (n < numPlanes);
        return true;
    },


    extractIntersectingPlanes : function extractIntersectingPlanesFn(extents, planes)
    {
        var n0 = extents[0];
        var n1 = extents[1];
        var n2 = extents[2];
        var p0 = extents[3];
        var p1 = extents[4];
        var p2 = extents[5];
        var numPlanes = planes.length;
        var p = [];
        var np = 0;
        var n = 0;
        do
        {
            var plane = planes[n];
            var d0 = plane[0];
            var d1 = plane[1];
            var d2 = plane[2];
            if ((d0 * (d0 > 0 ? n0 : p0) + d1 * (d1 > 0 ? n1 : p1) + d2 * (d2 > 0 ? n2 : p2)) < plane[3])
            {
                p[np] = plane;
                np += 1;
            }
            n += 1;
        }
        while (n < numPlanes);
        return p;
    }
};

// Copyright (c) 2011-2012 Turbulenz Limited

/*global TurbulenzBridge*/
/*global Utilities*/

//
// API
//
//badges is created by Turbulenzservices.createBadges
function BadgeManager() {}

BadgeManager.prototype =
{
    version : 1,
    // list all badges (just queries the yaml file)
    listUserBadges: function userbadgesListFn(callbackFn, errorCallbackFn)
    {
        var that = this;
        function cb(jsonResponse, status)
        {
            if (status === 200)
            {
                callbackFn(jsonResponse.data);
            }
            else if (status === 404)
            {
                callbackFn(null);
            }
            else
            {
                var errorCallback = errorCallbackFn || that.errorCallbackFn;
                errorCallback("Badges.listUserBadges failed with status " + status + ": " + jsonResponse.msg,
                              status,
                              [callbackFn]);
            }
        }

        this.service.request({
            url: '/api/v1/badges/progress/read/' + this.gameSession.gameSlug,
            method: 'GET',
            callback: cb,
            requestHandler: this.requestHandler
        });
    },

    awardUserBadge: function awardUserBadgeFn(badge_key, callbackFn, errorCallbackFn)
    {
        this.addUserBadge(badge_key, null, callbackFn, errorCallbackFn);
    },

    updateUserBadgeProgress: function updateUserBadgeProgressFn(badge_key, current, callbackFn, errorCallbackFn)
    {
        var that = this;
        if (current && typeof current === 'number')
        {
            this.addUserBadge(badge_key, current, callbackFn, errorCallbackFn);
        }
        else
        {
            var errorCallback = errorCallbackFn || that.errorCallbackFn;
            errorCallback("Badges.updateUserBadgeProgress expects a numeric value for current",
                          400,
                          [badge_key, current, callbackFn]);
        }
    },

    // add a badge to a user (gets passed a badge and a current level over POST, the username is taken from the environment)
    addUserBadge: function badgesAddFn(badge_key, current, callbackFn, errorCallbackFn)
    {
        var that = this;
        function cb(jsonResponse, status)
        {
            if (status === 200)
            {
                var userbadge = jsonResponse.data;
                TurbulenzBridge.updateUserBadge(userbadge);
                callbackFn(userbadge);
            }
            else
            {
                var errorCallback = errorCallbackFn || that.errorCallbackFn;
                errorCallback("Badges.addUserBadge failed with status " + status + ": " + jsonResponse.msg,
                              status,
                              [badge_key, current, callbackFn]);
            }
        }

        var dataSpec = {};
        dataSpec.gameSessionId = this.gameSessionId;
        dataSpec.badge_key = badge_key;

        if (current)
        {
            dataSpec.current = current;
        }

        this.service.request({
            url: '/api/v1/badges/progress/add/' + this.gameSession.gameSlug,
            method: 'POST',
            data : dataSpec,
            callback: cb,
            requestHandler: this.requestHandler,
            encrypt: true
        });
    },

    // list all badges (just queries the yaml file)
    listBadges: function badgesListFn(callbackFn, errorCallbackFn)
    {
        var that = this;
        function cb(jsonResponse, status)
        {
            if (status === 200)
            {
                callbackFn(jsonResponse.data);
            }
            else if (status === 404)
            {
                callbackFn(null);
            }
            else
            {
                var errorCallback = errorCallbackFn || that.errorCallbackFn;
                errorCallback("Badges.listBadges failed with status " + status + ": " + jsonResponse.msg,
                              status,
                              [callbackFn]);
            }
        }

        this.service.request({
            url: '/api/v1/badges/read/' + that.gameSession.gameSlug,
            method: 'GET',
            callback: cb,
            requestHandler: this.requestHandler
        });
    },

    errorCallbackFn: function errorCallbackFnx() {
        Utilities.log(Array.prototype.slice.call(arguments));
    }

};

// Copyright (c) 2011-2012 Turbulenz Limited

/*global Utilities: false*/
/*global TurbulenzBridge: false*/
/*global TurbulenzEngine: false*/

//
// API
//
function GameSession() {}
GameSession.prototype =
{
    version : 1,

    setStatus: function gameSessionSetStatusFn(status)
    {
        if (this.status !== status)
        {
            this.status = status;
            TurbulenzBridge.setGameSessionStatus(this.gameSessionId, status);
        }
    },

    // callbackFn is for testing only!
    // It will not be called if destroy is called in TurbulenzEngine.onUnload
    destroy: function gameSessionDestroyFn(callbackFn)
    {
        if (this.gameSessionId)
        {
            TurbulenzBridge.destroyedGameSession(this.gameSessionId);

            Utilities.ajax({
                url: '/api/v1/games/destroy-session',
                method: 'POST',
                data: {'gameSessionId': this.gameSessionId},
                callback: callbackFn,
                requestHandler: this.requestHandler
            });
        }
        else
        {
            if (callbackFn)
            {
                TurbulenzEngine.setTimeout(callbackFn, 0);
            }
        }
    }
};

// Copyright (c) 2011 Turbulenz Limited

/*global TurbulenzEngine: false*/
/*global TurbulenzServices: false*/
/*global Utilities: false*/

//
// API
//
function MultiPlayerSession() {}
MultiPlayerSession.prototype =
{
    version : 1,

    // Public API
    sendTo: function multiPlayerSendToFn(destinationID, messageType, messageData)
    {
        var packet = (destinationID + ':' + messageType + ':');
        if (messageData)
        {
            packet += messageData;
        }

        var socket = this.socket;
        if (socket)
        {
            socket.send(packet);
        }
        else
        {
            this.queue.push(packet);
        }
    },

    sendToGroup: function multiPlayerSendToGroup(destinationIDs, messageType, messageData)
    {
        var packet = (destinationIDs.join(',') + ':' + messageType + ':');
        if (messageData)
        {
            packet += messageData;
        }

        var socket = this.socket;
        if (socket)
        {
            socket.send(packet);
        }
        else
        {
            this.queue.push(packet);
        }
    },

    sendToAll: function multiPlayerSendToAll(messageType, messageData)
    {
        var packet = (':' + messageType + ':');
        if (messageData)
        {
            packet += messageData;
        }

        var socket = this.socket;
        if (socket)
        {
            socket.send(packet);
        }
        else
        {
            this.queue.push(packet);
        }
    },

    makePublic: function multiPlayerMakePublicFn(callbackFn)
    {
        this.service.request({
            url: '/api/v1/multiplayer/session/make-public',
            method: 'POST',
            data: {'session': this.sessionId},
            callback: callbackFn,
            requestHandler: this.requestHandler
        });
    },

    destroy: function multiPlayerDestroyFn(callbackFn)
    {
        var sessionId = this.sessionId;
        if (sessionId)
        {
            this.sessionId = null;

            var playerId = this.playerId;
            this.playerId = null;

            var socket = this.socket;
            if (socket)
            {
                this.socket = null;

                socket.onmessage = null;
                socket.onclose = null;
                socket.onerror = null;
                socket = null;
            }

            this.queue = null;

            this.onmessage = null;
            this.onclose = null;

            Utilities.ajax({
                url: '/api/v1/multiplayer/session/leave',
                method: 'POST',
                data: {'session': sessionId, 'player': playerId},
                callback: callbackFn,
                requestHandler: this.requestHandler
            });
        }
        else
        {
            if (callbackFn)
            {
                TurbulenzEngine.setTimeout(callbackFn, 0);
            }
        }
    },

    connected : function multiPlayerConnectedFn()
    {
        return (!!this.socket);
    },

    // Private API
    flushQueue: function multiPlayerFlushQueueFn()
    {
        var socket = this.socket;
        var queue = this.queue;
        var numPackets = queue.length;
        for (var n = 0; n < numPackets; n += 1)
        {
            socket.send(queue[n]);
        }
    }
};

//
// Constructor
//
MultiPlayerSession.create = function multiPlayerCreate(sessionData, createdCB, errorCB)
{
    var ms = new MultiPlayerSession();
    ms.sessionId = sessionData.sessionid;
    ms.playerId = sessionData.playerid;
    ms.socket = null;
    ms.queue = [];
    ms.onmessage = null;
    ms.onclose = null;
    ms.requestHandler = sessionData.requestHandler;
    ms.service = TurbulenzServices.getService('multiplayer');

    var numplayers = sessionData.numplayers;

    var serverURL = sessionData.server;

    var socket;

    sessionData = null;

    function multiPlayerOnMessage(packet)
    {
        var onmessage = ms.onmessage;
        if (onmessage)
        {
            var message = packet.data;
            var firstSplitIndex = message.indexOf(':');
            var secondSplitIndex = message.indexOf(':', (firstSplitIndex + 1));
            var senderID = message.slice(0, firstSplitIndex);
            /*jslint bitwise:false*/
            var messageType = (message.slice((firstSplitIndex + 1), secondSplitIndex) | 0);
            /*jslint bitwise:true*/
            var messageData = message.slice(secondSplitIndex + 1);

            onmessage(senderID, messageType, messageData);
        }
    }

    function multiPlayerConnect()
    {
        function multiPlayerConnectionError()
        {
            if (!socket)
            {
                socket = ms.socket;
            }

            ms.socket = null;

            if (socket)
            {
                socket.onopen = null;
                socket.onmessage = null;
                socket.onclose = null;
                socket.onerror = null;
                socket = null;
            }

            // current server URL does not respond, ask for a new one
            var requestCallback = function requestCallbackFn(jsonResponse, status)
            {
                if (status === 200)
                {
                    var reconnectData = jsonResponse.data;
                    numplayers = reconnectData.numplayers;
                    serverURL = reconnectData.server;
                    ms.sessionId = reconnectData.sessionid;
                    ms.playerId = reconnectData.playerid;

                    TurbulenzEngine.setTimeout(multiPlayerConnect, 0);
                }
                else
                {
                    if (errorCB)
                    {
                        errorCB("MultiPlayerSession failed: Server not available", 0);
                        errorCB = null;
                        createdCB = null;
                    }
                    else
                    {
                        var onclose = ms.onclose;
                        if (onclose)
                        {
                            ms.onclose = null;
                            onclose();
                        }
                    }
                }
            };

            ms.service.request({
                url: '/api/v1/multiplayer/session/join',
                method: 'POST',
                data: {'session': ms.sessionId, 'player': ms.playerId},
                callback: requestCallback,
                requestHandler: ms.requestHandler
            });
        }

        try
        {
            var nd = TurbulenzEngine.getNetworkDevice();
            if (!nd)
            {
                nd = TurbulenzEngine.createNetworkDevice({});
            }

            socket = nd.createWebSocket(serverURL);

            socket.onopen = function multiPlayerOnOpen()
            {
                ms.socket = socket;

                socket.onopen = null;

                socket.onmessage = multiPlayerOnMessage;

                socket = null;

                ms.flushQueue();

                if (createdCB)
                {
                    createdCB(ms, numplayers);
                    createdCB = null;
                    errorCB = null;
                }
            };

            socket.onclose = socket.onerror = multiPlayerConnectionError;
        }
        catch (exc)
        {
            multiPlayerConnectionError();
        }
    }

    multiPlayerConnect();

    return ms;
};

// Copyright (c) 2011-2012 Turbulenz Limited
/*global window: false*/
/*jslint nomen: false*/



/*
 * An object that takes care of communication with the gamesite and, among
 * other things, replaces the deprecated 'osdlib' module.
 *
 * It wraps an EventEmitter instance that is stored on the page and provides
 * methods that manually display the 'loading'-flag, post certain events to
 * the page or request information about a player's settings.
 *
 */
var TurbulenzBridge = {
    _bridge: undefined,

    /**
     * Try to find an 'EventEmitter' object on the page and cache it.
     */
    _initInstance: function _initInstanceFn() {
        var Turbulenz = window.top.Turbulenz;

        if (Turbulenz && Turbulenz.Services)
        {
            var bridge = Turbulenz.Services.bridge;
            if (!bridge)
            {
                return;
            }

            this._bridge = bridge;

            this.emit = bridge.emit;
            this.addListener = bridge.addListener;
            this.setListener = bridge.setListener;
        }
    },

    isInitialised: function isInitialisedFn() {
        return this._bridge !== undefined;
    },

    emit: function emitFn() {},

    addListener: function addListenerFn() {},

    setListener: function setListenerFn() {},

    /**
     * Methods to signal the beginning and end of load/save processes.
     * This will display hints to the player and helps the page
     * to prioritize resources.
     */
    startLoading: function startLoadingFn() {
        this.emit('status.loading.start');
    },

    startSaving: function startSavingFn() {
        this.emit('status.saving.start');
    },

    stopLoading: function stopLoadingFn() {
        this.emit('status.loading.stop');
    },

    stopSaving: function stopSavingFn() {
        this.emit('status.saving.stop');
    },

    /**
     * These methods tell the gamesite the gameSession so it can
     * emit a heartbeat for the message server to detect.
     * gameSessionId - A string for identifying the current game session
     */
    createdGameSession: function createdGameSessionFn(gameSessionId) {
        this.emit('game.session.created', gameSessionId);
    },

    destroyedGameSession: function destroyedGameSessionFn(gameSessionId) {
        this.emit('game.session.destroyed', gameSessionId);
    },

    setGameSessionStatus: function setGameSessionStatusFn(gameSessionId, status) {
        this.emit('game.session.status', gameSessionId, status);
    },

    /**
     * Update a userbadge. Used by the BadgeManager
     */
    updateUserBadge: function updateUserBadgeFn(badge)
    {
        this.emit('userbadge.update', badge);
    },


    /**
     * Methods to signal changes of the viewport's aspect ratio to the page.
     */
    changeAspectRatio: function changeAspectRatioFn(ratio) {
        this.emit('change.viewport.ratio', ratio);
    },


    /**
     * Methods to set callbacks to react to events happening on the page.
     */
    setOnViewportHide: function setOnViewportHideFn(callback) {
        this.setListener('change.viewport.hide', callback);
    },

    setOnViewportShow: function setOnViewportShowFn(callback) {
        this.setListener('change.viewport.show', callback);
    },

    setOnFullscreenOn: function setOnFullscreenOnFn(callback) {
        this.setListener('change.viewport.fullscreen.on', callback);
    },

    setOnFullscreenOff: function setOnFullscreenOffFn(callback) {
        this.setListener('change.viewport.fullscreen.off', callback);
    },

    setOnMenuStateChange: function setOnMenuStateChangeFn(callback) {
        this.setListener('change.menu.state', callback);
    },

    setOnUserStateChange: function setOnUserStateChangeFn(callback) {
        this.setListener('change.user.state', callback);
    },

    setOnMultiplayerSessionJoinRequest: function setOnMultiplayerSessionJoinRequestFn(callback) {
        this.setListener('multiplayer.request.joinsession', callback);
    },


    /**
     * Methods to send trigger event-emission on the page. These prompt the  page to trigger
     * the aforementioned corresponding onXXXX methods.
     */
    triggerOnFullscreen: function triggerOnFullscreenQueryFn() {
        this.emit('trigger.viewport.fullscreen');
    },

    triggerOnViewportVisibility: function triggerOnViewportVisibilityQueryFn() {
        this.emit('trigger.viewport.visibility');
    },

    triggerOnMenuStateChange: function triggerOnMenuStateQueryFn() {
        this.emit('trigger.menu.state');
    },

    triggerOnUserStateChange: function triggerOnUserStateQueryFn() {
        this.emit('trigger.user.state');
    },


    /**
     * Methods to send requests for information to the page. These methods can be used to send
     * state-queries. They take a callback function and prompt the page to call it.
     */

    /**
     * callback - a function that takes a single boolean value that will be set to 'true' if the
     * viewport is in fullscreen.
     */
    queryFullscreen: function queryFullscreenFn(callback) {
        this.emit('query.viewport.fullscreen', callback);
    },
    /**
     * callback - a function that takes a single boolean value that will be set to 'true' if the
     * viewport is visible.
     */
    queryViewportVisibility: function queryViewportVisibilityFn(callback) {
        this.emit('query.viewport.visibility', callback);
    },
    /**
     * callback - a function that takes an object-representation of the current menu-state.
     */
    queryMenuState: function queryMenuStateFn(callback) {
        this.emit('query.menu.state', callback);
    },
    /**
     * callback - a function that takes an object-representation of the current state of the user's settings.
     */
    queryUserState: function queryUserStateFn(callback) {
        this.emit('query.user.state', callback);
    }
};

if (!TurbulenzBridge.isInitialised())
{
    TurbulenzBridge._initInstance();
}

// Copyright (c) 2011-2012 Turbulenz Limited

/*global TurbulenzEngine: false*/

//
// API
//
function LeaderboardManager() {}
LeaderboardManager.prototype =
{
    version : 1,

    getOverview: function leaderboardManagerGetOverviewFn(spec, callbackFn, errorCallbackFn)
    {
        var errorCallback = errorCallbackFn || this.errorCallbackFn;
        if (!this.meta)
        {
            errorCallback("The leaderboard manager failed to initialize properly.");
            return;
        }

        var that = this;
        function getOverviewCallbackFn(jsonResponse, status)
        {
            if (status === 200)
            {
                var overview = jsonResponse.data;
                var overviewLength = overview.length;
                for (var i = 0; i < overviewLength; i += 1)
                {
                    var leaderboard = overview[i];
                    that.meta[leaderboard.key].bestScore = leaderboard.score;
                }
                callbackFn(overview);
            }
            else
            {
                errorCallback("LeaderboardManager.getKeys failed with status " + status + ": " + jsonResponse.msg,
                              status,
                              that.getOverview,
                              [spec, callbackFn]);
            }
        }

        var dataSpec = {};
        if (spec.friendsOnly)
        {
            dataSpec.friendsonly = spec.friendsOnly && 1;
        }

        this.service.request({
            url: '/api/v1/leaderboards/scores/read/' + that.gameSession.gameSlug,
            method: 'GET',
            data : dataSpec,
            callback: getOverviewCallbackFn,
            requestHandler: this.requestHandler
        });
    },

    get: function leaderboardManagerGetFn(key, spec, callbackFn, errorCallbackFn)
    {
        var errorCallback = errorCallbackFn || this.errorCallbackFn;
        if (!this.meta)
        {
            errorCallback("The leaderboard manager failed to initialize properly.");
            return;
        }

        var meta = this.meta[key];
        if (!meta)
        {
            errorCallback("No leaderboard with the name '" + key + "' exists.");
            return;
        }

        var that = this;
        function getCallbackFn(jsonResponse, status)
        {
            if (status === 200)
            {
                var data = jsonResponse.data;
                var player = data.player;
                var entities = data.entities;
                var ranking = data.ranking;
                var player_user_id;
                var user_id;

                if (player)
                {
                    that.meta[key].bestScore = player.score;
                    player_user_id = player.user;
                    player.user = entities[player_user_id];
                }

                var rankingLength = ranking.length;
                var i;
                for (i = 0; i < rankingLength; i += 1)
                {
                    var rank = ranking[i];

                    user_id = rank.user;
                    if (user_id === player_user_id)
                    {
                        data.playerIndex = i;
                        rank.me = true;
                    }
                    rank.user = entities[user_id];
                }

                callbackFn(key, data);
            }
            else
            {
                errorCallback("LeaderboardManager.get failed with status " + status + ": " + jsonResponse.msg,
                              status,
                              that.get,
                              [key, spec, callbackFn]);
            }
        }

        var dataSpec = {};

        // backwards compatibility
        if (spec.numNear)
        {
            dataSpec.type = 'near';
            dataSpec.size = spec.numNear * 2 + 1;
        }
        if (spec.numTop)
        {
            dataSpec.type = 'top';
            dataSpec.size = spec.numTop;
        }

        // new arguments
        if (spec.size)
        {
            dataSpec.size = spec.size;
        }
        if (!dataSpec.size)
        {
            // default value
            dataSpec.size = 9;
        }
        if (spec.type)
        {
            dataSpec.type = spec.type;
        }
        if (spec.friendsOnly)
        {
            dataSpec.friendsonly = spec.friendsOnly && 1;
        }

        this.service.request({
            url: '/api/v1/leaderboards/scores/read/' + that.gameSession.gameSlug + '/' + key,
            method: 'GET',
            data : dataSpec,
            callback: getCallbackFn,
            requestHandler: this.requestHandler
        });
    },

    set: function leaderboardManagerSetFn(key, score, callbackFn, errorCallbackFn)
    {
        var errorCallback = errorCallbackFn || this.errorCallbackFn;
        if (!this.meta)
        {
            errorCallback("The leaderboard manager failed to initialize properly.");
            return;
        }

        var meta = this.meta[key];
        if (!meta)
        {
            errorCallback("No leaderboard with the name '" + key + "' exists.");
            return;
        }

        var sortBy = meta.sortBy;
        var bestScore = meta.bestScore;
        // Avoid making an ajax query if the new score is worse than current score
        if (bestScore && ((sortBy === 1 && score <= bestScore) || (sortBy === -1 && score >= bestScore)))
        {
            TurbulenzEngine.setTimeout(function () {
                callbackFn(key, score, false, bestScore);
            }, 0);
            return;
        }

        var that = this;
        function setCallbackFn(jsonResponse, status)
        {
            if (status === 200)
            {
                var data = jsonResponse.data;
                var bestScore = data.bestScore || data.lastScore || null;
                var newBest = data.newBest || false;
                if (newBest)
                {
                    bestScore = score;
                }
                meta.bestScore = bestScore;
                callbackFn(key, score, newBest, bestScore);
            }
            else
            {
                errorCallback("LeaderboardManager.set failed with status " + status + ": " + jsonResponse.msg,
                              status,
                              that.set,
                              [key, score, callbackFn]);
            }
        }

        var dataSpec = {};
        dataSpec.score = score;
        dataSpec.gameSessionId = that.gameSessionId;

        this.service.request({
            url: '/api/v1/leaderboards/scores/set/' + key,
            method: 'POST',
            data : dataSpec,
            callback: setCallbackFn,
            requestHandler: this.requestHandler,
            encrypt: true
        });
    }
};

// Copyright (c) 2011 Turbulenz Limited

/*global TurbulenzServices: false*/

//
// API
//
function MappingTable() {}
MappingTable.prototype =
{
    version : 1,

    getURL: function mappingTableGetURL(assetPath, missingCallbackFn)
    {
        var url = this.urlMapping[assetPath];
        if (url)
        {
            return url;
        }
        else
        {
            if (missingCallbackFn)
            {
                missingCallbackFn(assetPath);
            }
            return (this.assetPrefix + assetPath);
        }
    },

    map: function mappingTableMap(logicalPath, physicalPath)
    {
        this.urlMapping[logicalPath] = physicalPath;
    },

    alias: function mappingTableAlias(alias, logicalPath)
    {
        var urlMapping = this.urlMapping;
        urlMapping[alias] = urlMapping[logicalPath];
    }
};

MappingTable.create = function MappingTableCreateFn(params)
{
    var mappingTable = new MappingTable();

    mappingTable.mappingTableURL = params.mappingTableURL;
    mappingTable.mappingTablePrefix = params.mappingTablePrefix;
    mappingTable.assetPrefix = params.assetPrefix;

    mappingTable.errorCallbackFn = params.errorCallback || TurbulenzServices.defaultErrorCallback;
    if (!mappingTable.mappingTableURL)
    {
        mappingTable.errorCallbackFn("TurbulenzServices.createMappingTable no mapping table file given");
    }

    function createMappingTableCallbackFn(urlMappingData)
    {
        var urlMapping = urlMappingData.urnmapping || urlMappingData.urnremapping || {};
        mappingTable.urlMapping = urlMapping;

        // Prepend all the mapped physical paths with the asset server
        var mappingTablePrefix = mappingTable.mappingTablePrefix;
        if (mappingTablePrefix)
        {
            for (var source in urlMapping)
            {
                if (urlMapping.hasOwnProperty(source))
                {
                    urlMapping[source] = mappingTablePrefix + urlMapping[source];
                }
            }
        }

        params.onload(mappingTable);
    }

    params.requestHandler.request({
            src: mappingTable.mappingTableURL,
            onload: function jsonifyResponse(jsonResponse, status) {
                var obj = JSON.parse(jsonResponse);
                if (status === 200)
                {
                    createMappingTableCallbackFn(obj);
                }
                else
                {
                    mappingTable.errorCallbackFn("TurbulenzServices.createMappingTable error with HTTP status " + status + ": " + jsonResponse.msg, status);
                }
            }
        });

    return mappingTable;
};

// Copyright (c) 2011-2012 Turbulenz Limited

/*global BadgeManager: false*/
/*global window: false*/
/*global GameSession: false*/
/*global TurbulenzBridge: false*/
/*global TurbulenzEngine: false*/
/*global Utilities: false*/
/*global MappingTable: false*/
/*global LeaderboardManager: false*/
/*global ServiceRequester: false*/
/*global Badges*/
/*global MultiPlayerSession: false*/
/*global Observer*/

var TurbulenzServices;

function ServiceRequester() {}
ServiceRequester.prototype =
{

    // make a request if the service is available. Same parameters as an
    // Utilities.ajax call with extra argument:
    //     neverDiscard - Never discard the request. Always queues the request
    //                    for when the service is again available. (Ignores
    //                    server preference)
    request: function requestFn(params)
    {
        var discardRequestFn = function discardRequestFn()
        {
            if (params.callback)
            {
                params.callback({'ok': false, 'msg': 'Service Unavailable. Discarding request'}, 503);
            }
        };

        var that = this;
        var serviceStatusObserver = this.serviceStatusObserver;

        var onServiceStatusChange;
        onServiceStatusChange = function onServiceStatusChangeFn(running, discardRequest)
        {
            if (discardRequest)
            {
                if (!params.neverDiscard)
                {
                    serviceStatusObserver.unsubscribe(onServiceStatusChange);
                    discardRequestFn();
                }
            }
            else if (running)
            {
                serviceStatusObserver.unsubscribe(onServiceStatusChange);
                that.request(params);
            }
        };

        if (!this.running)
        {
            if (this.discardRequests && !params.neverDiscard)
            {
                TurbulenzEngine.setTimeout(discardRequestFn, 0);
                return false;
            }

            // we check waiting so that we don't get into an infinite loop of callbacks
            // when a service goes down, then up and then down again before the subscribed
            // callbacks have all been called.
            if (!params.waiting)
            {
                params.waiting = true;
                serviceStatusObserver.subscribe(onServiceStatusChange);
            }
            return true;
        }

        var oldCustomErrorHandler = params.customErrorHandler;
        params.customErrorHandler = function checkServiceUnavailableFn(callContext, makeRequest, responseJSON, status)
        {
            if (status === 503)
            {
                var responseObj = JSON.parse(responseJSON);
                var statusObj = responseObj.data;
                var discardRequests = (statusObj ? statusObj.discardRequests : true);
                that.discardRequests = discardRequests;

                if (discardRequests && !params.neverDiscard)
                {
                    discardRequestFn();
                }
                else
                {
                    serviceStatusObserver.subscribe(onServiceStatusChange);
                }
                TurbulenzServices.serviceUnavailable(that, callContext);
                // An error occurred so return false to avoid calling the success callback
                return false;
            }
            else
            {
                // call the old custom error handler
                if (oldCustomErrorHandler)
                {
                    return oldCustomErrorHandler.call(that.requestHandler, callContext, makeRequest, responseJSON, status);
                }
                return true;
            }
        };

        Utilities.ajax(params);
        return true;
    }
};

ServiceRequester.create = function apiServiceCreateFn(serviceName, params)
{
    var serviceRequester = new ServiceRequester();

    if (!params)
    {
        params = {};
    }

    // we assume everything is working at first
    serviceRequester.running = true;
    serviceRequester.discardRequests = false;
    serviceRequester.serviceStatusObserver = Observer.create();

    serviceRequester.serviceName = serviceName;

    serviceRequester.onServiceUnavailable = params.onServiceUnavailable;
    serviceRequester.onServiceAvailable = params.onServiceAvailable;

    return serviceRequester;
};

//
// TurbulenzServices
//
TurbulenzServices = {

    available: function turbulenzServicesAvailableFn()
    {
        return window.gameSlug !== undefined;
    },

    defaultErrorCallback: function turbulenzServicesDefaultErrorCallbackFn(errorMsg, httpStatus) {},

    onServiceUnavailable: function turbulenzServicesOnServiceUnavailableFn(serviceName, callContext) {},
    onServiceAvailable : function turbulenzServicesOnServiceAvailableFn(serviceName, callContext) {},

    createGameSession: function turbulenzServicesCreateGameSession(requestHandler, sessionCreatedFn, errorCallbackFn)
    {
        var gameSession = new GameSession();

        var gameSlug = window.gameSlug;
        gameSession.gameSlug = gameSlug;

        gameSession.requestHandler = requestHandler;
        gameSession.errorCallbackFn = errorCallbackFn || TurbulenzServices.defaultErrorCallback;
        gameSession.gameSessionId = null;
        gameSession.service = this.getService('gameSessions');
        gameSession.status = null;

        if (!TurbulenzServices.available())
        {
            // Call sessionCreatedFn on a timeout to get the same behaviour as the AJAX call
            if (sessionCreatedFn)
            {
                TurbulenzEngine.setTimeout(function sessionCreatedCall()
                    {
                        sessionCreatedFn(gameSession);
                    }, 0);
            }
            return gameSession;
        }

        function gameSessionRequestCallbackFn(jsonResponse, status)
        {
            if (status === 200)
            {
                gameSession.mappingTable = jsonResponse.mappingTable;
                gameSession.gameSessionId = jsonResponse.gameSessionId;

                if (sessionCreatedFn)
                {
                    sessionCreatedFn(gameSession);
                }

                TurbulenzBridge.createdGameSession(gameSession.gameSessionId);
            }
            else
            {
                gameSession.errorCallbackFn("TurbulenzServices.createGameSession error with HTTP status " + status + ": " + jsonResponse.msg, status);
            }
        }

        var createSessionURL = '/api/v1/games/create-session/' + gameSlug;

        var Turbulenz = window.top.Turbulenz;
        if (Turbulenz)
        {
            var data = Turbulenz.Data;
            if (data)
            {
                var mode = data.mode;
                if (mode)
                {
                    createSessionURL += '/' + mode;
                }
            }
        }

        gameSession.service.request({
            url: createSessionURL,
            method: 'POST',
            callback: gameSessionRequestCallbackFn,
            requestHandler: requestHandler,
            neverDiscard: true
        });

        return gameSession;
    },

    createMappingTable: function turbulenzServicesCreateMappingTable(requestHandler,
                                                                     gameSession,
                                                                     tableRecievedFn,
                                                                     defaultMappingSettings,
                                                                     errorCallbackFn)
    {
        var mappingTable = new MappingTable();
        var mappingTableSettings = gameSession && gameSession.mappingTable;
        if (mappingTableSettings)
        {
            mappingTable.mappingTableURL = mappingTableSettings.mappingTableURL;
            mappingTable.mappingTablePrefix = mappingTableSettings.mappingTablePrefix;
            mappingTable.assetPrefix = mappingTableSettings.assetPrefix;
        }
        else if (defaultMappingSettings)
        {
            mappingTable.mappingTableURL = defaultMappingSettings.mappingTableURL ||
                (defaultMappingSettings.mappingTableURL === "" ? "" : "mapping_table.json");
            mappingTable.mappingTablePrefix = defaultMappingSettings.mappingTablePrefix ||
                (defaultMappingSettings.mappingTablePrefix === "" ? "" : "staticmax/");
            mappingTable.assetPrefix = defaultMappingSettings.assetPrefix ||
                (defaultMappingSettings.assetPrefix === "" ? "" : "missing/");
        }
        else
        {
            mappingTable.mappingTableURL = "mapping_table.json";
            mappingTable.mappingTablePrefix = "staticmax/";
            mappingTable.assetPrefix = "missing/";
        }

        mappingTable.errorCallbackFn = errorCallbackFn || TurbulenzServices.defaultErrorCallback;
        if (!mappingTable.mappingTableURL)
        {
            mappingTable.errorCallbackFn("TurbulenzServices.createMappingTable no mapping table file given");
        }

        function createMappingTableCallbackFn(urlMappingData)
        {
            var urlMapping = urlMappingData.urnmapping || urlMappingData.urnremapping || {};
            mappingTable.urlMapping = urlMapping;

            // Prepend all the mapped physical paths with the asset server
            var mappingTablePrefix = mappingTable.mappingTablePrefix;
            if (mappingTablePrefix)
            {
                for (var source in urlMapping)
                {
                    if (urlMapping.hasOwnProperty(source))
                    {
                        urlMapping[source] = mappingTablePrefix + urlMapping[source];
                    }
                }
            }

            tableRecievedFn(mappingTable);
        }

        requestHandler.request({
                src: mappingTable.mappingTableURL,
                onload: function jsonifyResponse(jsonResponse, status) {
                    var obj = JSON.parse(jsonResponse);
                    if (status === 200)
                    {
                        createMappingTableCallbackFn(obj);
                    }
                    else
                    {
                        mappingTable.errorCallbackFn("TurbulenzServices.createMappingTable error with HTTP status " + status + ": " + jsonResponse.msg, status);
                        mappingTable.urlMapping = defaultMappingSettings && (defaultMappingSettings.urnMapping || {});
                        tableRecievedFn(mappingTable);
                    }
                }
            });

        return mappingTable;
    },

    createLeaderboardManager: function turbulenzServicesCreateLeaderboardManager(requestHandler,
                                                                                 gameSession,
                                                                                 leaderboardMetaRecieved,
                                                                                 errorCallbackFn)
    {
        var leaderboardManager = new LeaderboardManager();

        leaderboardManager.gameSession = gameSession;
        leaderboardManager.gameSessionId = gameSession.gameSessionId;
        leaderboardManager.errorCallbackFn = errorCallbackFn || this.defaultErrorCallback;
        leaderboardManager.service = this.getService('leaderboards');
        leaderboardManager.requestHandler = requestHandler;

        if (!TurbulenzServices.available())
        {
            // Call error callback on a timeout to get the same behaviour as the ajax call
            TurbulenzEngine.setTimeout(function () {
                leaderboardManager.errorCallbackFn('TurbulenzServices.createLeaderboardManager could not load leaderboards meta data');
            }, 0);
            return leaderboardManager;
        }

        leaderboardManager.service.request({
            url: '/api/v1/leaderboards/read/' + gameSession.gameSlug,
            method: 'GET',
            callback: function createLeaderboardManagerAjaxErrorCheck(jsonResponse, status) {
                if (status === 200)
                {
                    var metaArray = jsonResponse.data;
                    if (metaArray)
                    {
                        leaderboardManager.meta = {};
                        var metaLength = metaArray.length;
                        for (var i = 0; i < metaLength; i += 1)
                        {
                            var board = metaArray[i];
                            leaderboardManager.meta[board.key] = board;
                        }
                    }
                    if (leaderboardMetaRecieved)
                    {
                        leaderboardMetaRecieved(leaderboardManager);
                    }
                }
                else
                {
                    leaderboardManager.errorCallbackFn("TurbulenzServices.createLeaderboardManager error with HTTP status " + status + ": " + jsonResponse.msg, status);
                }
            },
            requestHandler: requestHandler,
            neverDiscard: true
        });

        return leaderboardManager;
    },

    //just a factory, Badges have to be included from the caller!->TODO change to a less obtrusive pattern
    createBadgeManager: function turbulenzServicesCreateBadgeManager(requestHandler, gameSession)
    {
        var badgeManager = new BadgeManager();

        badgeManager.gameSession = gameSession;
        badgeManager.gameSessionId = gameSession.gameSessionId;
        badgeManager.service = this.getService('badges');
        badgeManager.requestHandler = requestHandler;

        return badgeManager;
    },

    createUserProfile: function turbulenzServicesCreateUserProfile(requestHandler,
                                                                   profileRecievedFn,
                                                                   errorCallbackFn)
    {
        var userProfile = {};

        if (!errorCallbackFn)
        {
            errorCallbackFn = TurbulenzServices.defaultErrorCallback;
        }

        function loadUserProfileCallbackFn(userProfileData)
        {
            if (userProfileData && userProfileData.ok)
            {
                userProfileData = userProfileData.data;
                for (var p in userProfileData)
                {
                    if (userProfileData.hasOwnProperty(p))
                    {
                        userProfile[p] = userProfileData[p];
                    }
                }
            }
        }

        var url = '/api/v1/profiles/user';
        // Can't request files from the hard disk using AJAX
        if (TurbulenzServices.available())
        {
            this.getService('profiles').request({
                url: url,
                method: 'GET',
                callback: function createUserProfileAjaxErrorCheck(jsonResponse, status)
                {
                    if (status === 200)
                    {
                        loadUserProfileCallbackFn(jsonResponse);
                    }
                    else if (errorCallbackFn)
                    {
                        errorCallbackFn("TurbulenzServices.createUserProfile error with HTTP status " + status + ": " + jsonResponse.msg, status);
                    }
                    profileRecievedFn(userProfile);
                },
                requestHandler: requestHandler
            });
        }

        return userProfile;
    },

    createMultiplayerSession: function turbulenzServicesCreateMultiplayerSession(numSlots,
                                                                                 requestHandler,
                                                                                 sessionCreatedFn,
                                                                                 errorCallbackFn)
    {
        if (!errorCallbackFn)
        {
            errorCallbackFn = TurbulenzServices.defaultErrorCallback;
        }

        if (!TurbulenzServices.available())
        {
            if (errorCallbackFn)
            {
                errorCallbackFn("TurbulenzServices.createMultiplayerSession failed: Service not available",
                                0);
            }
        }
        else
        {
            var requestCallback = function requestCallbackFn(jsonResponse, status)
            {
                if (status === 200)
                {
                    var sessionData = jsonResponse.data;
                    sessionData.requestHandler = requestHandler;

                    MultiPlayerSession.create(sessionData,
                                              sessionCreatedFn,
                                              errorCallbackFn);
                }
                else if (errorCallbackFn)
                {
                    errorCallbackFn("TurbulenzServices.createMultiplayerSession error with HTTP status " +
                                    status + ": " + jsonResponse.msg,
                                    status);
                }
            };

            this.getService('multiplayer').request({
                url: '/api/v1/multiplayer/session/create/' + window.gameSlug,
                method: 'POST',
                data: {'slots': numSlots},
                callback: requestCallback,
                requestHandler: requestHandler
            });
        }
    },

    joinMultiplayerSession: function turbulenzServicesJoinMultiplayerSession(sessionID,
                                                                             requestHandler,
                                                                             sessionCreatedFn,
                                                                             errorCallbackFn)
    {
        if (!errorCallbackFn)
        {
            errorCallbackFn = TurbulenzServices.defaultErrorCallback;
        }

        if (!TurbulenzServices.available())
        {
            if (errorCallbackFn)
            {
                errorCallbackFn("TurbulenzServices.joinMultiplayerSession failed: Service not available",
                                0);
            }
        }
        else
        {
            var requestCallback = function requestCallbackFn(jsonResponse, status)
            {
                if (status === 200)
                {
                    var sessionData = jsonResponse.data;
                    sessionData.requestHandler = requestHandler;
                    MultiPlayerSession.create(sessionData,
                                              sessionCreatedFn,
                                              errorCallbackFn);
                }
                else if (errorCallbackFn)
                {
                    errorCallbackFn("TurbulenzServices.joinMultiplayerSession error with HTTP status " +
                                    status + ": " + jsonResponse.msg,
                                    status);
                }
            };

            this.getService('multiplayer').request({
                url: '/api/v1/multiplayer/session/join',
                method: 'POST',
                data: {'session': sessionID},
                callback: requestCallback,
                requestHandler: requestHandler
            });
        }
    },

    services: {},
    waitingServices: {},
    pollingServiceStatus: false,
    // milliseconds
    defaultPollInterval: 4000,

    getService: function getServiceFn(serviceName)
    {
        var services = this.services;
        if (services.hasOwnProperty(serviceName))
        {
            return services[serviceName];
        }
        else
        {
            var service = ServiceRequester.create(serviceName);
            services[serviceName] = service;
            return service;
        }
    },

    serviceUnavailable: function serviceUnavailableFn(service, callContext)
    {
        var waitingServices = this.waitingServices;
        var serviceName = service.serviceName;
        if (waitingServices.hasOwnProperty(serviceName))
        {
            return;
        }

        waitingServices[serviceName] = service;

        service.running = false;

        var onServiceUnavailableCallbacks = function onServiceUnavailableCallbacksFn(service)
        {
            var onServiceUnavailable = callContext.onServiceUnavailable;
            if (onServiceUnavailable)
            {
                onServiceUnavailable.call(service, callContext);
            }
            if (service.onServiceUnavailable)
            {
                service.onServiceUnavailable();
            }
            if (TurbulenzServices.onServiceUnavailable)
            {
                TurbulenzServices.onServiceUnavailable(service);
            }
        };

        if (service.discardRequests)
        {
            onServiceUnavailableCallbacks(service);
        }

        if (this.pollingServiceStatus)
        {
            return;
        }

        var that = this;
        var pollServiceStatus;

        var serviceUrl = '/api/v1/service-status/game/read/' + window.gameSlug;
        var servicesStatusCB = function servicesStatusCBFn(responseObj, status)
        {
            if (status === 200)
            {
                var statusObj = responseObj.data;
                var servicesObj = statusObj.services;

                var retry = false;
                for (var serviceName in waitingServices)
                {
                    if (waitingServices.hasOwnProperty(serviceName))
                    {
                        var service = waitingServices[serviceName];
                        var serviceData = servicesObj[serviceName];
                        var serviceRunning = serviceData.running;

                        service.running = serviceRunning;
                        service.description = serviceData.description;

                        if (serviceRunning)
                        {
                            if (service.discardRequests)
                            {
                                var onServiceAvailable = callContext.onServiceAvailable;
                                if (onServiceAvailable)
                                {
                                    onServiceAvailable.call(service, callContext);
                                }
                                if (service.onServiceAvailable)
                                {
                                    service.onServiceAvailable();
                                }
                                if (TurbulenzServices.onServiceAvailable)
                                {
                                    TurbulenzServices.onServiceAvailable(service);
                                }
                            }

                            delete waitingServices[serviceName];
                            service.discardRequests = false;
                            service.serviceStatusObserver.notify(serviceRunning, service.discardRequests);

                        }
                        else
                        {
                            // if discardRequests has been set
                            if (serviceData.discardRequests && !service.discardRequests)
                            {
                                service.discardRequests = true;
                                onServiceUnavailableCallbacks(service);
                                // discard all waiting requests
                                service.serviceStatusObserver.notify(serviceRunning, service.discardRequests);
                            }
                            retry = true;
                        }
                    }
                }
                if (!retry)
                {
                    this.pollingServiceStatus = false;
                    return;
                }
                TurbulenzEngine.setTimeout(pollServiceStatus, statusObj.pollInterval * 1000);
            }
            else
            {
                TurbulenzEngine.setTimeout(pollServiceStatus, that.defaultPollInterval);
            }
        };

        pollServiceStatus = function pollServiceStatusFn()
        {
            Utilities.ajax({
                url: serviceUrl,
                method: 'GET',
                callback: servicesStatusCB
            });
        };

        pollServiceStatus();
    }

};

// Copyright (c) 2011 Turbulenz Limited

/*global TurbulenzServices: false*/
/*global ServiceRequester: false*/
/*global Utilities: false*/

//
// API
//
function UserDataManager() {}
UserDataManager.prototype =
{
    version : 1,
    keyValidate: new RegExp("^[A-Za-z0-9]+([\\-\\.][A-Za-z0-9]+)*$"),

    validateKey: function validateKeyFn(key)
    {
        if (!key || typeof(key) !== "string")
        {
            this.errorCallbackFn("Invalid key string (Key string is empty or not a string)");
            return false;
        }

        if (!this.keyValidate.test(key))
        {
            this.errorCallbackFn("Invalid key string (Only alphanumeric characters and .- are permitted)");
            return false;
        }

        return key;
    },

    getKeys: function userdataManagerGetKeysFn(callbackFn, errorCallbackFn)
    {
        var that = this;
        function getKeysCallbackFn(jsonResponse, status)
        {
            if (status === 200)
            {
                callbackFn(jsonResponse.keys || jsonResponse.array);
            }
            else
            {
                var errorCallback = errorCallbackFn || that.errorCallbackFn;
                errorCallback("UserDataManager.getKeys failed with status " + status + ": " + jsonResponse.msg,
                              status,
                              that.getKeys,
                              [callbackFn]);
            }
        }

        var dataSpec = {};
        dataSpec.gameSessionId = that.gameSessionId;

        this.service.request({
            url: '/api/v1/user-data/get-keys',
            method: 'GET',
            data: dataSpec,
            callback: getKeysCallbackFn,
            requestHandler: this.requestHandler,
            encrypt: true
        });
    },

    exists: function userdataManagerExistsFn(key, callbackFn, errorCallbackFn)
    {
        if (!this.validateKey(key))
        {
            return;
        }

        var that = this;
        function existsCallbackFn(jsonResponse, status)
        {
            if (status === 200)
            {
                callbackFn(key, jsonResponse.exists);
            }
            else
            {
                var errorCallback = errorCallbackFn || that.errorCallbackFn;
                errorCallback("UserDataManager.exists failed with status " + status + ": " + jsonResponse.msg,
                              status,
                              that.exists,
                              [key, callbackFn]);
            }
        }

        var dataSpec = {};
        dataSpec.gameSessionId = that.gameSessionId;

        this.service.request({
            url: '/api/v1/user-data/exists/' + key,
            method: 'GET',
            data: dataSpec,
            callback: existsCallbackFn,
            requestHandler: this.requestHandler,
            encrypt: true
        });
    },

    get: function userdataManagerGetFn(key, callbackFn, errorCallbackFn)
    {
        if (!this.validateKey(key))
        {
            return;
        }

        var that = this;
        function getCallbackFn(jsonResponse, status)
        {
            if (status === 200)
            {
                callbackFn(key, jsonResponse.value);
            }
            else if (status === 404)
            {
                callbackFn(key, null);
            }
            else
            {
                var errorCallback = errorCallbackFn || that.errorCallbackFn;
                errorCallback("UserDataManager.get failed with status " + status + ": " + jsonResponse.msg,
                              status,
                              that.get,
                              [key, callbackFn]);
            }
        }

        var dataSpec = {};
        dataSpec.gameSessionId = that.gameSessionId;

        this.service.request({
            url: '/api/v1/user-data/get/' + key,
            method: 'GET',
            data: dataSpec,
            callback: getCallbackFn,
            requestHandler: this.requestHandler,
            encrypt: true
        });
    },

    set: function userdataManagerSetFn(key, value, callbackFn, errorCallbackFn)
    {
        if (!this.validateKey(key))
        {
            return;
        }

        if (!value)
        {
            this.remove(key, callbackFn);
            return;
        }

        var that = this;
        function setCallbackFn(responseText, status)
        {
            if (status === 200)
            {
                callbackFn(key);
            }
            else
            {
                var errorCallback = errorCallbackFn || that.errorCallbackFn;
                errorCallback("UserDataManager.set failed with status " + status + ": " + responseText,
                              status,
                              that.set,
                              [key, value, callbackFn]);
            }
        }

        var dataSpec = {};
        dataSpec.value = value;
        dataSpec.gameSessionId = that.gameSessionId;

        this.service.request({
            url: '/api/v1/user-data/set/' + key,
            method: 'POST',
            data : dataSpec,
            callback: setCallbackFn,
            requestHandler: this.requestHandler,
            encrypt: true
        });
    },

    remove: function userdataManagerRemoveFn(key, callbackFn, errorCallbackFn)
    {
        if (!this.validateKey(key))
        {
            return;
        }

        var that = this;
        function removeCallbackFn(responseText, status)
        {
            if (status === 200)
            {
                callbackFn(key);
            }
            else if (status === 404)
            {
                callbackFn(key);
            }
            else
            {
                var errorCallback = errorCallbackFn || that.errorCallbackFn;
                errorCallback("UserDataManager.remove failed with status " + status + ": " + responseText,
                              status,
                              that.remove,
                              [key, callbackFn]);
            }
        }

        var dataSpec = {};
        dataSpec.gameSessionId = that.gameSessionId;

        this.service.request({
            url: '/api/v1/user-data/remove/' + key,
            method: 'POST',
            data: dataSpec,
            callback: removeCallbackFn,
            requestHandler: this.requestHandler,
            encrypt: true
        });
    },

    removeAll: function userdataManagerRemoveAllFn(callbackFn, errorCallbackFn)
    {
        var that = this;
        function removeAllCallbackFn(responseText, status)
        {
            if (status === 200)
            {
                callbackFn();
            }
            else
            {
                var errorCallback = errorCallbackFn || that.errorCallbackFn;
                errorCallback("UserDataManager.removeAll failed with status " + status + ": " + responseText,
                              status,
                              that.removeAll,
                              [callbackFn]);
            }
        }

        var dataSpec = {};
        dataSpec.gameSessionId = that.gameSessionId;

        this.service.request({
            url: '/api/v1/user-data/remove-all',
            method: 'POST',
            data: dataSpec,
            callback: removeAllCallbackFn,
            requestHandler: this.requestHandler,
            encrypt: true
        });
    }

};

// Constructor function
UserDataManager.create = function UserDataManagerCreateFn(requestHandler, gameSession, errorCallbackFn)
{
    if (!TurbulenzServices.available())
    {
        return null;
    }

    var userdataManager = new UserDataManager();
    userdataManager.requestHandler = requestHandler;
    userdataManager.errorCallbackFn = errorCallbackFn || TurbulenzServices.defaultErrorCallback;
    userdataManager.gameSessionId = gameSession.gameSessionId;

    userdataManager.service = TurbulenzServices.getService('userdata');

    return userdataManager;
};

// Copyright (c) 2009-2012 Turbulenz Limited

/*global TurbulenzEngine: false*/
/*global Observer: false*/
/*global Float32Array: false*/



/**
  @class  Font manager
  @private

  @since TurbulenzEngine 0.1.0
*/
function FontManager() {}
FontManager.prototype =
{
    /**
      Version number
      @memberOf FontManager
      @constant
      @type number
    */
    version : 1
};

/**
  @constructs Constructs a FontManager object.

  @param {GraphicsDevice} gd Graphics device
  @param {RequestHandler} rh RequestHandler object

  @return {FontManager} object, null if failed
*/
FontManager.create = function fontManagerCreateFn(gd, rh, df, errorCallback, log)
{
    if (!errorCallback)
    {
        errorCallback = function (e) {};
    }

    function createIndexBuffer(maxGlyphs)
    {
        var indexBufferParameters = {
            numIndices: (6 * maxGlyphs),
            format: 'USHORT'
        };

        var indexBuffer = gd.createIndexBuffer(indexBufferParameters);

        var writer = indexBuffer.map();
        if (writer)
        {
            var i0, i1, i2, i3;
            for (var i = 0; i < maxGlyphs; i += 1)
            {
                i0 = (4 * i);
                i1 = (i0 + 1);
                i2 = (i0 + 2);
                i3 = (i0 + 3);
                writer(i0, i1, i2);
                writer(i2, i3, i0);
            }

            indexBuffer.unmap(writer);
        }

        return indexBuffer;
    }

    function createVertexBuffer(maxGlyphs)
    {
        return gd.createVertexBuffer({numVertices: (4 * maxGlyphs),
            attributes: [gd.VERTEXFORMAT_FLOAT2, gd.VERTEXFORMAT_FLOAT2],
            dynamic: true,
            'transient': true});
    }

    var Float32ArrayConstructor = Array;
    if (typeof Float32Array !== "undefined")
    {
        var testArray = new Float32Array(4);
        var textDescriptor = Object.prototype.toString.call(testArray);
        if (textDescriptor === '[object Float32Array]')
        {
            Float32ArrayConstructor = Float32Array;
        }
    }


    var primitive = gd.PRIMITIVE_TRIANGLES;
    var semantics = gd.createSemantics(['POSITION', 'TEXCOORD0']);
    var techniqueParameters = gd.createTechniqueParameters({
        texture: null
    });
    var sharedIndexBuffer;
    var sharedVertexBuffer;


    /**
      @class  Font
      @private

      @since TurbulenzEngine 0.1.0
    */
    function Font() {}
    Font.prototype =
    {
        version : 1,

        calculateTextDimensions: function fontCalculateTextDimensionsFn(text, scale, spacing)
        {
            var glyphs = this.glyphs;
            var lineHeight = (this.lineHeight * scale);
            var width = 0;
            var height = 0;
            var numGlyphs = 0;
            var numLines = 0;
            var linesWidth = [];

            var textLength = text.length;
            var lineWidth = 0;
            var c, glyph, gaw;
            for (var i = 0; i < textLength; i += 1)
            {
                c = text.charCodeAt(i);
                if (c === 10)
                {
                    if (lineWidth)
                    {
                        lineWidth -= spacing;
                    }
                    linesWidth[numLines] = lineWidth;
                    numLines += 1;
                    if (width < lineWidth)
                    {
                        width = lineWidth;
                    }
                    lineWidth = 0;
                    height += lineHeight;
                }
                else
                {
                    glyph = glyphs[c];
                    if (glyph)
                    {
                        gaw = glyph.awidth;
                        if (gaw)
                        {
                            lineWidth += ((gaw * scale) + spacing);
                            numGlyphs += 1;
                        }
                        else
                        {
                            lineWidth += spacing;
                        }
                    }
                }
            }

            linesWidth[numLines] = lineWidth;
            if (width < lineWidth)
            {
                width = lineWidth;
            }
            height += lineHeight;

            return {
                width: width,
                height: height,
                numGlyphs: numGlyphs,
                linesWidth: linesWidth
            };
        },


        generateTextVertices: function fontGenerateTextVerticesFn(text, params)
        {
            var rect = params.rect;
            var alignment = params.alignment;
            var scale = (params.scale || 1.0);
            var extraSpacing = (params.spacing ? (params.spacing * scale) : 0);

            var dimensions = this.calculateTextDimensions(text, scale, extraSpacing);
            var numGlyphs = dimensions.numGlyphs;
            if (0 >= numGlyphs)
            {
                return null;
            }

            var linesWidth = dimensions.linesWidth;
            var lineHeight = (this.lineHeight * scale);
            var kernings = this.kernings;
            var glyphs = this.glyphs;

            var numVertices = (numGlyphs * 4);
            var vertices = new Float32ArrayConstructor(numVertices * 4);
            var vertexIndex = 0;

            var c, glyph, gx0, gy0, gx1, gy1, gaw, u0, v0, u1, v1;
            var lineWidth = linesWidth[0];
            var rectLeft = rect[0];
            var rectWidth = rect[2];
            var y = rect[1];
            var x = rectLeft;
            if (1 === alignment)
            {
                x += ((rectWidth - lineWidth) * 0.5);
            }
            else if (2 === alignment)
            {
                x += ((rectWidth - lineWidth));
            }
            var textLength = text.length;
            var line = 0;
            var i;
            for (i = 0; i < textLength; i += 1)
            {
                c = text.charCodeAt(i);
                if (c === 10)
                {
                    y += lineHeight;
                    line += 1;
                    lineWidth = linesWidth[line];
                    x = rectLeft;
                    if (1 === alignment)
                    {
                        x += ((rectWidth - lineWidth) * 0.5);
                    }
                    else if (2 === alignment)
                    {
                        x += ((rectWidth - lineWidth));
                    }
                }
                else
                {
                    glyph = glyphs[c];
                    if (glyph)
                    {
                        gaw = (glyph.awidth * scale);
                        if (gaw)
                        {
                            gx0 = (x + (glyph.xoffset * scale));
                            gy0 = (y + (glyph.yoffset * scale));
                            gx1 = (gx0 + (glyph.width  * scale));
                            gy1 = (gy0 + (glyph.height * scale));
                            u0 = glyph.left;
                            v0 = glyph.top;
                            u1 = glyph.right;
                            v1 = glyph.bottom;

                            vertices[vertexIndex + 0] = gx0;
                            vertices[vertexIndex + 1] = gy0;
                            vertices[vertexIndex + 2] = u0;
                            vertices[vertexIndex + 3] = v0;

                            vertices[vertexIndex + 4] = gx1;
                            vertices[vertexIndex + 5] = gy0;
                            vertices[vertexIndex + 6] = u1;
                            vertices[vertexIndex + 7] = v0;

                            vertices[vertexIndex + 8] = gx1;
                            vertices[vertexIndex + 9] = gy1;
                            vertices[vertexIndex + 10] = u1;
                            vertices[vertexIndex + 11] = v1;

                            vertices[vertexIndex + 12] = gx0;
                            vertices[vertexIndex + 13] = gy1;
                            vertices[vertexIndex + 14] = u0;
                            vertices[vertexIndex + 15] = v1;

                            vertexIndex += 16;

                            numGlyphs -= 1;
                            if (0 === numGlyphs)
                            {
                                break;
                            }
                            x += (gaw + extraSpacing);

                            if (kernings)
                            {
                                var kerning = kernings[c];
                                if (kerning && i < (textLength - 1))
                                {
                                    var amount = kerning[text.charCodeAt(i + 1)];
                                    if (amount)
                                    {
                                        x += (amount * scale);
                                    }
                                }
                            }
                        }
                        else
                        {
                            x += extraSpacing;
                        }
                    }
                }
            }

            return vertices;
        },


        drawTextRect: function fontDrawTextRectFn(text, params)
        {
            var vertices = this.generateTextVertices(text, params);
            if (!vertices)
            {
                return;
            }

            var numGlyphs = (vertices.length / 16);
            var numVertices = (numGlyphs * 4);
            var numIndicies = (numGlyphs * 6);

            if (!sharedIndexBuffer || numIndicies > sharedIndexBuffer.numIndices)
            {
                if (sharedIndexBuffer)
                {
                    sharedIndexBuffer.destroy();
                }
                sharedIndexBuffer = createIndexBuffer(numGlyphs);
            }

            if (!sharedVertexBuffer || numVertices > sharedVertexBuffer.numVertices)
            {
                if (sharedVertexBuffer)
                {
                    sharedVertexBuffer.destroy();
                }
                sharedVertexBuffer = createVertexBuffer(numGlyphs);
            }

            sharedVertexBuffer.setData(vertices, 0, numVertices);

            gd.setStream(sharedVertexBuffer, semantics);
            gd.setIndexBuffer(sharedIndexBuffer);

            // TODO: support for multiple pages
            techniqueParameters.texture = this.texture;
            gd.setTechniqueParameters(techniqueParameters);

            gd.drawIndexed(primitive, numIndicies);
        }
    };

    var fonts = {};
    var loadingFont = {};
    var loadedObservers = {};
    var loadingPages = {};
    var numLoadingFonts = 0;
    var internalFont = {};
    var pathRemapping = null;
    var pathPrefix = "";

    function textureLoaded(font, t)
    {
        font.texture = t;
        font.pageWidth = t.width;
        font.pageHeight = t.height;

        var glyphs = font.glyphs, g;
        if (!glyphs)
        {
            // Assume regular grid
            var floor = Math.floor;
            var w = floor(t.width  / 16);
            var h = floor(t.height / 16);
            var d = 1.0 / 16;
            glyphs = [];
            glyphs.length = 256;
            for (g = 0; g < 256; g += 1)
            {
                var u = (floor(g % 16) * d);
                var v = (floor(g / 16) * d);
                glyphs[g] = {
                        width: w,
                        height: h,
                        awidth: w,
                        xoffset: 0,
                        yoffset: 0,
                        left: u,
                        top: v,
                        right: (u + d),
                        bottom: (v + d),
                        page: 0
                    };
            }
            font.lineHeight = 16;
            font.baseline = 16;
            font.glyphs = glyphs;
            font.numGlyphs = 256;
            font.minGlyphIndex = 0;
        }
    }

    /**
      Creates a font from an '.fnt' or '.fontdat'file and its associated image file

      @memberOf FontManager.prototype
      @public
      @function
      @name load

      @param {string} path Path to the font file without the extension
      @param {function} onFontLoaded function to call once the font has loaded

      @return {object} Font object if it exists, undefined otherwise
    */
    function loadFontFn(path, onFontLoaded)
    {
        function pageComplete()
        {
            loadingPages[path] -= 1;
            if (loadingPages[path] === 0)
            {
                // Last page response
                delete loadingPages[path];
                delete loadingFont[path];
                numLoadingFonts -= 1;
                return true;
            }
            return false;
        }

        function requestFn(url, onload, callContext)
        {
            var font = fonts[path];
            if (!font)
            {
                pageComplete();
                return;
            }

            if (!gd.createTexture({
                src     : url,
                mipmaps : true,
                onload  : onload
            }))
            {
                errorCallback("Failed to create texture for font '" + path + "'.");
                delete fonts[path];

                pageComplete();
            }
        }

        var font = fonts[path];
        if (!font)
        {
            if (!(path in loadingFont))
            {
                loadingFont[path] = true;
                loadingPages[path] = 0;
                numLoadingFonts += 1;

                var observer = Observer.create();
                loadedObservers[path] = observer;
                if (onFontLoaded)
                {
                    observer.subscribe(onFontLoaded);
                }

                var fontDataLoaded = function fontDataLoadedFn(text)
                {
                    font = new Font();

                    if (text)
                    {
                        var fontData = JSON.parse(text);
                        var layouts = fontData.bitmapfontlayouts;
                        for (var p in layouts)
                        {
                            if (layouts.hasOwnProperty(p))
                            {
                                var layout = layouts[p];
                                font.bold = layout.bold;
                                font.italic = layout.italic;
                                font.pageWidth = layout.pagewidth;
                                font.pageHeight = layout.pageheight;
                                font.baseline = layout.baseline;
                                font.glyphs = layout.glyphs;
                                font.numGlyphs = layout.numglyphs;
                                font.minGlyphIndex = layout.minglyphindex;
                                font.lineHeight = layout.lineheight;
                                font.pages = layout.pages;
                                font.kernings = layout.kernings;
                                break;
                            }
                        }
                    }

                    fonts[path] = font;
                    var texturePath;
                    var pages = font.pages;

                    if (pages)
                    {
                        var numPages = pages.length;
                        loadingPages[path] += numPages;

                        var onloadFn = function onloadFn(t, status, callContext)
                        {
                            var font = fonts[path];
                            var i = callContext.index;

                            if (font)
                            {
                                if (t)
                                {
                                    pages[i] = t;

                                    if (i === 0)
                                    {
                                        font.texture = t;
                                    }

                                    if (pageComplete())
                                    {
                                        observer.notify(font);
                                        delete loadedObservers[path];
                                    }
                                    return;
                                }
                                else
                                {
                                    errorCallback("Failed to load font page: '" + pages[i] + "'.");
                                    delete fonts[path];
                                }
                            }
                            pageComplete();
                        };

                        for (var i = 0; i < numPages; i += 1)
                        {
                            texturePath = pages[i];
                            rh.request({
                                src: ((pathRemapping && pathRemapping[texturePath]) || (pathPrefix + texturePath)),
                                onload: onloadFn,
                                requestFn: requestFn,
                                index: i
                            });
                        }
                    }
                    else
                    {
                        texturePath = (path + ".dds");
                        rh.request({
                            src: ((pathRemapping && pathRemapping[texturePath]) || (pathPrefix + texturePath)),
                            onload: function (t)
                            {
                                if (t)
                                {
                                    textureLoaded(font, t);

                                    observer.notify(font);
                                    delete loadedObservers[path];
                                }
                                else
                                {
                                    errorCallback("Failed to load font page: '" + texturePath + "'.");
                                    delete fonts[path];
                                }

                                delete loadingPages[path];
                                delete loadingFont[path];
                                numLoadingFonts -= 1;
                            },
                            requestFn: function (url, onload)
                            {
                                if (!gd.createTexture({
                                    src     : url,
                                    mipmaps : false,
                                    onload  : onload
                                }))
                                {
                                    if (text)
                                    {
                                        errorCallback("Failed to create texture for font '" + path + "'.");
                                    }
                                    else
                                    {
                                        errorCallback("Failed to load font '" + path + "'.");
                                    }
                                    delete fonts[path];
                                    delete loadingPages[path];
                                    delete loadingFont[path];
                                    numLoadingFonts -= 1;
                                }
                            }
                        });
                    }
                };

                var dataPath = path;

                var extension;
                var dot = dataPath.lastIndexOf(".");
                if (dot !== -1)
                {
                    extension = dataPath.substr(dot);
                }
                if (!extension ||
                    (extension !== ".fnt" && extension !== ".fontdat"))
                {
                    dataPath += ".fontdat";
                }

                rh.request({
                    src: (pathRemapping && pathRemapping[dataPath]) || (pathPrefix + dataPath),
                    onload: fontDataLoaded
                });
            }
            else if (onFontLoaded)
            {
                loadedObservers[path].subscribe(onFontLoaded);
            }
        }
        else
        {
            if (onFontLoaded)
            {
                // the callback should always be called asynchronously
                TurbulenzEngine.setTimeout(function fontAlreadyLoadedFn()
                    {
                        onFontLoaded(font);
                    }, 0);
            }
        }
        return font;
    }

    /**
      Alias one font to another name

      @memberOf FontManager.prototype
      @public
      @function
      @name map

      @param {string} dst Name of the alias
      @param {string} src Name of the font to be aliased
    */
    function mapFontFn(dst, src)
    {
        fonts[dst] = fonts[src];
        internalFont[dst] = true;
    }

    /**
      Removes a font from the manager

      @memberOf FontManager.prototype
      @public
      @function
      @name remove

      @param {string} path Path or name of the font
    */
    function removeFontFn(path)
    {
        if (path in fonts)
        {
            delete fonts[path];
        }
    }

    var fm = new FontManager();

    if (log)
    {
        fm.load = function loadFontLogFn(path)
        {
            log.innerHTML += "FontManager.load:&nbsp;'" + path + "'";
            return loadFontFn(path);
        };

        fm.map = function mapFontLogFn(dst, src)
        {
            log.innerHTML += "FontManager.map:&nbsp;'" + src + "' -> '" + dst + "'";
            mapFontFn(dst, src);
        };

        fm.remove = function removeFontLogFn(path)
        {
            log.innerHTML += "FontManager.remove:&nbsp;'" + path + "'";
            removeFontFn(path);
        };
    }
    else
    {
        fm.load = loadFontFn;
        fm.map = mapFontFn;
        fm.remove = removeFontFn;
    }

    /**
      Get object containing all loaded fonts data

      @memberOf FontManager.prototype
      @public
      @function
      @name getAll

      @return {object}
    */
    fm.getAll = function getAllFontsFn()
    {
        return fonts;
    };

    /**
      Get number of fonts pending

      @memberOf FontManager.prototype
      @public
      @function
      @name getNumLoadingFonts

      @return {number}
    */
    fm.getNumPendingFonts = function getNumPendingFontsFn()
    {
        return numLoadingFonts;
    };

    /**
      Check if a font is not pending

      @memberOf FontManager.prototype
      @public
      @function
      @name isFontLoaded

      @param {string} path Path or name of the font

      @return {boolean}
    */
    fm.isFontLoaded = function isFontLoadedFn(path)
    {
        return !loadingFont[path];
    };

    /**
      Check if a font is missing

      @memberOf FontManager.prototype
      @public
      @function
      @name isFontMissing

      @param {string} path Path or name of the font

      @return {boolean}
    */
    fm.isFontMissing = function isFontMissingFn(path)
    {
        return !fonts[path];
    };

    /**
      Set path remapping dictionary

      @memberOf FontManager.prototype
      @public
      @function
      @name setPathRemapping

      @param {string} prm Path remapping dictionary
      @param {string} assetUrl Asset prefix for all assets loaded
    */
    fm.setPathRemapping = function setPathRemappingFn(prm, assetUrl)
    {
        pathRemapping = prm;
        pathPrefix = assetUrl;
    };

    /**
      Calculate text dimensions

      @memberOf FontManager.prototype
      @public
      @function
      @name calculateTextDimensions

      @param {string} path Name of the font
      @param {string} text Text to calculate dimensions for
      @param {number} scale Text scale
      @param {number} spacing Extra spacing between characters

      @return {object} Width and height of the text
    */
    fm.calculateTextDimensions = function calculateTextDimensionsFn(path, text, scale, spacing)
    {
        var font = fonts[path];
        if (font)
        {
            return font.calculateTextDimensions(text, scale, spacing);
        }
        else
        {
            return {
                width: 0,
                height: 0,
                numGlyphs: 0
            };
        }
    };

    /**
      Destroy font manager

      @memberOf FontManager.prototype
      @public
      @function
      @name destroy
    */
    fm.destroy = function fontManagerDestroyFn(prm)
    {
        if (fonts)
        {
            var p;
            for (p in fonts)
            {
                if (fonts.hasOwnProperty(p))
                {
                    var font = fonts[p];
                    if (font)
                    {
                        var texture = font.texture;
                        if (texture)
                        {
                            texture.destroy();
                            font.texture = null;
                        }
                    }
                }
            }
            fonts = null;
        }
        if (sharedVertexBuffer)
        {
            sharedVertexBuffer.destroy();
            sharedVertexBuffer = null;
        }
        if (sharedIndexBuffer)
        {
            sharedIndexBuffer.destroy();
            sharedIndexBuffer = null;
        }
        techniqueParameters = null;
        semantics = null;
        loadingFont = null;
        loadingPages = null;
        loadedObservers = null;
        loadingPages = null;
        numLoadingFonts = 0;
        internalFont = null;
        pathRemapping = null;
        pathPrefix = null;
        rh = null;
        gd = null;
    };

    return fm;
};

// Copyright (c) 2011 Turbulenz Limited


var namedCSSColor = {
    aliceblue : "#f0f8ff",
    antiquewhite : "#faebd7",
    aqua : "#00ffff",
    aquamarine : "#7fffd4",
    azure : "#f0ffff",
    beige : "#f5f5dc",
    bisque : "#ffe4c4",
    black : "#000000",
    blanchedalmond : "#ffebcd",
    blue : "#0000ff",
    blueviolet : "#8a2be2",
    brown : "#a52a2a",
    burlywood : "#deb887",
    cadetblue : "#5f9ea0",
    chartreuse : "#7fff00",
    chocolate : "#d2691e",
    coral : "#ff7f50",
    cornflowerblue : "#6495ed",
    cornsilk : "#fff8dc",
    crimson : "#dc143c",
    cyan : "#00ffff",
    darkblue : "#00008b",
    darkcyan : "#008b8b",
    darkgoldenrod : "#b8860b",
    darkgray : "#a9a9a9",
    darkgrey : "#a9a9a9",
    darkgreen : "#006400",
    darkkhaki : "#bdb76b",
    darkmagenta : "#8b008b",
    darkolivegreen : "#556b2f",
    darkorange : "#ff8c00",
    darkorchid : "#9932cc",
    darkred : "#8b0000",
    darksalmon : "#e9967a",
    darkseagreen : "#8fbc8f",
    darkslateblue : "#483d8b",
    darkslategray : "#2f4f4f",
    darkslategrey : "#2f4f4f",
    darkturquoise : "#00ced1",
    darkviolet : "#9400d3",
    deeppink : "#ff1493",
    deepskyblue : "#00bfff",
    dimgray : "#696969",
    dimgrey : "#696969",
    dodgerblue : "#1e90ff",
    firebrick : "#b22222",
    floralwhite : "#fffaf0",
    forestgreen : "#228b22",
    fuchsia : "#ff00ff",
    gainsboro : "#dcdcdc",
    ghostwhite : "#f8f8ff",
    gold : "#ffd700",
    goldenrod : "#daa520",
    gray : "#808080",
    grey : "#808080",
    green : "#008000",
    greenyellow : "#adff2f",
    honeydew : "#f0fff0",
    hotpink : "#ff69b4",
    indianred : "#cd5c5c",
    indigo : "#4b0082",
    ivory : "#fffff0",
    khaki : "#f0e68c",
    lavender : "#e6e6fa",
    lavenderblush : "#fff0f5",
    lawngreen : "#7cfc00",
    lemonchiffon : "#fffacd",
    lightblue : "#add8e6",
    lightcoral : "#f08080",
    lightcyan : "#e0ffff",
    lightgoldenrodyellow : "#fafad2",
    lightgray : "#d3d3d3",
    lightgrey : "#d3d3d3",
    lightgreen : "#90ee90",
    lightpink : "#ffb6c1",
    lightsalmon : "#ffa07a",
    lightseagreen : "#20b2aa",
    lightskyblue : "#87cefa",
    lightslategray : "#778899",
    lightslategrey : "#778899",
    lightsteelblue : "#b0c4de",
    lightyellow : "#ffffe0",
    lime : "#00ff00",
    limegreen : "#32cd32",
    linen : "#faf0e6",
    magenta : "#ff00ff",
    maroon : "#800000",
    mediumaquamarine : "#66cdaa",
    mediumblue : "#0000cd",
    mediumorchid : "#ba55d3",
    mediumpurple : "#9370d8",
    mediumseagreen : "#3cb371",
    mediumslateblue : "#7b68ee",
    mediumspringgreen : "#00fa9a",
    mediumturquoise : "#48d1cc",
    mediumvioletred : "#c71585",
    midnightblue : "#191970",
    mintcream : "#f5fffa",
    mistyrose : "#ffe4e1",
    moccasin : "#ffe4b5",
    navajowhite : "#ffdead",
    navy : "#000080",
    oldlace : "#fdf5e6",
    olive : "#808000",
    olivedrab : "#6b8e23",
    orange : "#ffa500",
    orangered : "#ff4500",
    orchid : "#da70d6",
    palegoldenrod : "#eee8aa",
    palegreen : "#98fb98",
    paleturquoise : "#afeeee",
    palevioletred : "#d87093",
    papayawhip : "#ffefd5",
    peachpuff : "#ffdab9",
    peru : "#cd853f",
    pink : "#ffc0cb",
    plum : "#dda0dd",
    powderblue : "#b0e0e6",
    purple : "#800080",
    red : "#ff0000",
    rosybrown : "#bc8f8f",
    royalblue : "#4169e1",
    saddlebrown : "#8b4513",
    salmon : "#fa8072",
    sandybrown : "#f4a460",
    seagreen : "#2e8b57",
    seashell : "#fff5ee",
    sienna : "#a0522d",
    silver : "#c0c0c0",
    skyblue : "#87ceeb",
    slateblue : "#6a5acd",
    slategray : "#708090",
    slategrey : "#708090",
    snow : "#fffafa",
    springgreen : "#00ff7f",
    steelblue : "#4682b4",
    tan : "#d2b48c",
    teal : "#008080",
    thistle : "#d8bfd8",
    tomato : "#ff6347",
    turquoise : "#40e0d0",
    violet : "#ee82ee",
    wheat : "#f5deb3",
    white : "#ffffff",
    whitesmoke : "#f5f5f5",
    yellow : "#ffff00",
    yellowgreen : "#9acd32"
};

function parseCSSColor(text, color)
{
    var readInt = parseInt;
    var components;

    text = text.replace(/ /g, '').toLowerCase();

    text = (namedCSSColor[text] || text);

    if (text[0] === '#')
    {
        text = text.substr(1, 6);

        var numChars = text.length;
        if (numChars === 6)
        {
            components = /^(\w{2})(\w{2})(\w{2})$/.exec(text);
            if (components)
            {
                color[0] = (readInt(components[1], 16) / 255);
                color[1] = (readInt(components[2], 16) / 255);
                color[2] = (readInt(components[3], 16) / 255);
                color[3] = 1.0;
                return color;
            }
        }
        else if (numChars === 3)
        {
            components = /^(\w{1})(\w{1})(\w{1})$/.exec(text);
            if (components)
            {
                color[0] = (readInt(components[1], 16) / 15);
                color[1] = (readInt(components[2], 16) / 15);
                color[2] = (readInt(components[3], 16) / 15);
                color[3] = 1.0;
                return color;
            }
        }
    }
    else
    {
        var color_type = text.substr(0, 4);
        if (color_type === 'rgba')
        {
            components = /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*\.?\d+)\)$/.exec(text);
            if (components)
            {
                color[0] = readInt(components[1], 10) / 255;
                color[1] = readInt(components[2], 10) / 255;
                color[2] = readInt(components[3], 10) / 255;
                color[3] = parseFloat(components[4]);
                return color;
            }
        }
        else if (color_type === 'rgb(')
        {
            components = /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/.exec(text);
            if (components)
            {
                color[0] = readInt(components[1], 10) / 255;
                color[1] = readInt(components[2], 10) / 255;
                color[2] = readInt(components[3], 10) / 255;
                color[3] = 1.0;
                return color;
            }
        }
        else
        {
            if (color_type === 'hsla')
            {
                components = /^hsla\((\d{1,3}),\s*(\d{1,3})\%,\s*(\d{1,3})\%,\s*(\d*\.?\d+)\)$/.exec(text);
                if (components)
                {
                    color[3] = parseFloat(components[4]);
                }
            }
            else if (color_type === 'hsl(')
            {
                components = /^hsl\((\d{1,3}),\s*(\d{1,3})\%,\s*(\d{1,3})\%\)$/.exec(text);
                if (components)
                {
                    color[3] = 1.0;
                }
            }

            if (components)
            {
                var hue = readInt(components[1], 10) / 360;
                var saturation = readInt(components[2], 10) / 100;
                var lightness = readInt(components[3], 10) / 100;
                if (saturation === 0)
                {
                    color[0] = lightness;
                    color[1] = lightness;
                    color[2] = lightness;
                }
                else
                {
                    var m1, m2;
                    if (lightness < 0.5)
                    {
                        m2 = (lightness * (saturation + 1));
                    }
                    else
                    {
                        m2 = ((lightness + saturation) - (lightness * saturation));
                    }
                    m1 = ((lightness * 2) - m2);

                    var hueToRgb = function hueToRgbFn(m1, m2, hue)
                    {
                        if (hue < 0)
                        {
                            hue += 1;
                        }
                        else if (hue > 1)
                        {
                            hue -= 1;
                        }

                        if ((6 * hue) < 1)
                        {
                            return (m1 + ((m2 - m1) * (hue * 6)));
                        }
                        else if ((2 * hue) < 1)
                        {
                            return m2;
                        }
                        else if ((3 * hue) < 2)
                        {
                            return (m1 + ((m2 - m1) * ((2 / 3) - hue) * 6));
                        }
                        else
                        {
                            return m1;
                        }
                    };

                    color[0] = hueToRgb(m1, m2, (hue + (1 / 3)));
                    color[1] = hueToRgb(m1, m2, hue);
                    color[2] = hueToRgb(m1, m2, (hue - (1 / 3)));
                }
                return color;
            }
        }
    }

    return undefined;
}

//
// CanvasLinearGradient
//
function CanvasLinearGradient() {}
CanvasLinearGradient.prototype =
{
    version : 1,

    // Public API
    addColorStop : function addLinearColorStopFn(offset, color)
    {
        if (offset < 0 || offset > 1)
        {
            throw 'INDEX_SIZE_ERR';
        }

        function sortfunction(a, b)
        {
            return (a[0] - b[0]);
        }

        var stops = this.stops;
        var numStops = stops.length;

        var parsedColor = parseCSSColor(color, []);

        if (parsedColor[3] < 1.0)
        {
            this.opaque = false;
        }

        parsedColor[0] = parseInt((parsedColor[0] * 255), 10);
        parsedColor[1] = parseInt((parsedColor[1] * 255), 10);
        parsedColor[2] = parseInt((parsedColor[2] * 255), 10);
        parsedColor[3] = parseInt((parsedColor[3] * 255), 10);
        stops[numStops] = [offset, parsedColor];
        numStops += 1;
        if (numStops > 1)
        {
            stops.sort(sortfunction);
        }
    },

    // Private API
    updateTexture : function updateLinearTextureFn(gd)
    {
        var texture = this.texture;
        var stops = this.stops;
        var numStops = stops.length;
        if (this.numTextureStops !== numStops)
        {
            this.numTextureStops = numStops;

            var width = this.width;
            var height = this.height;

            if (!texture)
            {
                this.texture = texture = gd.createTexture({
                    name    : ('linear:' + width + 'x' + height),
                    width   : width,
                    height  : height,
                    depth   : 1,
                    format  : gd.PIXELFORMAT_R8G8B8A8,
                    cubemap : false,
                    mipmaps : false
                });
            }

            var opaque = this.opaque;

            var lx = (this.x1 - this.x0);
            var ly = (this.y1 - this.y0);
            var ln = ((lx * lx) + (ly * ly));
            if (ln === 0)
            {
                ln = 1;
            }
            else
            {
                ln = (1.0 / Math.sqrt(ln));
            }

            lx *= ln;
            ly *= ln;

            var dx = (lx / (width > 1 ? (width - 1) : 1));
            var dy = (ly / (height > 1 ? (height - 1) : 1));

            var ArrayTypeConstructor = [].constructor;
            var numValues = (width * height * 4);
            var pixelData = new ArrayTypeConstructor(numValues);
            var p = 0;
            var vy = 0;
            for (var y = 0; y < height; y += 1, vy += dy)
            {
                var vyly = (vy * ly);
                var vx = 0;

                for (var x = 0; x < width; x += 1, p += 4, vx += dx)
                {
                    var s = ((vx * lx) + vyly);

                    var currentStop = stops[0];
                    var currentOffset = currentStop[0];
                    var currentColor = currentStop[1];
                    var lastOffset = currentOffset;
                    var lastColor = currentColor;

                    if (s > currentOffset)
                    {
                        for (var ns = 1; ns < numStops; ns += 1)
                        {
                            currentStop = stops[ns];
                            currentOffset = currentStop[0];
                            currentColor = currentStop[1];
                            if (s <= currentOffset)
                            {
                                break;
                            }
                            lastOffset = currentOffset;
                            lastColor = currentColor;
                        }
                    }

                    var da = (currentOffset - lastOffset);
                    if (da <= 0 || s === currentOffset)
                    {
                        pixelData[p] = currentColor[0];
                        pixelData[p + 1] = currentColor[1];
                        pixelData[p + 2] = currentColor[2];
                        if (opaque)
                        {
                            pixelData[p + 3] = 255;
                        }
                        else
                        {
                            pixelData[p + 3] = currentColor[3];
                        }
                    }
                    else
                    {
                        var a = (s - lastOffset) / da;
                        if (a < 0.996)
                        {
                            var inva = (1.0 - a);
                            pixelData[p] = ((currentColor[0] * a) + (lastColor[0] * inva));
                            pixelData[p + 1] = ((currentColor[1] * a) + (lastColor[1] * inva));
                            pixelData[p + 2] = ((currentColor[2] * a) + (lastColor[2] * inva));
                            if (opaque)
                            {
                                pixelData[p + 3] = 255;
                            }
                            else
                            {
                                pixelData[p + 3] = ((currentColor[3] * a) + (lastColor[3] * inva));
                            }
                        }
                        else
                        {
                            pixelData[p] = currentColor[0];
                            pixelData[p + 1] = currentColor[1];
                            pixelData[p + 2] = currentColor[2];
                            if (opaque)
                            {
                                pixelData[p + 3] = 255;
                            }
                            else
                            {
                                pixelData[p + 3] = currentColor[3];
                            }
                        }
                    }
                }
            }

            texture.setData(pixelData);
        }
        return texture;
    }
};

// Constructor function
CanvasLinearGradient.create = function canvasLinearGradientCreateFn(x0, y0, x1, y1)
{
    var dx = (x1 - x0);
    var dy = (y1 - y0);
    var width = Math.abs(dx);
    var height = Math.abs(dy);
    if (width === 0 && height === 0)
    {
        return null;
    }

    // We need minimmal dimensions for minimal quality
    while (width < 16 && height < 16)
    {
        width *= 16;
        height *= 16;
    }

    if (width < 1)
    {
        width = 1;
    }
    else
    {
        width = Math.floor(width);
    }

    if (height < 1)
    {
        height = 1;
    }
    else
    {
        height = Math.floor(height);
    }

    var c = new CanvasLinearGradient();
    c.x0 = x0;
    c.y0 = y0;
    c.x1 = x1;
    c.y1 = y1;
    c.width = width;
    c.height = height;
    c.stops = [];

    var idx = (1.0 / dx);
    var idy = (1.0 / dy);
    c.matrix = [idx, 0, -x0 * idx,
                0, idy, -y0 * idy];

    c.numTextureStops = 0;
    c.texture = null;

    c.opaque = true;

    return c;
};

//
// CanvasRadialGradient
//
function CanvasRadialGradient() {}
CanvasRadialGradient.prototype =
{
    version : 1,

    // Public API
    addColorStop : function addRadialColorStopFn(offset, color)
    {
        if (offset < 0 || offset > 1)
        {
            throw 'INDEX_SIZE_ERR';
        }

        function sortfunction(a, b)
        {
            return (a[0] - b[0]);
        }

        var stops = this.stops;
        var numStops = stops.length;
        var parsedColor = parseCSSColor(color, []);

        if (parsedColor[3] < 1.0)
        {
            this.opaque = false;
        }

        parsedColor[0] = parseInt((parsedColor[0] * 255), 10);
        parsedColor[1] = parseInt((parsedColor[1] * 255), 10);
        parsedColor[2] = parseInt((parsedColor[2] * 255), 10);
        parsedColor[3] = parseInt((parsedColor[3] * 255), 10);
        stops[numStops] = [offset, parsedColor];
        numStops += 1;
        if (numStops > 1)
        {
            stops.sort(sortfunction);
        }
    },

    // Private API
    updateTexture : function updateRadialTextureFn(gd)
    {
        var texture = this.texture;
        var stops = this.stops;
        var numStops = stops.length;
        if (this.numTextureStops !== numStops)
        {
            this.numTextureStops = numStops;

            var width = this.width;
            if (width < numStops)
            {
                this.width = width = numStops;
            }

            var height = this.height;
            if (height < numStops)
            {
                this.height = height = numStops;
            }

            if (!texture ||
                texture.width !== width ||
                texture.height !== height)
            {
                this.texture = texture = gd.createTexture({
                    name    : ('radial:' + width + 'x' + height),
                    width   : width,
                    height  : height,
                    depth   : 1,
                    format  : gd.PIXELFORMAT_R8G8B8A8,
                    cubemap : false,
                    mipmaps : false
                });
            }

            var x0 = (this.x0 - this.minX);
            var x1 = (this.x1 - this.minX);
            var dx = (x1 - x0);

            var y0 = (this.y0 - this.minY);
            var y1 = (this.y1 - this.minY);
            var dy = (y1 - y0);

            var r0 = this.r0;
            var r1 = this.r1;
            var dr = (r1 - r0);

            var ArrayTypeConstructor = [].constructor;
            var numValues = (width * height * 4);
            var pixelData = new ArrayTypeConstructor(numValues);

            var cos = Math.cos;
            var sin = Math.sin;
            var abs = Math.abs;
            var pi2 = (Math.PI * 2);

            /*jslint bitwise: false*/
            var numSteps = Math.max(abs(dx | 0), abs(dy | 0), abs(dr | 0));
            /*jslint bitwise: true*/

            var dw = (1.0 / numSteps);
            var c0, c1, c2, c3;
            for (var w = 0.0; w <= 1.0; w += dw)
            {
                var currentStop = stops[0];
                var currentOffset = currentStop[0];
                var currentColor = currentStop[1];
                var lastOffset = currentOffset;
                var lastColor = currentColor;

                if (w > currentOffset)
                {
                    for (var ns = 1; ns < numStops; ns += 1)
                    {
                        currentStop = stops[ns];
                        currentOffset = currentStop[0];
                        currentColor = currentStop[1];
                        if (w <= currentOffset)
                        {
                            break;
                        }
                        lastOffset = currentOffset;
                        lastColor = currentColor;
                    }
                }

                var da = (currentOffset - lastOffset);
                if (da <= 0 || w === currentOffset)
                {
                    c0 = currentColor[0];
                    c1 = currentColor[1];
                    c2 = currentColor[2];
                    c3 = currentColor[3];
                }
                else
                {
                    var a = (w - lastOffset) / da;
                    var inva = (1.0 - a);
                    c0 = ((currentColor[0] * a) + (lastColor[0] * inva));
                    c1 = ((currentColor[1] * a) + (lastColor[1] * inva));
                    c2 = ((currentColor[2] * a) + (lastColor[2] * inva));
                    c3 = ((currentColor[3] * a) + (lastColor[3] * inva));
                }

                var x = (x0 + (w * dx));
                var y = (y0 + (w * dy));
                var r = (r0 + (w * dr));

                var angle, dangle, cx, cy, p;
                for (var cr = 1; cr < r; cr += 1)
                {
                    dangle = (1.0 / cr);
                    for (angle = 0; angle < pi2; angle += dangle)
                    {
                        /*jslint bitwise: false*/
                        cx = ((x + (cr * cos(angle))) | 0);
                        cy = ((y + (cr * sin(angle))) | 0);
                        p = ((cx + (cy * width)) << 2);
                        /*jslint bitwise: true*/
                        if (pixelData[p + 3] === undefined)
                        {
                            pixelData[p] = c0;
                            pixelData[p + 1] = c1;
                            pixelData[p + 2] = c2;
                            pixelData[p + 3] = c3;
                        }
                    }
                }

                dangle = (1.0 / r);
                for (angle = 0; angle < pi2; angle += dangle)
                {
                    /*jslint bitwise: false*/
                    cx = ((x + (r * cos(angle))) | 0);
                    cy = ((y + (r * sin(angle))) | 0);
                    p = ((cx + (cy * width)) << 2);
                    /*jslint bitwise: true*/
                    if (pixelData[p + 3] === undefined)
                    {
                        pixelData[p] = c0;
                        pixelData[p + 1] = c1;
                        pixelData[p + 2] = c2;
                        pixelData[p + 3] = c3;
                    }
                }
            }

            var outColor = stops[numStops - 1][1];
            var out0 = outColor[0];
            var out1 = outColor[1];
            var out2 = outColor[2];
            var out3 = outColor[3];
            for (var n = 0; n < numValues; n += 4)
            {
                if (pixelData[n + 3] === undefined)
                {
                    pixelData[n] = out0;
                    pixelData[n + 1] = out1;
                    pixelData[n + 2] = out2;
                    pixelData[n + 3] = out3;
                }
            }

            texture.setData(pixelData);
        }
        return texture;
    }
};

// Constructor function
CanvasRadialGradient.create = function canvasRadialGradientCreateFn(x0, y0, r0, x1, y1, r1)
{
    if (r0 < 0 || r1 < 0)
    {
        throw 'INDEX_SIZE_ERR';
    }

    var c = new CanvasRadialGradient();
    c.x0 = x0;
    c.y0 = y0;
    c.r0 = r0;
    c.x1 = x1;
    c.y1 = y1;
    c.r1 = r1;

    var minX = (Math.min((x0 - r0), (x1 - r1)) - 1);
    var maxX = (Math.max((x0 + r0), (x1 + r1)) + 1);
    var minY = (Math.min((y0 - r0), (y1 - r1)) - 1);
    var maxY = (Math.max((y0 + r0), (y1 + r1)) + 1);

    c.minX = minX;
    c.minY = minY;
    c.stops = [];

    var width = Math.ceil(maxX - minX);
    var height = Math.ceil(maxY - minY);
    if (!width || !height)
    {
        return null;
    }
    c.width = width;
    c.height = height;

    var idx = (1.0 / width);
    var idy = (1.0 / height);

    c.matrix = [idx, 0, -minX * idx,
                0, idy, -minY * idy];

    c.numTextureStops = 0;
    c.texture = null;

    c.opaque = true;

    return c;
};

//
// CanvasContext
//
function CanvasContext() {}
CanvasContext.prototype =
{
    version : 1,

    compositeOperations :
    {
        'source-atop' : 1,
        'source-in' : 1,
        'source-out' : 1,
        'source-over' : 1,
        'destination-atop' : 1,
        'destination-in' : 1,
        'destination-out' : 1,
        'destination-over' : 1,
        'lighter' : 1,
        'copy' : 1,
        'xor' : 1
    },

    capStyles :
    {
        'butt' : 1,
        'round' : 1,
        'square' : 1
    },

    joinStyles :
    {
        'bevel' : 1,
        'round' : 1,
        'miter' : 1
    },

    arrayTypeConstructor : [].constructor,

    //
    // Public canvas 2D context API
    //
    save : function saveFn()
    {
        var statesStack = this.statesStack;
        statesStack[statesStack.length] = this.getStates();
    },

    restore : function restoreFn()
    {
        var statesStack = this.statesStack;
        if (statesStack.length >= 1)
        {
            this.setStates(statesStack.pop());
        }
    },


    scale : function scaleFn(x, y)
    {
        var m = this.matrix;
        m[0] *= x;
        m[1] *= y;
        m[3] *= x;
        m[4] *= y;
    },

    rotate : function rotateFn(angle)
    {
        if (angle)
        {
            var s = Math.sin(angle);
            var c = Math.cos(angle);
            this.transform(c, s, -s, c, 0, 0);
        }
    },

    translate : function translateFn(x, y)
    {
        var m = this.matrix;
        m[2] += (m[0] * x + m[1] * y);
        m[5] += (m[3] * x + m[4] * y);
    },

    transform : function transformFn(a, b, c, d, e, f)
    {
        var m = this.matrix;
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];

        m[0] = (m0 * a + m1 * b);
        m[3] = (m3 * a + m4 * b);
        m[1] = (m0 * c + m1 * d);
        m[4] = (m3 * c + m4 * d);
        m[2] = (m0 * e + m1 * f + m2);
        m[5] = (m3 * e + m4 * f + m5);
    },

    setTransform : function setTransformFn(a, b, c, d, e, f)
    {
        var m = this.matrix;
        m[0] = a;
        m[1] = c;
        m[2] = e;
        m[3] = b;
        m[4] = d;
        m[5] = f;
    },


    createLinearGradient : function createLinearGradientFn(x0, y0, x1, y1)
    {
        return CanvasLinearGradient.create(x0, y0, x1, y1);
    },

    createRadialGradient : function createRadialGradientFn(x0, y0, r0, x1, y1, r1)
    {
        return CanvasRadialGradient.create(x0, y0, r0, x1, y1, r1);
    },

    createPattern : function createPatternFn(image, repetition)
    {
        if (!image)
        {
            throw 'INVALID_STATE_ERR';
        }

        if (image.width === 0 ||
            image.height === 0)
        {
            return null;
        }

        return image;
    },


    clearRect : function clearRectFn(x, y, w, h)
    {
        if (w > 0 && h > 0)
        {
            var rect = this.transformRect(x, y, w, h);
            this.fillFlatVertices(rect, 4);

            var technique = this.flatTechniques.copy;
            var gd = this.gd;

            gd.setTechnique(technique);

            technique.screen = this.screen;
            technique.color = this.v4Zero;

            gd.draw(this.triangleStripPrimitive, 4);
        }
    },

    fillRect : function fillRectFn(x, y, w, h)
    {
        if (w > 0 && h > 0)
        {
            var rect = this.transformRect(x, y, w, h);
            this.fillFlatVertices(rect, 4);

            var primitive = this.triangleStripPrimitive;
            var style = this.fillStyle;
            var gd = this.gd;

            if (this.setShadowStyle(style))
            {
                gd.draw(primitive, 4);
            }

            this.setStyle(style);

            gd.draw(primitive, 4);
        }
    },

    strokeRect : function strokeRectFn(x, y, w, h)
    {
        if (w > 0 || h > 0)
        {
            var rect = this.transformRect(x, y, w, h);
            var points = [rect[2], rect[3], rect[1], rect[0], rect[2]];

            var style = this.strokeStyle;
            var lineWidth = this.lineWidth;
            var thinLines = (lineWidth < 2 && !this.forceFatLines);

            var primitive;
            var vertices;
            var numVertices = 0;

            if (thinLines)
            {
                primitive = this.lineStripPrimitive;
                vertices = points;
                numVertices = 5;
            }
            else
            {
                primitive = this.triangleStripPrimitive;
                vertices = this.tempVertices;
                numVertices = this.triangulateFatStrip(points, 5, lineWidth, vertices, numVertices);
            }

            if (numVertices > 0)
            {
                this.fillFlatVertices(vertices, numVertices);

                var gd = this.gd;

                if (this.setShadowStyle(style))
                {
                    gd.draw(primitive, numVertices);
                }

                this.setStyle(style);

                gd.draw(primitive, numVertices);
            }
        }
    },


    beginPath : function beginPathFn()
    {
        this.subPaths.length = 0;
        this.currentSubPath.length = 0;
    },

    closePath : function closePathFn()
    {
        var currentSubPath = this.currentSubPath;
        var numCurrentSubPathElements = currentSubPath.length;
        if (numCurrentSubPathElements > 1)
        {
            var firstPoint = currentSubPath[0];

            // Close current subpath if not just a single segment
            if (numCurrentSubPathElements > 2)
            {
                var lastPoint = currentSubPath[numCurrentSubPathElements - 1];
                if (firstPoint[0] !== lastPoint[0] &&
                    firstPoint[1] !== lastPoint[2])
                {
                    currentSubPath[numCurrentSubPathElements] = firstPoint;
                }
            }

            var subPaths = this.subPaths;
            subPaths[subPaths.length] = currentSubPath;

            this.currentSubPath = [firstPoint];
        }
    },

    moveTo : function moveToFn(x, y)
    {
        var currentSubPath = this.currentSubPath;
        if (currentSubPath.length > 1)
        {
            var subPaths = this.subPaths;
            subPaths[subPaths.length] = currentSubPath;

            this.currentSubPath = [this.transformPoint(x, y)];
        }
        else
        {
            currentSubPath[0] = this.transformPoint(x, y);
        }
    },

    lineTo : function lineToFn(x, y)
    {
        var currentSubPath = this.currentSubPath;
        currentSubPath[currentSubPath.length] = this.transformPoint(x, y);
    },

    quadraticCurveTo : function quadraticCurveToFn(cpx, cpy, x, y)
    {
        var currentSubPath = this.currentSubPath;
        var numCurrentSubPathElements = currentSubPath.length;
        if (numCurrentSubPathElements === 0)
        {
            throw 'Needs starting point!';
        }

        var p1 = currentSubPath[numCurrentSubPathElements - 1];
        var x1 = p1[0];
        var y1 = p1[1];

        var q = this.transformPoint(cpx, cpy);
        var xq = q[0];
        var yq = q[1];

        var p2 = this.transformPoint(x, y);
        var x2 = p2[0];
        var y2 = p2[1];

        var abs = Math.abs;
        /*jslint bitwise: false*/
        var numSteps = ((0.5 * (abs(x2 - x1) + abs(y2 - y1))) | 0);
        /*jslint bitwise: true*/
        var dt = (1.0 / numSteps);
        for (var t = dt; 1 < numSteps; t += dt, numSteps -= 1)
        {
            var invt = (1.0 - t);
            var invt2 = (invt * invt);
            var t2 = (t * t);
            var tinvt = (2 * t * invt);
            currentSubPath[numCurrentSubPathElements] = [((invt2 * x1) + (tinvt * xq) + (t2 * x2)),
                                                         ((invt2 * y1) + (tinvt * yq) + (t2 * y2))];
            numCurrentSubPathElements += 1;
        }

        currentSubPath[numCurrentSubPathElements] = [x2, y2];
    },

    bezierCurveTo : function bezierCurveToFn(cp1x, cp1y, cp2x, cp2y, x, y)
    {
        var currentSubPath = this.currentSubPath;
        var numCurrentSubPathElements = currentSubPath.length;
        if (numCurrentSubPathElements === 0)
        {
            throw 'Needs starting point!';
        }

        var p1 = currentSubPath[numCurrentSubPathElements - 1];
        var x1 = p1[0];
        var y1 = p1[1];

        var q1 = this.transformPoint(cp1x, cp1y);
        var xq1 = q1[0];
        var yq1 = q1[1];

        var q2 = this.transformPoint(cp2x, cp2y);
        var xq2 = q2[0];
        var yq2 = q2[1];

        var p2 = this.transformPoint(x, y);
        var x2 = p2[0];
        var y2 = p2[1];

        var abs = Math.abs;
        /*jslint bitwise: false*/
        var numSteps = ((0.5 * (abs(x2 - x1) + abs(y2 - y1))) | 0);
        /*jslint bitwise: true*/
        var dt = (1.0 / numSteps);
        for (var t = dt; 1 < numSteps; t += dt, numSteps -= 1)
        {
            var invt = (1.0 - t);
            var invt2 = (invt * invt);
            var invt3 = (invt2 * invt);
            var t2 = (t * t);
            var t3 = (t2 * t);
            var tinvt = (3 * t * invt2);
            var invtt = (3 * t2 * invt);
            currentSubPath[numCurrentSubPathElements] = [((invt3 * x1) + (tinvt * xq1) + (invtt * xq2) + (t3 * x2)),
                                                         ((invt3 * y1) + (tinvt * yq1) + (invtt * yq2) + (t3 * y2))];
            numCurrentSubPathElements += 1;
        }

        currentSubPath[numCurrentSubPathElements] = [x2, y2];
    },

    arcTo : function arcToFn(x1, y1, x2, y2, radius)
    {
        if (radius < 0)
        {
            throw 'INDEX_SIZE_ERR';
        }

        var x0, y0;

        var currentSubPath = this.currentSubPath;
        var numCurrentSubPathElements = currentSubPath.length;
        if (numCurrentSubPathElements === 0)
        {
            currentSubPath[0] = this.transformPoint(x1, y1);
            numCurrentSubPathElements = 1;

            x0 = x1;
            y0 = y1;
        }
        else
        {
            var p0 = this.untransformPoint(currentSubPath[numCurrentSubPathElements - 1]);
            x0 = p0[0];
            y0 = p0[1];
        }

        var dx0 = (x0 - x1);
        var dy0 = (y0 - y1);
        var ln0 = ((dx0 * dx0) + (dy0 * dy0));

        var dx2 = (x2 - x1);
        var dy2 = (y2 - y1);
        var ln2 = ((dx2 * dx2) + (dy2 * dy2));

        if (radius < 2 ||
            ln0 < 2 ||
            ln2 < 2)
        {
            currentSubPath.push(this.transformPoint(x1, y1));
        }
        else
        {
            var sqrt = Math.sqrt;
            var acos = Math.acos;
            var pi = Math.PI;

            ln0 = 1.0 / sqrt(ln0);
            dx0 *= ln0;
            dy0 *= ln0;

            ln2 = 1.0 / sqrt(ln2);
            dx2 *= ln2;
            dy2 *= ln2;

            // Calculate unit vector from x1 to center
            var dxc = (dx0 + dx2);
            var dyc = (dy0 + dy2);
            var lnc = (1.0 / sqrt((dxc * dxc) + (dyc * dyc)));
            dxc *= lnc;
            dyc *= lnc;

            // Calculate angle from vector to center with the vector to x2 using dot product
            // Use it to calculate distance to center
            var dot = ((dxc * dx2) + (dyc * dy2));
            var h = (radius / dot); // dot = Math.cos(angle)

            var cp = this.transformPoint((x1 + (h * dxc)),
                                         (y1 + (h * dyc)));
            var cx = cp[0];
            var cy = cp[1];

            var anticlockwise = (((dx0 * dy2) - (dx2 * dy0)) > 0);

            var da = acos(-dxc);
            if (dyc < 0)
            {
                da = -da;
            }
            da = ((0.5 * pi) - da);

            var angle = acos(dot);
            var startAngle = (pi + angle + da);
            var endAngle = ((2 * pi) - angle + da);
            if (anticlockwise)
            {
                this.interpolateArc(cx, cy, radius, endAngle, startAngle, true);
            }
            else
            {
                this.interpolateArc(cx, cy, radius, startAngle, endAngle);
            }
        }
    },

    arc : function arcFn(x, y, radius, startAngle, endAngle, anticlockwise)
    {
        if (radius < 0)
        {
            throw 'INDEX_SIZE_ERR';
        }

        var cp = this.transformPoint(x, y);

        var currentSubPath = this.currentSubPath;

        if (radius < 2.0)
        {
            currentSubPath.push(cp);
        }
        else
        {
            this.interpolateArc(cp[0], cp[1], radius, startAngle, endAngle, anticlockwise);
        }
    },

    rect : function rectFn(x, y, w, h)
    {
        var subPaths = this.subPaths;
        var numSubPaths = subPaths.length;
        var currentSubPath = this.currentSubPath;
        if (currentSubPath.length > 1)
        {
            subPaths[numSubPaths] = currentSubPath;
            numSubPaths += 1;
        }

        var rect = this.transformRect(x, y, w, h);
        var p0 = rect[0];
        var p1 = rect[1];
        var p2 = rect[2];
        var p3 = rect[3];

        subPaths[numSubPaths] = [p2, p3, p1, p0, p2];

        this.currentSubPath = [p0];
    },

    path : function pathFn(path)
    {
        var end = path.length;
        var currentCommand = -1, previousCommand = -1;
        var i = 0;

        function skipWhiteSpace()
        {
            var c = path.charCodeAt(i);
            while (c <= 32 || c === 44) // whitespace or ,
            {
                i += 1;
                if (i >= end)
                {
                    return -1;
                }
                c = path.charCodeAt(i);
            }
            return c;
        }

        function readNumber()
        {
            var c = path.charCodeAt(i);
            while (c <= 32 || c === 44) // whitespace or ,
            {
                i += 1;
                if (i >= end)
                {
                    throw "Reached end of string without required coordinate.";
                }
                c = path.charCodeAt(i);
            }

            var start = i;

            if (c === 45 || //-
                c === 43) //+
            {
                i += 1;
                if (i >= end)
                {
                    return 0;
                }
                c = path.charCodeAt(i);
            }

            while (c >= 48 && c <= 57) //0-9
            {
                i += 1;
                if (i >= end)
                {
                    break;
                }
                c = path.charCodeAt(i);
            }

            if (c === 46 || //.
                c === 101 || //e
                c === 101) //E
            {
                if (c === 46) //.
                {
                    do
                    {
                        i += 1;
                        if (i >= end)
                        {
                            break;
                        }
                        c = path.charCodeAt(i);
                    }
                    while (c >= 48 && c <= 57); //0-9
                }

                if (c === 101 || //e
                    c === 101) //E
                {
                    i += 1;
                    if (i < end)
                    {
                        c = path.charCodeAt(i);

                        if (c === 45 || //-
                            c === 43) //+
                        {
                            i += 1;
                            if (i < end)
                            {
                                c = path.charCodeAt(i);
                            }
                        }

                        while (c >= 48 && c <= 57) //0-9
                        {
                            i += 1;
                            if (i >= end)
                            {
                                break;
                            }
                            c = path.charCodeAt(i);
                        }
                    }
                }

                return parseFloat(path.slice(start, i));
            }
            else
            {
                return parseInt(path.slice(start, i), 10);
            }
        }

        function readFlag()
        {
            var c = skipWhiteSpace();
            if (c < -1)
            {
                throw "Reached end of string without required flag.";
            }

            if (c === 48) //0
            {
                i += 1;
                return false;
            }
            else if (c === 49) //1
            {
                i += 1;
                return true;
            }
            else
            {
                throw "Unknown flag: " + path.slice(i);
            }
        }

        function getRatio(u, v)
        {
            var u0 = u[0];
            var u1 = u[1];
            var v0 = v[0];
            var v1 = v[1];
            return ((u0 * v0) + (u1 * v1)) / Math.sqrt(((u0 * u0) + (u1 * u1)) * ((v0 * v0) + (v1 * v1)));
        }

        function getAngle(u, v)
        {
            return ((u[0] * v[1]) < (u[1] * v[0]) ? -1 : 1) * Math.acos(getRatio(u, v));
        }

        var lx = 0;
        var ly = 0;

        var x, y, x1, y1, x2, y2;
        var rx, ry, angle, largeArcFlag, sweepFlag;

        while (i < end)
        {
            // Skip whitespace
            var c = skipWhiteSpace();
            if (c < 0)
            {
                // end of string
                return;
            }

            // Same command, new arguments?
            if (c === 43 || //+
                c === 45 || //-
                c === 46 || //.
                (c >= 48 && c <= 57)) //0-9
            {
                if (currentCommand < 0)
                {
                    throw "Coordinates without a command: " + path.slice(i);
                }
                else
                {
                    // Implicit lineTo after moveTo?
                    if (currentCommand === 77) //M
                    {
                        currentCommand = 76; //L
                    }
                    else if (currentCommand === 109) //m
                    {
                        currentCommand = 108; //l
                    }
                }
            }
            else
            {
                previousCommand = currentCommand;
                currentCommand = c;
                i += 1;
            }

            switch (currentCommand)
            {
            case 77: //M
            case 109: //m
                x = readNumber();
                y = readNumber();
                if (currentCommand === 109) //m
                {
                    x += lx;
                    y += ly;
                }
                this.moveTo(x, y);
                break;

            case 76: //L
            case 108: //l
                x = readNumber();
                y = readNumber();
                if (currentCommand === 108) //l
                {
                    x += lx;
                    y += ly;
                }
                this.lineTo(x, y);
                break;

            case 72: //H
            case 104: //h
                x = readNumber();
                if (currentCommand === 104) //h
                {
                    x += lx;
                }
                y = ly;
                this.lineTo(x, y);
                break;

            case 86: //V
            case 118: //v
                x = lx;
                y = readNumber();
                if (currentCommand === 118) //v
                {
                    y += ly;
                }
                this.lineTo(x, y);
                break;

            case 67: //C
            case 99: //c
                x1 = readNumber();
                y1 = readNumber();
                x2 = readNumber();
                y2 = readNumber();
                x = readNumber();
                y = readNumber();
                if (currentCommand === 99) //c
                {
                    x1 += lx;
                    y1 += ly;
                    x2 += lx;
                    y2 += ly;
                    x += lx;
                    y += ly;
                }
                this.bezierCurveTo(x1, y1, x2, y2, x, y);
                break;

            case 83: //S
            case 115: //s
                if (previousCommand === 67 || //C
                    previousCommand === 99 || //c
                    previousCommand === 83 || //S
                    previousCommand === 115) //s
                {
                    x1 = ((2 * lx) - x2);
                    y1 = ((2 * ly) - y2);
                }
                else
                {
                    x1 = lx;
                    y1 = ly;
                }
                x2 = readNumber();
                y2 = readNumber();
                x = readNumber();
                y = readNumber();
                if (currentCommand === 115) //s
                {
                    x2 += lx;
                    y2 += ly;
                    x += lx;
                    y += ly;
                }
                this.bezierCurveTo(x1, y1, x2, y2, x, y);
                break;

            case 81: //Q
            case 113: //q
                x1 = readNumber();
                y1 = readNumber();
                x = readNumber();
                y = readNumber();
                if (currentCommand === 113) //q
                {
                    x1 += lx;
                    y1 += ly;
                    x += lx;
                    y += ly;
                }
                this.quadraticCurveTo(x1, y1, x, y);
                break;

            case 84: //T
            case 116: //t
                if (previousCommand === 81 || //Q
                    previousCommand === 113 || //q
                    previousCommand === 84 || //T
                    previousCommand === 116) //t
                {
                    x1 = ((2 * lx) - x1);
                    y1 = ((2 * ly) - y1);
                }
                else
                {
                    x1 = lx;
                    y1 = ly;
                }
                x = readNumber();
                y = readNumber();
                if (currentCommand === 116) //t
                {
                    x += lx;
                    y += ly;
                }
                this.quadraticCurveTo(x1, y1, x, y);
                break;

            case 65: //A
            case 97: //a
                var pi = Math.PI;
                x1 = lx;
                y1 = ly;
                rx = readNumber();
                ry = readNumber();
                angle = (readNumber() * (pi / 180.0));
                largeArcFlag = readFlag();
                sweepFlag = readFlag();
                x = readNumber();
                y = readNumber();
                if (currentCommand === 97) //a
                {
                    x += lx;
                    y += ly;
                }

                var sqrt = Math.sqrt;
                var ca = Math.cos(angle);
                var sa = Math.sin(angle);

                var hdx = (x1 - x) * 0.5;
                var hdy = (y1 - y) * 0.5;
                var x1b = ca * hdx + sa * hdy;
                var x1b2 = (x1b * x1b);
                var y1b = -sa * hdx + ca * hdy;
                var y1b2 = (y1b * y1b);

                // adjust radii
                var l = x1b2 / (rx * rx) + y1b2 / (ry * ry);
                if (l > 1)
                {
                    var lsq = sqrt(l);
                    rx *= lsq;
                    ry *= lsq;
                }

                var rx2 = (rx * rx);
                var invrx = (1 / rx);
                var ry2 = (ry * ry);
                var invry = (1 / ry);

                // cx', cy'
                var s = (largeArcFlag === sweepFlag ? -1 : 1) * sqrt(
                        ((rx2 * ry2) - (rx2 * y1b2) - (ry2 * x1b2)) / (rx2 * y1b2 + ry2 * x1b2));
                if (isNaN(s))
                {
                    s = 0;
                }
                var cxb = s * rx * y1b * invry;
                var cyb = s * -ry * x1b * invrx;

                var cx = (x1 + x) * 0.5 + ca * cxb - sa * cyb;
                var cy = (y1 + y) * 0.5 + sa * cxb + ca * cyb;

                var u = [(x1b - cxb) * invrx, (y1b - cyb) * invry];
                var v = [(-x1b - cxb) * invrx, (-y1b - cyb) * invry];

                // initial angle
                var a1 = getAngle([1, 0], u);

                // angle delta
                var ad;
                var ratio = getRatio(u, v);
                if (ratio <= -1)
                {
                    ad = pi;
                }
                else if (ratio >= 1)
                {
                    ad = 0;
                }
                else
                {
                    ad = getAngle(u, v);
                }

                if (!sweepFlag)
                {
                    if (ad > 0)
                    {
                        ad = ad - (2 * pi);
                    }
                }
                else //if (sweepFlag)
                {
                    if (ad < 0)
                    {
                        ad = ad + (2 * pi);
                    }
                }

                var radius, sx, sy;
                if (rx === ry)
                {
                    radius = rx;
                    sx = 1;
                    sy = 1;
                }
                else if (rx > ry)
                {
                    radius = rx;
                    sx = 1;
                    sy = ry * invrx;
                }
                else //if (rx < ry)
                {
                    radius = ry;
                    sx = rx * invry;
                    sy = 1;
                }

                if (angle !== 0 || sx !== 1 || sy !== 1)
                {
                    this.translate(cx, cy);
                    if (angle !== 0)
                    {
                        this.rotate(angle);
                    }
                    if (sx !== 1 || sy !== 1)
                    {
                        this.scale(sx, sy);
                    }

                    this.arc(0, 0, radius, a1, (a1 + ad), (true - sweepFlag));

                    if (sx !== 1 || sy !== 1)
                    {
                        this.scale((1 / sx), (1 / sy));
                    }
                    if (angle !== 0)
                    {
                        this.rotate(-angle);
                    }
                    this.translate(-cx, -cy);
                }
                else
                {
                    this.arc(cx, cy, radius, a1, (a1 + ad), (true - sweepFlag));
                }
                break;

            case 90: //Z
            case 122: //z
                var firstPoint = this.currentSubPath[0];
                x = firstPoint[0];
                y = firstPoint[1];
                this.closePath();
                break;

            default:
                throw "Unknown command: " + path.slice(i);
            }

            lx = x;
            ly = y;
        }
    },

    fill : function fillFn()
    {
        var subPaths = this.subPaths;
        var numSubPaths = subPaths.length;
        var currentSubPath = this.currentSubPath;
        if (numSubPaths > 0 ||
            currentSubPath.length > 2)
        {
            var autoClose = this.autoClose;
            var isConvex = this.isConvex;
            var points, numPoints, numSegments;

            var style = this.fillStyle;

            var primitive;
            var vertices;
            var numVertices = 0;

            if (numSubPaths > 1 ||
                (numSubPaths === 1 &&
                 currentSubPath.length > 2))
            {
                primitive = this.trianglePrimitive;
                vertices = this.tempVertices;

                for (var i = 0; i < numSubPaths; i += 1)
                {
                    points = subPaths[i];
                    numPoints = points.length;
                    if (numPoints > 2)
                    {
                        numPoints = autoClose(points, numPoints);
                        numSegments = (numPoints - 1);
                        if (isConvex(points, numSegments))
                        {
                            numVertices = this.triangulateConvex(points, numSegments, vertices, numVertices);
                        }
                        else
                        {
                            numVertices = this.triangulateConcave(points, numSegments, vertices, numVertices);
                        }
                    }
                }

                points = currentSubPath;
                numPoints = points.length;
                if (numPoints > 2)
                {
                    numPoints = autoClose(points, numPoints);
                    numSegments = (numPoints - 1);
                    if (isConvex(points, numSegments))
                    {
                        numVertices = this.triangulateConvex(points, numSegments, vertices, numVertices);
                    }
                    else
                    {
                        numVertices = this.triangulateConcave(points, numSegments, vertices, numVertices);
                    }
                }
            }
            else
            {
                if (numSubPaths > 0)
                {
                    points = subPaths[0];
                }
                else
                {
                    points = currentSubPath;
                }

                numPoints = points.length;
                if (numPoints > 2)
                {
                    numPoints = autoClose(points, numPoints);
                    numSegments = (numPoints - 1);

                    if (isConvex(points, numSegments))
                    {
                        primitive = this.triangleFanPrimitive;
                        vertices = points;
                        numVertices = numSegments;
                    }
                    else
                    {
                        primitive = this.trianglePrimitive;
                        vertices = this.tempVertices;
                        numVertices = this.triangulateConcave(points, numSegments, vertices, 0);
                    }
                }
            }

            if (numVertices > 0)
            {
                this.fillFlatVertices(vertices, numVertices);

                var gd = this.gd;

                if (this.setShadowStyle(style))
                {
                    gd.draw(primitive, numVertices);
                }

                this.setStyle(style);

                gd.draw(primitive, numVertices);
            }
        }
    },

    stroke : function strokeFn()
    {
        var subPaths = this.subPaths;
        var numSubPaths = subPaths.length;
        var currentSubPath = this.currentSubPath;
        if (numSubPaths > 0 ||
            currentSubPath.length > 0)
        {
            var gd = this.gd;
            var style = this.strokeStyle;
            var lineWidth = this.lineWidth;
            var thinLines = (lineWidth < 2 && !this.forceFatLines);

            var points, numPoints, primitive, vertices, numVertices;

            for (var i = 0; i < numSubPaths; i += 1)
            {
                points = subPaths[i];
                numPoints = points.length;
                if (thinLines)
                {
                    primitive = this.lineStripPrimitive;
                    vertices = points;
                    numVertices = numPoints;
                }
                else if (numPoints > 1)
                {
                    primitive = this.triangleStripPrimitive;
                    vertices = this.tempVertices;
                    numVertices = this.triangulateFatStrip(points, numPoints, lineWidth, vertices, 0);
                }

                this.fillFlatVertices(vertices, numVertices);

                if (this.setShadowStyle(style))
                {
                    gd.draw(primitive, numVertices);
                }

                this.setStyle(style);

                gd.draw(primitive, numVertices);
            }

            points = currentSubPath;
            numPoints = points.length;
            if (numPoints > 0)
            {
                if (thinLines)
                {
                    primitive = this.lineStripPrimitive;
                    vertices = points;
                    numVertices = numPoints;
                }
                else if (numPoints > 1)
                {
                    primitive = this.triangleStripPrimitive;
                    vertices = this.tempVertices;
                    numVertices = this.triangulateFatStrip(points, numPoints, lineWidth, vertices, 0);
                }

                this.fillFlatVertices(vertices, numVertices);

                if (this.setShadowStyle(style))
                {
                    gd.draw(primitive, numVertices);
                }

                this.setStyle(style);

                gd.draw(primitive, numVertices);
            }
        }
    },


    drawSystemFocusRing : function drawSystemFocusRingFn(element)
    {
        // TODO
    },

    drawCustomFocusRing : function drawCustomFocusRingFn(element)
    {
        // TODO
        return false;
    },

    scrollPathIntoView : function scrollPathIntoViewFn()
    {
        // TODO
    },

    clip : function clipFn()
    {
        // Get copy of sub paths
        var points, numPoints, i, j, point, x, y;
        var numClipSubPaths = 0;
        var clipSubPaths = [];

        var subPaths = this.subPaths;
        var numSubPaths = subPaths.length;
        if (numSubPaths > 0)
        {
            clipSubPaths.length = numSubPaths;
            i = 0;
            do
            {
                points = subPaths[i];
                if (points.length > 2)
                {
                    clipSubPaths[numClipSubPaths] = points.slice();
                    numClipSubPaths += 1;
                }

                i += 1;
            }
            while (i < numSubPaths);
        }

        var currentSubPath = this.currentSubPath;
        if (currentSubPath.length > 2)
        {
            clipSubPaths[numClipSubPaths] = currentSubPath.slice();
            numClipSubPaths += 1;
        }

        if (numClipSubPaths === 0)
        {
            return;
        }

        var autoClose = this.autoClose;

        // Calculate bounding box of current path
        var minX, minY, maxX, maxY;
        i = 0;
        do
        {
            points = clipSubPaths[i];
            numPoints = autoClose(points, points.length);

            j = 0;

            if (minX === undefined)
            {
                point = points[0];
                minX = maxX = point[0];
                minY = maxY = point[1];
                j = 1;
            }

            do
            {
                point = points[j];
                x = point[0];
                y = point[1];

                if (minX > x)
                {
                    minX = x;
                }
                else if (maxX < x)
                {
                    maxX = x;
                }

                if (minY > y)
                {
                    minY = y;
                }
                else if (maxY < y)
                {
                    maxY = y;
                }

                j += 1;
            }
            while (j < numPoints);

            i += 1;
        }
        while (i < numClipSubPaths);

        // Intersect current clipExtents with bounding boxes of current paths
        var clipExtents = this.clipExtents;
        var minClipX = clipExtents[0];
        var minClipY = clipExtents[1];
        var maxClipX = clipExtents[2];
        var maxClipY = clipExtents[3];
        minClipX = (minClipX > minX ? minClipX : minX);
        minClipY = (minClipY > minY ? minClipY : minY);
        maxClipX = (maxClipX < maxX ? maxClipX : maxX);
        maxClipY = (maxClipY < maxY ? maxClipY : maxY);
        clipExtents[0] = minClipX;
        clipExtents[1] = minClipY;
        clipExtents[2] = maxClipX;
        clipExtents[3] = maxClipY;

        // Update scissor rectangle to at least have rectangular clipping
        this.updateScissor();

        // TODO: non rectangular clipping
    },

    isPointInPath : function isPointInPathFn(x, y)
    {
        var subPaths = this.subPaths;
        var numSubPaths = subPaths.length;
        if (numSubPaths > 0)
        {
            for (var i = 0; i < numSubPaths; i += 1)
            {
                if (this.isPointInSubPath(x, y, subPaths[i]))
                {
                    return true;
                }
            }
        }

        var currentSubPath = this.currentSubPath;
        if (this.isPointInSubPath(x, y, currentSubPath))
        {
            return true;
        }

        return false;
    },


    fillText : function fillTextFn(text, x, y, maxWidth)
    {
        if (maxWidth !== undefined && maxWidth <= 0)
        {
            return;
        }

        var fm = this.fm;
        if (!fm)
        {
            return;
        }

        var fontName = this.buildFontName();
        if (!fontName)
        {
            return;
        }

        var font = fm.load(fontName);
        if (!font)
        {
            return;
        }

        if (!maxWidth)
        {
            maxWidth = this.width;
        }

        var color;

        var style = this.fillStyle;
        if (typeof style === 'string') // CSS Color
        {
            color = this.parseColor(style);
        }
        else
        {
            // TODO
            color = this.v4One;
        }

        // No need to pre-multiply RGB by alpha for texture shaders
        var globalAlpha = this.globalAlpha;
        if (globalAlpha < 1.0)
        {
            color = this.md.v4Build(color[0], color[1], color[2], (color[3] * globalAlpha), this.tempColor);
        }

        var technique = this.textureTechniques[this.globalCompositeOperation];
        if (!technique)
        {
            throw "Unknown composite operation: " + this.globalCompositeOperation;
        }

        var gd = this.gd;

        gd.setTechnique(technique);

        technique.screen = this.screen;

        technique.color = color;

        var rect = this.transformRect(x, y, maxWidth, maxWidth);
        var p1 = rect[1];
        var p2 = rect[2];
        x = p2[0];
        y = p2[1];

        var scale = this.calculateFontScale(font);

        if (this.textBaseline === 'alphabetic')
        {
            y -= (font.baseline * scale);
        }
        else if (this.textBaseline === 'middle')
        {
            y -= ((font.baseline * 0.5) * scale);
        }
        else if (this.textBaseline === 'bottom' ||
                 this.textBaseline === 'ideographic')
        {
            y -= (font.lineHeight * scale);
        }

        var params = {
            rect : [x, y, (p1[0] - x), (p1[1] - y)],
            scale : scale,
            spacing : 0
        };

        if (this.textAlign === "left" ||
            this.textAlign === "start")
        {
            params.alignment = 0;
        }
        else if (this.textAlign === "right" ||
                 this.textAlign === "end")
        {
            params.alignment = 2;
        }
        else
        {
            params.alignment = 1;
        }

        font.drawTextRect(text, params);
    },

    strokeText : function strokeTextFn(text, x, y, maxWidth)
    {
        // TODO
    },

    measureText : function measureTextFn(text)
    {
        var fm = this.fm;
        if (fm)
        {
            var fontName = this.buildFontName();
            if (fontName)
            {
                var font = fm.load(fontName);
                if (font)
                {
                    var scale = this.calculateFontScale(font);
                    return {
                            width : font.calculateTextDimensions(text, scale, 0).width
                        };
                }
            }
        }

        return {
                width : 0
            };
    },


    drawImage : function drawImageFn(image)
    {
        var dx, dy, dw, dh, u0, v0, u1, v1;

        if (arguments.length >= 7)
        {
            var sx = arguments[1];
            var sy = arguments[2];
            var sw = arguments[3];
            var sh = arguments[4];

            dx = arguments[5];
            dy = arguments[6];

            if (arguments.length >= 9)
            {
                dw = arguments[7];
                dh = arguments[8];
            }
            else
            {
                dw = sw;
                dh = sh;
            }

            var invImageWidth  = (1.0 / image.width);
            var invImageHeight = (1.0 / image.height);
            u0 = (sx * invImageWidth);
            v0 = (sy * invImageHeight);
            u1 = ((sx + sw) * invImageWidth);
            v1 = ((sy + sh) * invImageHeight);
        }
        else
        {
            dx = arguments[1];
            dy = arguments[2];

            if (arguments.length >= 5)
            {
                dw = arguments[3];
                dh = arguments[4];
            }
            else
            {
                dw = image.width;
                dh = image.height;
            }

            u0 = 0;
            v0 = 0;
            u1 = 1;
            v1 = 1;
        }

        if (dw > 0 && dh > 0)
        {
            var writer = this.mapTextureBuffer(4);
            if (writer)
            {
                var rect = this.transformRect(dx, dy, dw, dh);
                var p0 = rect[0];
                var p1 = rect[1];
                var p2 = rect[2];
                var p3 = rect[3];

                var x0 = p0[0];
                var y0 = p0[1];
                var x1 = p1[0];
                var y1 = p1[1];
                var x2 = p2[0];
                var y2 = p2[1];
                var x3 = p3[0];
                var y3 = p3[1];

                writer(x0, y0, u0, v1);
                writer(x1, y1, u1, v1);
                writer(x2, y2, u0, v0);
                writer(x3, y3, u1, v0);

                this.unmapTextureBuffer(writer);
                writer = null;

                var primitive = this.triangleStripPrimitive;
                var gd = this.gd;

                if (this.setShadowStyle(image, true))
                {
                    gd.draw(primitive, 4);
                }

                var technique = this.textureTechniques[this.globalCompositeOperation];
                if (!technique)
                {
                    throw "Unknown composite operation: " + this.globalCompositeOperation;
                }

                gd.setTechnique(technique);

                technique.screen = this.screen;
                technique.texture = image;

                var globalAlpha = this.globalAlpha;
                if (globalAlpha < 1.0)
                {
                    technique.color = this.md.v4Build(1.0, 1.0, 1.0, globalAlpha, this.tempColor);
                }
                else
                {
                    technique.color = this.v4One;
                }

                gd.draw(primitive, 4);
            }
        }
    },


    createImageData : function createImageDataFn()
    {
        var sw, sh;
        if (arguments.length === 2)
        {
            sw = arguments[0];
            sh = arguments[1];
        }
        else if (arguments.length === 1)
        {
            var imagedata = arguments[0];
            sw = imagedata.width;
            sh = imagedata.height;
        }
        else
        {
            throw "Wrong arguments";
        }

        var numValues = (sw * sh * 4);
        var pixelData = new this.arrayTypeConstructor(numValues);
        for (var i = 0; i < numValues; i += 1)
        {
            pixelData[i] = 0;
        }

        return {
            width : sw,
            height : sh,
            data : pixelData
        };
    },

    getImageData : function getImageDataFn(sx, sy, sw, sh)
    {
        var gd = this.gd;

        // Convert from top-left to bottom-left
        sy = (this.height - (sy + sh));

        var pixelData = gd.getScreenshot(false, sx, sy, sw, sh);

        return {
            width : sw,
            height : sh,
            data : pixelData
        };
    },

    putImageData : function putImageDataFn(imagedata, dx, dy)
    {
        if (!imagedata || !imagedata.data)
        {
            throw 'TYPE_MISMATCH_ERR';
        }

        var imageWidth  = imagedata.width;
        var imageHeight = imagedata.height;

        var dirtyX, dirtyY, dirtyWidth, dirtyHeight;
        if (arguments.length >= 7)
        {
            dirtyX = arguments[3];
            dirtyY = arguments[4];
            dirtyWidth = arguments[5];
            dirtyHeight = arguments[6];
        }
        else
        {
            dirtyX = 0;
            dirtyY = 0;
            dirtyWidth = imageWidth;
            dirtyHeight = imageHeight;
        }

        if (dirtyWidth && dirtyHeight)
        {
            var gd = this.gd;

            var tempImage = this.tempImage;
            if (tempImage === null ||
                tempImage.width !== dirtyWidth ||
                tempImage.height !== dirtyHeight)
            {
                this.tempImage = tempImage = gd.createTexture({
                        name    : ('imageData:' + dirtyWidth + 'x' + dirtyHeight),
                        width   : dirtyWidth,
                        height  : dirtyHeight,
                        depth   : 1,
                        format  : gd.PIXELFORMAT_R8G8B8A8,
                        cubemap : false,
                        mipmaps : false
                    });
            }

            tempImage.setData(imagedata.data);

            var viewport = this.viewport;
            gd.setScissor(viewport[0], viewport[1], viewport[2], viewport[3]);

            var writer = this.mapTextureBuffer(4);
            if (writer)
            {
                var invCanvasWidth  = 2.0 / this.width;
                var invCanvasHeight = 2.0 / this.height;
                var x0 = ((dx * invCanvasWidth)  - 1);
                var y0 = (1 - (dy * invCanvasHeight));
                var x1 = (((dx + dirtyWidth)  * invCanvasWidth)  - 1);
                var y1 = (1 - ((dy + dirtyHeight) * invCanvasHeight));

                var invImageWidth  = 1.0 / imageWidth;
                var invImageHeight = 1.0 / imageHeight;
                var u0 = (dirtyX * invImageWidth);
                var v0 = (dirtyY * invImageHeight);
                var u1 = ((dirtyX + dirtyWidth)  * invImageWidth);
                var v1 = ((dirtyY + dirtyHeight) * invImageHeight);

                writer(x0, y1, u0, v1);
                writer(x1, y1, u1, v1);
                writer(x0, y0, u0, v0);
                writer(x1, y0, u1, v0);

                this.unmapTextureBuffer(writer);
                writer = null;

                var technique = this.imageTechnique;

                gd.setTechnique(technique);

                technique.image = tempImage;

                gd.draw(this.triangleStripPrimitive, 4);
            }

            this.updateScissor();
        }
    },

    //
    // Public Turbulenz Canvas Context API
    //
    beginFrame : function beginFrameFn(target, viewportRect)
    {
        if (this.target)
        {
            throw '"endFrame" was never called!';
        }

        var gd = this.gd;

        if (!target)
        {
            target = gd;
        }

        this.target = target;

        var viewport = this.viewport;

        if (viewportRect)
        {
            viewport[0] =  viewportRect[0];
            viewport[1] =  viewportRect[1];
            viewport[2] =  viewportRect[2];
            viewport[3] =  viewportRect[3];
        }
        else
        {
            viewport[0] =  0;
            viewport[1] =  0;
            viewport[2] =  target.width;
            viewport[3] =  target.height;
        }

        gd.setViewport(viewport[0], viewport[1], viewport[2], viewport[3]);

        /* This code is required if Object.defineProperty does not work */
        var canvas = this.canvas;
        var width = canvas.width;
        var height = canvas.height;
        if (width !== this.width ||
            height !== this.height)
        {
            this.width = width;
            this.height = height;

            this.screen[0] = (2 / width);
            this.screen[1] = (-2 / height);

            this.resetState();

            this.clearRect(0, 0, width, height);
        }

        this.forceFatLines = ((2 * width) <= viewport[2] ||
                              (2 * height) <= viewport[3]);

        this.updateScissor();

        return true;
    },

    endFrame : function endFrameFn()
    {
        if (!this.target)
        {
            throw '"beginFrame" was never called!';
        }

        this.target = null;

        var viewport = this.viewport;
        var v0 = viewport[0];
        var v1 = viewport[1];
        var v2 = viewport[2];
        var v3 = viewport[3];

        var gd = this.gd;

        gd.setViewport(v0, v1, v2, v3);
        gd.setScissor(v0, v1, v2, v3);
    },

    //
    // Private API
    //
    setWidth : function setWidthFn(width)
    {
        this.width = width;
        this.screen[0] = (2 / width);

        this.resetState();

        if (this.target)
        {
            this.clearRect(0, 0, width, this.height);
        }
    },

    setHeight : function setHeightFn(height)
    {
        this.height = height;
        this.screen[1] = (-2 / height);

        this.resetState();

        if (this.target)
        {
            this.clearRect(0, 0, this.width, height);
        }
    },

    getStates : function getStatesFn()
    {
        return {
            globalAlpha : this.globalAlpha,
            globalCompositeOperation : this.globalCompositeOperation,
            strokeStyle : this.strokeStyle,
            fillStyle : this.fillStyle,
            lineWidth : this.lineWidth,
            lineCap : this.lineCap,
            lineJoin : this.lineJoin,
            miterLimit : this.miterLimit,
            shadowOffsetX : this.shadowOffsetX,
            shadowOffsetY : this.shadowOffsetY,
            shadowBlur : this.shadowBlur,
            shadowColor : this.shadowColor,
            font : this.font,
            textAlign : this.textAlign,
            textBaseline : this.textBaseline,
            matrix : this.matrix.slice(),
            scale : this.scale,
            translate : this.translate,
            transform : this.transform,
            setTransform : this.setTransform,
            transformPoint : this.transformPoint,
            transformRect : this.transformRect,
            clipExtents : this.clipExtents.slice()
        };
    },

    setStates : function setStatesFn(states)
    {
        this.globalAlpha = states.globalAlpha;
        this.globalCompositeOperation = states.globalCompositeOperation;
        this.strokeStyle = states.strokeStyle;
        this.fillStyle = states.fillStyle;
        this.lineWidth = states.lineWidth;
        this.lineCap = states.lineCap;
        this.lineJoin = states.lineJoin;
        this.miterLimit = states.miterLimit;
        this.shadowOffsetX = states.shadowOffsetX;
        this.shadowOffsetY = states.shadowOffsetY;
        this.shadowBlur = states.shadowBlur;
        this.shadowColor = states.shadowColor;
        this.font = states.font;
        this.textAlign = states.textAlign;
        this.textBaseline = states.textBaseline;

        // Have to copy array elements because if we keep a reference we modify the default ones
        var newMatrix = states.matrix;
        var oldMatrix = this.matrix;
        oldMatrix[0] = newMatrix[0];
        oldMatrix[1] = newMatrix[1];
        oldMatrix[2] = newMatrix[2];
        oldMatrix[3] = newMatrix[3];
        oldMatrix[4] = newMatrix[4];
        oldMatrix[5] = newMatrix[5];

        this.scale = states.scale;
        this.translate = states.translate;
        this.transform = states.transform;
        this.setTransform = states.setTransform;
        this.transformPoint = states.transformPoint;
        this.transformRect = states.transformRect;

        var newExtents = states.clipExtents;
        var oldExtents = this.clipExtents;
        oldExtents[0] = newExtents[0];
        oldExtents[1] = newExtents[1];
        oldExtents[2] = newExtents[2];
        oldExtents[3] = newExtents[3];
    },

    resetState : function resetStateFn()
    {
        this.statesStack.length = 0;

        this.beginPath();

        this.setStates(this.defaultStates);

        var clipExtents = this.clipExtents;
        clipExtents[0] = 0;
        clipExtents[1] = 0;
        clipExtents[2] = this.width;
        clipExtents[3] = this.height;
    },

    updateScissor : function updateScissorFn()
    {
        // Set scissor rectangle to intersection of viewport with clipExtents,
        // in OpengGL screen coordinates (0, 0) at bottom
        var viewport = this.viewport;
        var viewportX = viewport[0];
        var viewportY = viewport[1];
        var viewportWidth = viewport[2];
        var viewportHeight = viewport[3];

        var deviceScaleX = (viewportWidth / this.width);
        var deviceScaleY = (viewportHeight / this.height);

        var clipExtents = this.clipExtents;
        var minClipX = (clipExtents[0] * deviceScaleX);
        var minClipY = (clipExtents[1] * deviceScaleY);
        var maxClipX = (clipExtents[2] * deviceScaleX);
        var maxClipY = (clipExtents[3] * deviceScaleY);

        this.gd.setScissor((viewportX + minClipX),
                           (viewportY + (viewportHeight - maxClipY)),
                           (maxClipX - minClipX),
                           (maxClipY - minClipY));
    },


    setFontManager : function setFontManagerFn(fm)
    {
        this.fm = fm;
    },

    buildFontName : function buildFontNameFn()
    {
        var fontName;
        var font = this.font;
        var lastSpace = font.lastIndexOf(" ");
        if (lastSpace !== -1)
        {
            fontName = ('fonts/' + font.substr(lastSpace + 1) + '.fnt');
        }
        return fontName;
    },

    calculateFontScale : function calculateFontScaleFn(font)
    {
        var requiredHeight = parseInt(this.font, 10);
        if (isNaN(requiredHeight))
        {
            return 1;
        }
        else
        {
            return (requiredHeight / font.lineHeight);
        }
    },

    transformPoint : function transformPointFn(x, y)
    {
        var m = this.matrix;
        return [((x * m[0]) + (y * m[1]) + m[2]),
                ((x * m[3]) + (y * m[4]) + m[5])];
    },

    transformRect : function transformRectFn(x, y, w, h)
    {
        var m = this.matrix;
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];

        var bx = ((x * m0) + (y * m1) + m2);
        var by = ((x * m3) + (y * m4) + m5);
        var dx0 = (w * m0);
        var dy0 = (h * m1);
        var dx1 = (w * m3);
        var dy1 = (h * m4);

        return [[(bx + dy0), (by + dy1)],
                [(bx + dx0 + dy0), (by + dx1 + dy1)],
                [bx, by],
                [(bx + dx0), (by + dx1)]];
    },

    untransformPoint : function untransformPointFn(p)
    {
        var m = this.matrix;
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];

        var x = p[0];
        var y = p[1];

        // invert matrix
        var r0, r1, r2, r3, r4, r5;

        var det = (m0 * m4 - m1 * m3);
        if (det === 0.0)
        {
            return [x, y];
        }

        r0 = m4;
        r3 = -m3;
        r1 = -m1;
        r4 = m0;
        r2 = (m1 * m5 - m4 * m2);
        r5 = (m2 * m3 - m0 * m5);

        if (det !== 1.0)
        {
            var detrecp = (1.0 / det);
            r0 *= detrecp;
            r3 *= detrecp;
            r1 *= detrecp;
            r4 *= detrecp;
            r2 *= detrecp;
            r5 *= detrecp;
        }

        return [((x * r0) + (y * r1) + r2),
                ((x * r3) + (y * r4) + r5)];
    },

    calculateUVtransform : function calculateUVtransformFn(gradientMatrix)
    {
        var m = this.matrix;
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];

        var g0 = gradientMatrix[0];
        var g1 = gradientMatrix[1];
        var g2 = gradientMatrix[2];
        var g3 = gradientMatrix[3];
        var g4 = gradientMatrix[4];
        var g5 = gradientMatrix[5];

        // invert matrix
        var r0, r1, r2, r3, r4, r5;

        var det = (m0 * m4 - m1 * m3);
        if (det === 0.0)
        {
            r0 = 1.0;
            r3 = 0.0;
            r1 = 0.0;
            r4 = 1.0;
            r2 = 0.0;
            r5 = 0.0;
        }
        else
        {
            r0 = m4;
            r3 = -m3;
            r1 = -m1;
            r4 = m0;
            r2 = (m1 * m5 - m4 * m2);
            r5 = (m2 * m3 - m0 * m5);

            if (det !== 1.0)
            {
                var detrecp = (1.0 / det);
                r0 *= detrecp;
                r3 *= detrecp;
                r1 *= detrecp;
                r4 *= detrecp;
                r2 *= detrecp;
                r5 *= detrecp;
            }
        }

        return [(g0 * r0 + g1 * r3),
                (g0 * r1 + g1 * r4),
                (g0 * r2 + g1 * r5 + g2),
                (g3 * r0 + g4 * r3),
                (g3 * r1 + g4 * r4),
                (g3 * r2 + g4 * r5 + g5)];
    },


    setShadowStyle : function setShadowStyleFn(style, onlyTexture)
    {
        var shadowOffsetX = this.shadowOffsetX;
        var shadowOffsetY = this.shadowOffsetY;
        if (shadowOffsetX < 1 && shadowOffsetY < 1)
        {
            return false;
        }

        if (this.globalCompositeOperation !== 'source-over')
        {
            return false;
        }

        var color = this.parseColor(this.shadowColor);

        var alpha = (color[3] * this.globalAlpha);

        if (this.shadowBlur > 0)
        {
            alpha *= 0.5;
        }

        if (alpha < 0.004)
        {
            return false;
        }

        if (alpha < 1.0)
        {
            color = this.md.v4Build((color[0] * alpha),
                                    (color[1] * alpha),
                                    (color[2] * alpha),
                                    alpha,
                                    this.tempColor);
        }

        var screen = this.screen;
        var screenScaleX = screen[0];
        var screenScaleY = screen[1];
        screen = this.md.v4Build(screenScaleX, screenScaleY,
                                (screen[2] + (shadowOffsetX * screenScaleX)),
                                (screen[3] + (shadowOffsetY * screenScaleY)),
                                this.tempScreen);

        var gd = this.gd;

        var technique;

        if (typeof style !== 'string' &&
            !style.opaque)
        {
            if (onlyTexture) // drawImage
            {
                technique = this.textureShadowTechnique;

                gd.setTechnique(technique);

                technique.texture = style;
            }
            else if (style.stops) // Gradient
            {
                var texture = style.updateTexture(gd);
                var gradientWidth = texture.width;
                var gradientHeight = texture.height;

                if (!gradientWidth || !gradientHeight)
                {
                    throw 'INVALID_STATE_ERR';
                }

                technique = this.gradientShadowTechnique;

                gd.setTechnique(technique);

                technique.uvtransform = this.calculateUVtransform(style.matrix);
                technique.gradient = texture;
            }
            else // Pattern
            {
                var imageWidth = style.width;
                var imageHeight = style.height;

                if (!imageWidth || !imageHeight)
                {
                    throw 'INVALID_STATE_ERR';
                }

                technique = this.patternShadowTechnique;

                gd.setTechnique(technique);

                technique.uvscale = this.md.v4Build((1.0 / imageWidth), (1.0 / imageHeight), 0, 0, this.uvscale);
                technique.pattern = style;
            }
        }
        else
        {
            if (alpha < 1.0)
            {
                technique = this.flatTechniques['source-over'];
            }
            else
            {
                technique = this.flatTechniques.copy;
            }

            gd.setTechnique(technique);
        }

        technique.screen = screen;

        technique.color = color;

        return true;
    },


    setStyle : function setStyleFn(style)
    {
        if (!style)
        {
            throw 'INVALID_STATE_ERR';
        }

        var globalCompositeOperation = this.globalCompositeOperation;
        var screen = this.screen;
        var gd = this.gd;

        var technique;

        if (typeof style === 'string') // CSS Color
        {
            var color = this.parseColor(style);

            var alpha = (color[3] * this.globalAlpha);
            if (alpha < 1.0)
            {
                color = this.md.v4Build((color[0] * alpha),
                                        (color[1] * alpha),
                                        (color[2] * alpha),
                                        alpha,
                                        this.tempColor);
            }

            if (globalCompositeOperation !== 'source-over' ||
                alpha < 1.0)
            {
                technique = this.flatTechniques[globalCompositeOperation];
                if (!technique)
                {
                    throw "Unknown composite operation: " + globalCompositeOperation;
                }
            }
            else
            {
                technique = this.flatTechniques.copy;
            }

            gd.setTechnique(technique);

            technique.screen = screen;

            technique.color = color;
        }
        else if (style.stops) // Gradient
        {
            var texture = style.updateTexture(gd);
            var gradientWidth = texture.width;
            var gradientHeight = texture.height;

            if (!gradientWidth || !gradientHeight)
            {
                throw 'INVALID_STATE_ERR';
            }

            var globalAlpha = this.globalAlpha;
            if (globalCompositeOperation !== 'source-over' ||
                globalAlpha < 1.0 ||
                !style.opaque)
            {
                technique = this.gradientTechniques[globalCompositeOperation];
                if (!technique)
                {
                    throw "Unknown composite operation: " + globalCompositeOperation;
                }
            }
            else
            {
                technique = this.gradientTechniques.copy;
            }

            gd.setTechnique(technique);

            technique.screen = screen;

            technique.uvtransform = this.calculateUVtransform(style.matrix);

            technique.gradient = texture;
            technique.alpha = globalAlpha;
        }
        else // Pattern
        {
            var imageWidth = style.width;
            var imageHeight = style.height;

            if (!imageWidth || !imageHeight)
            {
                throw 'INVALID_STATE_ERR';
            }

            technique = this.patternTechniques[globalCompositeOperation];
            if (!technique)
            {
                throw "Unknown composite operation: " + globalCompositeOperation;
            }

            gd.setTechnique(technique);

            technique.screen = screen;

            technique.uvscale = this.md.v4Build((1.0 / imageWidth), (1.0 / imageHeight), 0, 0, this.uvscale);

            technique.pattern = style;
            technique.alpha = this.globalAlpha;
        }
    },

    parseColor : function parseColorFn(colorText)
    {
        var color = this.cachedColors[colorText];
        if (color !== undefined)
        {
            return color;
        }

        if (this.numCachedColors > 1024)
        {
            this.cachedColors = {};
            this.numCachedColors = 0;
        }

        color = parseCSSColor(colorText, this.md.v4BuildZero());
        if (color)
        {
            this.cachedColors[colorText] = color;
            this.numCachedColors += 1;
            return color;
        }
        else
        {
            throw "Unknown color: " + colorText;
        }
    },

    interpolateArc : function interpolateArcFn(x, y, radius, startAngle, endAngle, anticlockwise)
    {
        var cos = Math.cos;
        var sin = Math.sin;
        var pi2 = (Math.PI * 2);

        var points = this.currentSubPath;
        var numPoints = points.length;
        var angle, angleDiff, i, j;

        var angleStep = (2.0 / radius);

        var m = this.matrix;
        var m0 = (m[0] * radius);
        var m1 = (m[1] * radius);
        var m3 = (m[3] * radius);
        var m4 = (m[4] * radius);

        if (anticlockwise)
        {
            while (endAngle >= startAngle)
            {
                endAngle -= pi2;
            }

            angleDiff = (startAngle - endAngle);
            if (angleDiff >= angleStep)
            {
                for (angle = startAngle; angle > endAngle; angle -= angleStep)
                {
                    i = cos(angle);
                    j = sin(angle);
                    points[numPoints] = [((i * m0) + (j * m1) + x),
                                         ((i * m3) + (j * m4) + y)];
                    numPoints += 1;
                }
            }
        }
        else
        {
            while (endAngle <= startAngle)
            {
                endAngle += pi2;
            }

            angleDiff = (endAngle - startAngle);
            if (angleDiff >= angleStep)
            {
                for (angle = startAngle; angle < endAngle; angle += angleStep)
                {
                    i = cos(angle);
                    j = sin(angle);
                    points[numPoints] = [((i * m0) + (j * m1) + x),
                                         ((i * m3) + (j * m4) + y)];
                    numPoints += 1;
                }
            }
        }

        i = cos(endAngle);
        j = sin(endAngle);
        points[numPoints] = [((i * m0) + (j * m1) + x),
                             ((i * m3) + (j * m4) + y)];
    },


    mapFlatBuffer : function mapFlatBufferFn(numVertices)
    {
        var flatVertexBuffer = this.flatVertexBuffer;

        if (flatVertexBuffer.numVertices < numVertices)
        {
            this.flatVertexBuffer = flatVertexBuffer = null;
            this.flatVertexBuffer = flatVertexBuffer = this.gd.createVertexBuffer({
                numVertices: numVertices,
                attributes: this.flatVertexFormats,
                dynamic: true,
                'transient': true
            });
        }

        return flatVertexBuffer.map(0, numVertices);
    },

    unmapFlatBuffer : function unmapFlatBufferFn(writer)
    {
        var flatVertexBuffer = this.flatVertexBuffer;

        flatVertexBuffer.unmap(writer);

        this.gd.setStream(flatVertexBuffer, this.flatSemantics);
    },


    mapTextureBuffer : function mapTextureBufferFn(numVertices)
    {
        var textureVertexBuffer = this.textureVertexBuffer;

        if (textureVertexBuffer.numVertices < numVertices)
        {
            this.textureVertexBuffer = textureVertexBuffer = null;
            this.textureVertexBuffer = textureVertexBuffer = this.gd.createVertexBuffer({
                numVertices: numVertices,
                attributes: this.textureVertexFormats,
                dynamic: true,
                'transient': true
            });
        }

        return textureVertexBuffer.map(0, numVertices);
    },

    unmapTextureBuffer : function unmapTextureBufferFn(writer)
    {
        var textureVertexBuffer = this.textureVertexBuffer;

        textureVertexBuffer.unmap(writer);

        this.gd.setStream(textureVertexBuffer, this.textureSemantics);
    },


    triangulateFatLines : function triangulateFatLinesFn(points, numPoints, lineWidth, vertices, numVertices)
    {
        var p, pA, pB, x0, y0, x1, y1, dx, dy, ln, a, b;
        var sqrt = Math.sqrt;

        lineWidth *= 0.5;
        p = 0;
        do
        {
            pA = points[p];
            pB = points[p + 1];
            x0 = pA[0];
            y0 = pA[1];
            x1 = pB[0];
            y1 = pB[1];
            dx = (x1 - x0);
            dy = (y1 - y0);
            ln = ((dx * dx) + (dy * dy));
            if (ln > 0)
            {
                ln = (lineWidth / sqrt(ln));
                dx *= ln;
                dy *= ln;

                // use perpendicular vector to (dx, dy) -> (dy, -dx)
                var a0 = (x0 + dy);
                var a1 = (y0 - dx);
                var b0 = (x1 - dy);
                var b1 = (y1 + dx);

                a = [a0, a1];
                b = [b0, b1];

                vertices[numVertices] = [x0 - dy, y0 + dx];
                vertices[numVertices + 1] = a;
                vertices[numVertices + 2] = b;
                vertices[numVertices + 3] = b;
                vertices[numVertices + 4] = a;
                vertices[numVertices + 5] = [x1 + dy, y1 - dx];
            }
            else
            {
                a = [x0, y0];
                b = [x1, y1];

                vertices[numVertices] = a;
                vertices[numVertices + 1] = a;
                vertices[numVertices + 2] = a;
                vertices[numVertices + 3] = b;
                vertices[numVertices + 4] = b;
                vertices[numVertices + 5] = b;
            }

            numVertices += 6;

            p += 2;
        }
        while (p < numPoints);

        return numVertices;
    },


    triangulateFatStrip : function triangulateFatStripFn(points, numPoints, lineWidth, vertices, numVertices)
    {
        var p, pA, pB, x0, y0, x1, y1, dx, dy, ln;
        var sqrt = Math.sqrt;

        var numSegments = (numPoints - 1);
        var startNumVertices = numVertices;

        lineWidth *= 0.5;
        p = 0;
        pA = points[0];
        x0 = pA[0];
        y0 = pA[1];
        do
        {
            pB = points[p + 1];
            x1 = pB[0];
            y1 = pB[1];
            dx = (x1 - x0);
            dy = (y1 - y0);
            ln = ((dx * dx) + (dy * dy));
            if (ln > 0)
            {
                ln = (lineWidth / sqrt(ln));
                dx *= ln;
                dy *= ln;

                // use perpendicular vector to (dx, dy) -> (dy, -dx)
                vertices[numVertices] = [x0 - dy, y0 + dx];
                vertices[numVertices + 1] = [x0 + dy, y0 - dx];
                vertices[numVertices + 2] = [x1 - dy, y1 + dx];
                vertices[numVertices + 3] = [x1 + dy, y1 - dx];
            }
            else
            {
                vertices[numVertices] = pA;
                vertices[numVertices + 1] = pA;
                vertices[numVertices + 2] = pB;
                vertices[numVertices + 3] = pB;
            }

            numVertices += 4;

            p += 1;
            pA = pB;
            x0 = x1;
            y0 = y1;
        }
        while (p < numSegments);

        // Do we need to close the loop
        if (points[0] === points[numSegments])
        {
            vertices[numVertices] = vertices[startNumVertices];
            vertices[numVertices + 1] = vertices[startNumVertices + 1];
            numVertices += 2;
        }

        return numVertices;
    },

    autoClose : function autoCloseFn(points, numPoints)
    {
        var firstPoint = points[0];
        var lastPoint = points[numPoints - 1];

        if (firstPoint === lastPoint)
        {
            return numPoints;
        }

        var abs = Math.abs;
        if (abs(firstPoint[0] - lastPoint[0]) < 1.0 &&
            abs(firstPoint[1] - lastPoint[1]) < 1.0)
        {
            return numPoints;
        }

        points[numPoints] = firstPoint;

        return (numPoints + 1);
    },

    isClosed : function isClosedFn(firstPoint, lastPoint)
    {
        if (firstPoint === lastPoint)
        {
            return true;
        }

        var abs = Math.abs;
        if (abs(firstPoint[0] - lastPoint[0]) < 1.0 &&
            abs(firstPoint[1] - lastPoint[1]) < 1.0)
        {
            return true;
        }

        return false;
    },

    isConvex : function isConvexFn(points, numSegments)
    {
        if (numSegments < 4)
        {
            return true;
        }

        var flag = 0;

        /*jslint bitwise: false*/
        var p0 = points[numSegments - 2];
        var p1 = points[numSegments - 1];
        var p0x = p0[0];
        var p0y = p0[1];
        var p1x = p1[0];
        var p1y = p1[1];
        var n = 0;
        do
        {
            var p2 = points[n];
            var p2x = p2[0];
            var p2y = p2[1];

            var z = (((p1x - p0x) * (p2y - p1y)) - ((p1y - p0y) * (p2x - p1x)));
            if (z < 0)
            {
                flag |= 1;
            }
            else if (z > 0)
            {
                flag |= 2;
            }

            if (flag === 3)
            {
                return false;
            }

            p0x = p1x;
            p0y = p1y;
            p1x = p2x;
            p1y = p2y;

            n += 1;
        }
        while (n < numSegments);
        /*jslint bitwise: true*/

        if (flag !== 0)
        {
            return true;
        }

        return false;
    },

    calculateArea : function calculateArea(points, numPoints)
    {
        // Dan Sunday, "Fast Polygon Area and Newell Normal Computation"
        var area = 0;
        var p0 = points[numPoints - 2];
        var p1 = points[numPoints - 1];
        var p = 0;
        do
        {
            var p2 = points[p];
            area += p1[0] * (p2[1] - p0[1]);
            p0 = p1;
            p1 = p2;

            p += 1;
        }
        while (p < numPoints);
        return (area * 0.5);
    },

    triangulateConvex : function triangulateConvexFn(points, numSegments, vertices, numVertices)
    {
        var p0 = points[0];
        var p1 = points[1];
        var p = 2;
        do
        {
            var p2 = points[p];
            vertices[numVertices] = p0;
            vertices[numVertices + 1] = p1;
            vertices[numVertices + 2] = p2;
            numVertices += 3;
            p1 = p2;
            p += 1;
        }
        while (p < numSegments);

        return numVertices;
    },

    triangulateConcave : function triangulateConcaveFn(points, numSegments, vertices, numVertices, ownPoints)
    {
        var isConvex = this.isConvex;

        var totalArea = this.calculateArea(points, numSegments);
        if (totalArea === 0)
        {
            return numVertices;
        }

        if (ownPoints)
        {
            points.length = numSegments;
        }
        else
        {
            // Need to get a copy because this is a destructive algorithm
            points = points.slice(0, numSegments); // no need to copy the duplicated last point
        }

        // Ear cutting algorithm
        var i0, i1, i2, p0, p1, p2, j, tarea;
        var ax, ay, bx, by, cx, cy;
        var v0x, v0y, v1x, v1y;
        var minX, maxX, minY, maxY;
        var valid, deletePoint;
        do
        {
            i0 = (numSegments - 2);
            i1 = (numSegments - 1);
            i2 = 0;

            p0 = points[i0];
            ax = p0[0];
            ay = p0[1];

            p1 = points[i1];
            bx = p1[0];
            by = p1[1];
            v1x = (bx - ax);
            v1y = (by - ay);

            valid = false;
            do
            {
                deletePoint = false;

                p2 = points[i2];
                cx = p2[0];
                cy = p2[1];
                v0x = (cx - ax);
                v0y = (cy - ay);

                // Calculate triangle area
                tarea = ((v1x * v0y) - (v0x * v1y)); // * 0.5);

                if ((totalArea * tarea) >= 0) // same winding order
                {
                    // Calculate triangle extents
                    minX = (ax < bx ? ax : bx);
                    minX = (minX < cx ? minX : cx);

                    maxX = (ax > bx ? ax : bx);
                    maxX = (maxX > cx ? maxX : cx);

                    minY = (ay < by ? ay : by);
                    minY = (minY < cy ? minY : cy);

                    maxY = (ay > by ? ay : by);
                    maxY = (maxY > cy ? maxY : cy);

                    // Compute dot products
                    var dot00 = ((v0x * v0x) + (v0y * v0y));
                    var dot01 = ((v0x * v1x) + (v0y * v1y));
                    var dot11 = ((v1x * v1x) + (v1y * v1y));
                    var denom = ((dot00 * dot11) - (dot01 * dot01));
                    if (denom !== 0)
                    {
                        var invDenom = (1.0 / denom);
                        dot00 *= invDenom;
                        dot01 *= invDenom;
                        dot11 *= invDenom;

                        var overlappingPointArea = 0;
                        var overlappingPoint = -1;

                        // Check if triangle overlaps any other point
                        j = 0;
                        do
                        {
                            if (j !== i0 &&
                                j !== i1 &&
                                j !== i2)
                            {
                                var p = points[j];
                                var px = p[0];
                                if (minX <= px && px <= maxX)
                                {
                                    var py = p[1];
                                    if (minY <= py && py <= maxY)
                                    {
                                        var v2x = (px - ax);
                                        var v2y = (py - ay);
                                        var dot02 = ((v0x * v2x) + (v0y * v2y));
                                        var dot12 = ((v1x * v2x) + (v1y * v2y));

                                        // Barycentric coordinates
                                        var u = ((dot11 * dot02) - (dot01 * dot12));
                                        if (u > 0)
                                        {
                                            var v = ((dot00 * dot12) - (dot01 * dot02));
                                            if (v > 0 && (u + v) < 1)
                                            {
                                                // There is at least one vertex inside the triangle, if there are more
                                                // find the one closer to i1 vertically by finding the one that has the
                                                // biggest triangle area with i0 and i2
                                                var parea = ((v0y * v2x) - (v0x * v2y));
                                                parea *= parea; // Make sure is a positive value
                                                if (overlappingPointArea < parea)
                                                {
                                                    overlappingPointArea = parea;
                                                    overlappingPoint = j;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            j += 1;
                        }
                        while (j < numSegments);

                        if (overlappingPoint < 0)
                        {
                            vertices[numVertices] = p0;
                            vertices[numVertices + 1] = p1;
                            vertices[numVertices + 2] = p2;
                            numVertices += 3;

                            deletePoint = true;
                        }
                        else if (overlappingPoint === ((i1 + 2) % numSegments))
                        {
                            // The diagonal is only splitting the next triangle
                            // Remove the point an keep going
                            i0 = i1;
                            i1 = i2;
                            i2 = overlappingPoint;

                            p0 = p1;
                            ax = bx;
                            ay = by;

                            p1 = p2;

                            p2 = points[i2];
                            cx = p2[0];
                            cy = p2[1];
                            v0x = (cx - ax);
                            v0y = (cy - ay);

                            vertices[numVertices] = p0;
                            vertices[numVertices + 1] = p1;
                            vertices[numVertices + 2] = p2;
                            numVertices += 3;

                            deletePoint = true;
                        }
                        else if (i1 === ((overlappingPoint + 2) % numSegments))
                        {
                            // The diagonal is only splitting the previous triangle
                            // Remove the point an keep going
                            i2 = i1;
                            i1 = i0;
                            i0 = overlappingPoint;

                            p2 = p1;
                            cx = bx;
                            cy = by;

                            p1 = p0;

                            p0 = points[i0];
                            ax = p0[0];
                            ay = p0[1];

                            v0x = (cx - ax);
                            v0y = (cy - ay);

                            vertices[numVertices] = p0;
                            vertices[numVertices + 1] = p1;
                            vertices[numVertices + 2] = p2;
                            numVertices += 3;

                            deletePoint = true;
                        }
                        else
                        {
                             // Found a diagonal
                            var d0 = i1;
                            var d1 = overlappingPoint;

                            var pointsA, pointsB;
                            if (d0 < d1)
                            {
                                pointsA = points.splice(d0, (d1 - d0 + 1), points[d0], points[d1]);
                                pointsB = points;
                            }
                            else
                            {
                                pointsB = points.splice(d1, (d0 - d1 + 1), points[d1], points[d0]);
                                pointsA = points;
                            }
                            points = null;

                            var numSegmentsA = pointsA.length;
                            if (numSegmentsA === 3)
                            {
                                vertices[numVertices] = pointsA[0];
                                vertices[numVertices + 1] = pointsA[1];
                                vertices[numVertices + 2] = pointsA[2];
                                numVertices += 3;
                            }
                            else
                            {
                                pointsA[numSegmentsA] = pointsA[0];

                                if (isConvex(pointsA, numSegmentsA))
                                {
                                    numVertices = this.triangulateConvex(pointsA, numSegmentsA, vertices, numVertices);
                                }
                                else
                                {
                                    numVertices = this.triangulateConcave(pointsA, numSegmentsA, vertices, numVertices, true);
                                }
                            }
                            pointsA = null;

                            var numSegmentsB = pointsB.length;
                            if (numSegmentsB === 3)
                            {
                                vertices[numVertices] = pointsB[0];
                                vertices[numVertices + 1] = pointsB[1];
                                vertices[numVertices + 2] = pointsB[2];
                                numVertices += 3;
                                return numVertices;
                            }
                            else
                            {
                                pointsB[numSegmentsB] = pointsB[0];

                                // Avoid recursion by restarting the loop
                                points = pointsB;
                                numSegments = numSegmentsB;
                                pointsB = null;

                                totalArea = this.calculateArea(points, numSegments);
                                if (totalArea === 0)
                                {
                                    return numVertices;
                                }

                                points.length = numSegments;

                                valid = true;
                                break;
                            }
                        }
                    }
                    else // Zero-area triangle
                    {
                        deletePoint = true;
                    }
                }

                if (deletePoint)
                {
                    valid = true;

                    points.splice(i1, 1);

                    numSegments -= 1;
                    if (numSegments < 4)
                    {
                        break;
                    }

                    if (i2 < numSegments)
                    {
                        if (i1 === 0)
                        {
                            i0 = (numSegments - 1);
                        }
                        else
                        {
                            i0 = (i1 - 1);

                            if (i1 === numSegments)
                            {
                                i1 = 0;
                            }
                        }

                        i2 = (i1 + 1);

                        p1 = p2;
                        bx = cx;
                        by = cy;
                        v1x = v0x;
                        v1y = v0y;

                        continue;
                    }
                    else
                    {
                        break;
                    }
                }

                i0 = i1;
                i1 = i2;
                i2 = (i2 + 1);

                p0 = p1;
                ax = bx;
                ay = by;

                p1 = p2;
                bx = cx;
                by = cy;
                v1x = (bx - ax);
                v1y = (by - ay);
            }
            while (i2 < numSegments);
        }
        while (valid && !isConvex(points, numSegments));

        if (!valid)
        {
            return numVertices;
        }

        // convex
        p0 = points[0];
        ax = p0[0];
        ay = p0[1];

        p1 = points[1];
        bx = p1[0];
        by = p1[1];
        v1x = (bx - ax);
        v1y = (by - ay);

        j = 2;
        do
        {
            p2 = points[j];
            cx = p2[0];
            cy = p2[1];
            v0x = (cx - ax);
            v0y = (cy - ay);

            // Calculate triangle area
            tarea = (((v1x * v0y) - (v0x * v1y)) * 0.5);

            if ((totalArea * tarea) > 0) // same winding order
            {
                vertices[numVertices] = p0;
                vertices[numVertices + 1] = p1;
                vertices[numVertices + 2] = p2;
                numVertices += 3;
            }

            p1 = p2;
            bx = cx;
            by = cy;
            v1x = v0x;
            v1y = v0y;

            j += 1;
        }
        while (j < numSegments);

        return numVertices;
    },

    fillFlatVertices : function fillFlatVerticesFn(vertices, numVertices)
    {
        var writer = this.mapFlatBuffer(numVertices);
        if (writer)
        {
            var p = 0;
            do
            {
                var vertex = vertices[p];
                writer(vertex[0], vertex[1]);
                p += 1;
            }
            while (p < numVertices);

            this.unmapFlatBuffer(writer);
        }
    },

    isPointInPolygon : function isPointInPolygonFn(tx, ty, points, numPoints)
    {
        var yflag0, yflag1, inside;
        var vtx0, vtx1, vtxn;

        vtx0 = points[numPoints - 1];
        yflag0 = (vtx0[1] >= ty);

        inside = false;

        for (vtxn = 0; vtxn < numPoints; vtxn += 1)
        {
            vtx1 = points[vtxn];
            yflag1 = (vtx1[1] >= ty);

            if (yflag0 !== yflag1)
            {
                if (((vtx1[1] - ty) * (vtx0[0] - vtx1[0]) >= (vtx1[0] - tx) * (vtx0[1] - vtx1[1])) === yflag1)
                {
                    inside = !inside;
                }
            }

            vtx0 = vtx1;
            yflag0 = yflag1;
        }

        return inside;
    },

    isPointInSubPath : function isPointInSubPathFn(tx, ty, points)
    {
        var numPoints = points.length;
        if (numPoints > 2)
        {
            if (this.isClosed(points[0], points[numPoints - 1]))
            {
                numPoints -= 1; // Skip duplicated last point

                return this.isPointInPolygon(tx, ty, points, numPoints);
            }
        }

        return false;
    },

/*jslint white: false*/
    shaderDefinition : {
 "version": 1,
 "name": "canvas.cgfx",
 "samplers":
 {
  "texture":
  {
   "MinFilter": 9985,
   "MagFilter": 9729,
   "WrapS": 33071,
   "WrapT": 33071
  },
  "pattern":
  {
   "MinFilter": 9728,
   "MagFilter": 9729,
   "WrapS": 10497,
   "WrapT": 10497
  },
  "gradient":
  {
   "MinFilter": 9728,
   "MagFilter": 9729,
   "WrapS": 33071,
   "WrapT": 33071
  },
  "image":
  {
   "MinFilter": 9728,
   "MagFilter": 9729,
   "WrapS": 33071,
   "WrapT": 33071
  }
 },
 "parameters":
 {
  "screen":
  {
   "type": "float",
   "columns": 4
  },
  "uvscale":
  {
   "type": "float",
   "columns": 4
  },
  "uvtransform":
  {
   "type": "float",
   "rows": 2,
   "columns": 3
  },
  "color":
  {
   "type": "float",
   "columns": 4
  },
  "alpha":
  {
   "type": "float"
  },
  "texture":
  {
   "type": "sampler2D"
  },
  "pattern":
  {
   "type": "sampler2D"
  },
  "gradient":
  {
   "type": "sampler2D"
  },
  "image":
  {
   "type": "sampler2D"
  }
 },
 "techniques":
 {
  "flat_source_atop":
  [
   {
    "parameters": ["screen","color"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [772,771]
    },
    "programs": ["vp_flat","fp_flat"]
   }
  ],
  "flat_source_in":
  [
   {
    "parameters": ["screen","color"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [772,0]
    },
    "programs": ["vp_flat","fp_flat"]
   }
  ],
  "flat_source_out":
  [
   {
    "parameters": ["screen","color"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,0]
    },
    "programs": ["vp_flat","fp_flat"]
   }
  ],
  "flat_source_over":
  [
   {
    "parameters": ["screen","color"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [1,771]
    },
    "programs": ["vp_flat","fp_flat"]
   }
  ],
  "flat_destination_atop":
  [
   {
    "parameters": ["screen","color"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,770]
    },
    "programs": ["vp_flat","fp_flat"]
   }
  ],
  "flat_destination_in":
  [
   {
    "parameters": ["screen","color"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [0,770]
    },
    "programs": ["vp_flat","fp_flat"]
   }
  ],
  "flat_destination_out":
  [
   {
    "parameters": ["screen","color"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [0,771]
    },
    "programs": ["vp_flat","fp_flat"]
   }
  ],
  "flat_destination_over":
  [
   {
    "parameters": ["screen","color"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,1]
    },
    "programs": ["vp_flat","fp_flat"]
   }
  ],
  "flat_lighter":
  [
   {
    "parameters": ["screen","color"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [1,1]
    },
    "programs": ["vp_flat","fp_flat"]
   }
  ],
  "flat_copy":
  [
   {
    "parameters": ["screen","color"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": false
    },
    "programs": ["vp_flat","fp_flat"]
   }
  ],
  "flat_xor":
  [
   {
    "parameters": ["screen","color"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,771]
    },
    "programs": ["vp_flat","fp_flat"]
   }
  ],
  "texture_source_atop":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [772,771]
    },
    "programs": ["vp_texture","fp_texture"]
   }
  ],
  "texture_source_in":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [772,0]
    },
    "programs": ["vp_texture","fp_texture"]
   }
  ],
  "texture_source_out":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,0]
    },
    "programs": ["vp_texture","fp_texture"]
   }
  ],
  "texture_source_over":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [1,771]
    },
    "programs": ["vp_texture","fp_texture"]
   }
  ],
  "texture_destination_atop":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,770]
    },
    "programs": ["vp_texture","fp_texture"]
   }
  ],
  "texture_destination_in":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [0,770]
    },
    "programs": ["vp_texture","fp_texture"]
   }
  ],
  "texture_destination_out":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [0,771]
    },
    "programs": ["vp_texture","fp_texture"]
   }
  ],
  "texture_destination_over":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,1]
    },
    "programs": ["vp_texture","fp_texture"]
   }
  ],
  "texture_lighter":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [1,1]
    },
    "programs": ["vp_texture","fp_texture"]
   }
  ],
  "texture_copy":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": false
    },
    "programs": ["vp_texture","fp_texture"]
   }
  ],
  "texture_xor":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,771]
    },
    "programs": ["vp_texture","fp_texture"]
   }
  ],
  "pattern_source_atop":
  [
   {
    "parameters": ["screen","uvscale","alpha","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [772,771]
    },
    "programs": ["vp_pattern","fp_pattern"]
   }
  ],
  "pattern_source_in":
  [
   {
    "parameters": ["screen","uvscale","alpha","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [772,0]
    },
    "programs": ["vp_pattern","fp_pattern"]
   }
  ],
  "pattern_source_out":
  [
   {
    "parameters": ["screen","uvscale","alpha","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,0]
    },
    "programs": ["vp_pattern","fp_pattern"]
   }
  ],
  "pattern_source_over":
  [
   {
    "parameters": ["screen","uvscale","alpha","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [1,771]
    },
    "programs": ["vp_pattern","fp_pattern"]
   }
  ],
  "pattern_destination_atop":
  [
   {
    "parameters": ["screen","uvscale","alpha","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,770]
    },
    "programs": ["vp_pattern","fp_pattern"]
   }
  ],
  "pattern_destination_in":
  [
   {
    "parameters": ["screen","uvscale","alpha","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [0,770]
    },
    "programs": ["vp_pattern","fp_pattern"]
   }
  ],
  "pattern_destination_out":
  [
   {
    "parameters": ["screen","uvscale","alpha","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [0,771]
    },
    "programs": ["vp_pattern","fp_pattern"]
   }
  ],
  "pattern_destination_over":
  [
   {
    "parameters": ["screen","uvscale","alpha","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,1]
    },
    "programs": ["vp_pattern","fp_pattern"]
   }
  ],
  "pattern_lighter":
  [
   {
    "parameters": ["screen","uvscale","alpha","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [1,1]
    },
    "programs": ["vp_pattern","fp_pattern"]
   }
  ],
  "pattern_copy":
  [
   {
    "parameters": ["screen","uvscale","alpha","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": false
    },
    "programs": ["vp_pattern","fp_pattern"]
   }
  ],
  "pattern_xor":
  [
   {
    "parameters": ["screen","uvscale","alpha","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,771]
    },
    "programs": ["vp_pattern","fp_pattern"]
   }
  ],
  "gradient_source_atop":
  [
   {
    "parameters": ["screen","uvtransform","alpha","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [772,771]
    },
    "programs": ["vp_gradient","fp_gradient"]
   }
  ],
  "gradient_source_in":
  [
   {
    "parameters": ["screen","uvtransform","alpha","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [772,0]
    },
    "programs": ["vp_gradient","fp_gradient"]
   }
  ],
  "gradient_source_out":
  [
   {
    "parameters": ["screen","uvtransform","alpha","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,0]
    },
    "programs": ["vp_gradient","fp_gradient"]
   }
  ],
  "gradient_source_over":
  [
   {
    "parameters": ["screen","uvtransform","alpha","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [1,771]
    },
    "programs": ["vp_gradient","fp_gradient"]
   }
  ],
  "gradient_destination_atop":
  [
   {
    "parameters": ["screen","uvtransform","alpha","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,770]
    },
    "programs": ["vp_gradient","fp_gradient"]
   }
  ],
  "gradient_destination_in":
  [
   {
    "parameters": ["screen","uvtransform","alpha","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [0,770]
    },
    "programs": ["vp_gradient","fp_gradient"]
   }
  ],
  "gradient_destination_out":
  [
   {
    "parameters": ["screen","uvtransform","alpha","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [0,771]
    },
    "programs": ["vp_gradient","fp_gradient"]
   }
  ],
  "gradient_destination_over":
  [
   {
    "parameters": ["screen","uvtransform","alpha","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,1]
    },
    "programs": ["vp_gradient","fp_gradient"]
   }
  ],
  "gradient_lighter":
  [
   {
    "parameters": ["screen","uvtransform","alpha","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [1,1]
    },
    "programs": ["vp_gradient","fp_gradient"]
   }
  ],
  "gradient_copy":
  [
   {
    "parameters": ["screen","uvtransform","alpha","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": false
    },
    "programs": ["vp_gradient","fp_gradient"]
   }
  ],
  "gradient_xor":
  [
   {
    "parameters": ["screen","uvtransform","alpha","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,771]
    },
    "programs": ["vp_gradient","fp_gradient"]
   }
  ],
  "texture_shadow":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [1,771]
    },
    "programs": ["vp_texture","fp_texture_shadow"]
   }
  ],
  "pattern_shadow":
  [
   {
    "parameters": ["screen","uvscale","color","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [1,771]
    },
    "programs": ["vp_pattern","fp_pattern_shadow"]
   }
  ],
  "gradient_shadow":
  [
   {
    "parameters": ["screen","uvtransform","color","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [1,771]
    },
    "programs": ["vp_gradient","fp_gradient_shadow"]
   }
  ],
  "image":
  [
   {
    "parameters": ["image"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": false
    },
    "programs": ["vp_image","fp_image"]
   }
  ]
 },
 "programs":
 {
  "fp_image":
  {
   "type": "fragment",
   "code": "#ifdef GL_ES\nprecision mediump float;precision mediump int;\n#endif\nvarying vec4 tz_TexCoord[8];\nvec4 _ret_0;uniform sampler2D image;void main()\n{_ret_0=texture2D(image,tz_TexCoord[0].xy);gl_FragColor=_ret_0;}"
  },
  "vp_image":
  {
   "type": "vertex",
   "code": "#ifdef GL_ES\nprecision mediump float;precision mediump int;\n#endif\nvarying vec4 tz_TexCoord[8];attribute vec4 ATTR8;attribute vec4 ATTR0;\nstruct VS_TEXTURE_OUT{vec4 _Position;vec2 _UV;};void main()\n{VS_TEXTURE_OUT _Out;_Out._Position=vec4(ATTR0.x,ATTR0.y,0.0,1.0);tz_TexCoord[0].xy=ATTR8.xy;gl_Position=_Out._Position;}"
  },
  "fp_gradient_shadow":
  {
   "type": "fragment",
   "code": "#ifdef GL_ES\nprecision mediump float;precision mediump int;\n#endif\nvarying vec4 tz_TexCoord[8];\nvec4 _ret_0;uniform vec4 color;uniform sampler2D gradient;void main()\n{_ret_0=color*texture2D(gradient,tz_TexCoord[0].xy).w;gl_FragColor=_ret_0;}"
  },
  "vp_gradient":
  {
   "type": "vertex",
   "code": "#ifdef GL_ES\nprecision mediump float;precision mediump int;\n#endif\nvarying vec4 tz_TexCoord[8];attribute vec4 ATTR0;\nstruct VS_TEXTURE_OUT{vec4 _Position;vec2 _UV;};uniform vec4 screen;uniform vec3 uvtransform[2];void main()\n{VS_TEXTURE_OUT _Out;vec3 _position;vec2 _TMP10;_TMP10=ATTR0.xy*screen.xy+screen.zw;_Out._Position=vec4(_TMP10.x,_TMP10.y,0.0,1.0);_position=vec3(ATTR0.x,ATTR0.y,1.0);_Out._UV.x=dot(_position,uvtransform[0]);_Out._UV.y=dot(_position,uvtransform[1]);tz_TexCoord[0].xy=_Out._UV;gl_Position=_Out._Position;}"
  },
  "fp_pattern_shadow":
  {
   "type": "fragment",
   "code": "#ifdef GL_ES\nprecision mediump float;precision mediump int;\n#endif\nvarying vec4 tz_TexCoord[8];\nvec4 _ret_0;uniform vec4 color;uniform sampler2D pattern;void main()\n{_ret_0=color*texture2D(pattern,tz_TexCoord[0].xy).w;gl_FragColor=_ret_0;}"
  },
  "vp_pattern":
  {
   "type": "vertex",
   "code": "#ifdef GL_ES\nprecision mediump float;precision mediump int;\n#endif\nvarying vec4 tz_TexCoord[8];attribute vec4 ATTR0;\nstruct VS_TEXTURE_OUT{vec4 _Position;vec2 _UV;};uniform vec4 screen;uniform vec4 uvscale;void main()\n{VS_TEXTURE_OUT _Out;vec2 _TMP9;_TMP9=ATTR0.xy*screen.xy+screen.zw;_Out._Position=vec4(_TMP9.x,_TMP9.y,0.0,1.0);_Out._UV=ATTR0.xy*uvscale.xy+uvscale.zw;tz_TexCoord[0].xy=_Out._UV;gl_Position=_Out._Position;}"
  },
  "fp_texture_shadow":
  {
   "type": "fragment",
   "code": "#ifdef GL_ES\nprecision mediump float;precision mediump int;\n#endif\nvarying vec4 tz_TexCoord[8];\nvec4 _ret_0;uniform vec4 color;uniform sampler2D texture;void main()\n{_ret_0=color*texture2D(texture,tz_TexCoord[0].xy).w;gl_FragColor=_ret_0;}"
  },
  "vp_texture":
  {
   "type": "vertex",
   "code": "#ifdef GL_ES\nprecision mediump float;precision mediump int;\n#endif\nvarying vec4 tz_TexCoord[8];attribute vec4 ATTR8;attribute vec4 ATTR0;\nstruct VS_TEXTURE_OUT{vec4 _Position;vec2 _UV;};uniform vec4 screen;void main()\n{VS_TEXTURE_OUT _Out;vec2 _TMP9;_TMP9=ATTR0.xy*screen.xy+screen.zw;_Out._Position=vec4(_TMP9.x,_TMP9.y,0.0,1.0);tz_TexCoord[0].xy=ATTR8.xy;gl_Position=_Out._Position;}"
  },
  "fp_gradient":
  {
   "type": "fragment",
   "code": "#ifdef GL_ES\nprecision mediump float;precision mediump int;\n#endif\nvarying vec4 tz_TexCoord[8];\nuniform float alpha;uniform sampler2D gradient;void main()\n{vec4 _fg;_fg=texture2D(gradient,tz_TexCoord[0].xy);_fg.w=_fg.w*alpha;_fg.xyz=_fg.xyz*_fg.www;gl_FragColor=_fg;}"
  },
  "fp_pattern":
  {
   "type": "fragment",
   "code": "#ifdef GL_ES\nprecision mediump float;precision mediump int;\n#endif\nvarying vec4 tz_TexCoord[8];\nuniform float alpha;uniform sampler2D pattern;void main()\n{vec4 _fg;_fg=texture2D(pattern,tz_TexCoord[0].xy);_fg.w=_fg.w*alpha;_fg.xyz=_fg.xyz*_fg.www;gl_FragColor=_fg;}"
  },
  "fp_texture":
  {
   "type": "fragment",
   "code": "#ifdef GL_ES\nprecision mediump float;precision mediump int;\n#endif\nvarying vec4 tz_TexCoord[8];\nuniform vec4 color;uniform sampler2D texture;void main()\n{vec4 _fg;_fg=texture2D(texture,tz_TexCoord[0].xy)*color;_fg.xyz=_fg.xyz*_fg.www;gl_FragColor=_fg;}"
  },
  "fp_flat":
  {
   "type": "fragment",
   "code": "#ifdef GL_ES\nprecision mediump float;precision mediump int;\n#endif\nuniform vec4 color;void main()\n{gl_FragColor=color;}"
  },
  "vp_flat":
  {
   "type": "vertex",
   "code": "#ifdef GL_ES\nprecision mediump float;precision mediump int;\n#endif\nattribute vec4 ATTR0;\nvec4 _ret_0;uniform vec4 screen;void main()\n{vec2 _TMP9;_TMP9=ATTR0.xy*screen.xy+screen.zw;_ret_0=vec4(_TMP9.x,_TMP9.y,0.0,1.0);gl_Position=_ret_0;}"
  }
 }
}
/*jslint white: true*/
};

// Constructor function
CanvasContext.create = function canvasCreateFn(canvas, gd, md, width, height)
{
    var c = new CanvasContext();

    // public variables
    c.canvas = canvas;
    c.globalAlpha = 1.0;
    c.globalCompositeOperation = 'source-over';
    c.strokeStyle = '#000000';
    c.fillStyle = '#000000';
    c.lineWidth = 1;
    c.lineCap = 'butt';
    c.lineJoin = 'miter';
    c.miterLimit = 10;
    c.shadowOffsetX = 0;
    c.shadowOffsetY = 0;
    c.shadowBlur = 0;
    c.shadowColor = 'rgba(0,0,0,0)';
    c.font = '10px sans-serif';
    c.textAlign = 'start';
    c.textBaseline = 'alphabetic';

    // private variables
    c.gd = gd;
    c.md = md;

    c.fm = null;

    c.target = null;
    c.viewport = [0, 0, width, height];

    c.forceFatLines = false;

    c.width = width;
    c.height = height;

    c.screen = md.v4Build((2 / width), (-2 / height), -1, 1);

    c.statesStack = [];

    c.subPaths = [];
    c.currentSubPath = [];

    var shader = gd.createShader(c.shaderDefinition);
    c.shader = shader;

    c.triangleStripPrimitive = gd.PRIMITIVE_TRIANGLE_STRIP;
    c.triangleFanPrimitive = gd.PRIMITIVE_TRIANGLE_FAN;
    c.trianglePrimitive = gd.PRIMITIVE_TRIANGLES;
    c.lineStripPrimitive = gd.PRIMITIVE_LINE_STRIP;
    c.linePrimitive = gd.PRIMITIVE_LINES;

    c.textureVertexFormats = [gd.VERTEXFORMAT_FLOAT2, gd.VERTEXFORMAT_FLOAT2];
    c.textureSemantics = gd.createSemantics(['POSITION', 'TEXCOORD0']);

    c.textureVertexBuffer = gd.createVertexBuffer({
        numVertices: 256,
        attributes: c.textureVertexFormats,
        dynamic: true,
        'transient': true
    });

    c.flatVertexFormats = [gd.VERTEXFORMAT_FLOAT2];
    c.flatSemantics = gd.createSemantics(['POSITION']);

    c.flatVertexBuffer = gd.createVertexBuffer({
        numVertices: 256,
        attributes: c.flatVertexFormats,
        dynamic: true,
        'transient': true
    });

    c.tempVertices = [];

    c.v4Zero = md.v4BuildZero();
    c.v4One = md.v4BuildOne();

    c.cachedColors = {};
    c.numCachedColors = 0;

    c.uvscale = md.v4BuildZero();
    c.tempColor = md.v4BuildZero();
    c.tempScreen = md.v4BuildZero();

    c.tempImage = null;
    c.imageTechnique = shader.getTechnique('image');

    var compositeOperations = c.compositeOperations;
    var flatTechniques = {};
    var textureTechniques = {};
    var patternTechniques = {};
    var gradientTechniques = {};
    c.flatTechniques = flatTechniques;
    c.textureTechniques = textureTechniques;
    c.patternTechniques = patternTechniques;
    c.gradientTechniques = gradientTechniques;
    for (var p in compositeOperations)
    {
        if (compositeOperations.hasOwnProperty(p))
        {
            var sp = p.replace('-', '_');
            flatTechniques[p] = shader.getTechnique('flat_' + sp);
            textureTechniques[p] = shader.getTechnique('texture_' + sp);
            patternTechniques[p] = shader.getTechnique('pattern_' + sp);
            gradientTechniques[p] = shader.getTechnique('gradient_' + sp);
        }
    }

    c.textureShadowTechnique = shader.getTechnique('texture_shadow');
    c.patternShadowTechnique = shader.getTechnique('pattern_shadow');
    c.gradientShadowTechnique = shader.getTechnique('gradient_shadow');

/*
    c.renderTexture = gd.createTexture({
        name       : "canvas.backbuffer",
        width      : width,
        height     : height,
        depth      : 1,
        format     : gd.PIXELFORMAT_R8G8B8A8,
        cubemap    : false,
        mipmaps    : false,
        renderable : true
    });

    c.renderTarget = gd.createRenderTarget({
        colorTexture0 : c.renderTexture
    });
*/

    //
    // Transformation matrix and related operations
    //
    c.matrix = [1, 0, 0,
                0, 1, 0];

    var CanvasPrototype = CanvasContext.prototype;
    var scale = CanvasPrototype.scale;
    var translate = CanvasPrototype.translate;
    var transform = CanvasPrototype.transform;
    var setTransform = CanvasPrototype.setTransform;
    var transformPoint = CanvasPrototype.transformPoint;
    var transformRect = CanvasPrototype.transformRect;

    function resetTransformMethods()
    {
        c.scale = scale;
        c.translate = translate;
        c.transform = transform;
        c.setTransform = setTransform;
        c.transformPoint = transformPoint;
        c.transformRect = transformRect;
    }

    function transformTranslate(a, b, c, d, e, f)
    {
        var m = this.matrix;
        m[0] = a;
        m[3] = b;
        m[1] = c;
        m[4] = d;
        m[2] = (e + m[2]);
        m[5] = (f + m[5]);

        resetTransformMethods();
    }

    function translatePoint(x, y)
    {
        var m = this.matrix;
        return [(x + m[2]), (y + m[5])];
    }

    function translateRect(x, y, w, h)
    {
        var m = this.matrix;
        var x0 = (x + m[2]);
        var y0 = (y + m[5]);
        var x1 = (x0 + w);
        var y1 = (y0 + h);
        return [[x0, y1], [x1, y1], [x0, y0], [x1, y0]];
    }

    function scaleIdentity(x, y)
    {
        var m = this.matrix;
        m[0] = x;
        m[4] = y;

        resetTransformMethods();
    }

    function translateIdentity(x, y)
    {
        var m = this.matrix;
        m[2] = x;
        m[5] = y;

        this.translate = translate;
        this.transform = transformTranslate;
        this.transformPoint = translatePoint;
        this.transformRect = translateRect;
    }

    function setTransformIdentity(a, b, c, d, e, f)
    {
        var m = this.matrix;
        m[0] = a;
        m[1] = c;
        m[2] = e;
        m[3] = b;
        m[4] = d;
        m[5] = f;

        resetTransformMethods();
    }

    function transformPointIdentity(x, y)
    {
        return [x, y];
    }

    function transformRectIdentity(x, y, w, h)
    {
        var x1 = (x + w);
        var y1 = (y + h);
        return [[x, y1], [x1, y1], [x, y], [x1, y]];
    }

    c.scale = scaleIdentity;
    c.translate = translateIdentity;
    c.transform = setTransformIdentity;
    c.setTransform = setTransformIdentity;
    c.transformPoint = transformPointIdentity;
    c.transformRect = transformRectIdentity;

    //
    // Clipping
    //
    c.clipExtents = [0, 0, width, height];

    //
    c.defaultStates = c.getStates();

    return c;
};

//
// Canvas
//
function Canvas() {}
Canvas.prototype =
{
    version : 1,

    // Standard API
    getContext : function getContextFn(contextId)
    {
        if (contextId.toLowerCase() === '2d')
        {
            return this.context;
        }
        else
        {
            return null;
        }
    },

    toDataURL : function toDataURLFn(type)
    {
        if (this.width === 0 ||
            this.height === 0)
        {
            return "data:,";
        }

        //if (type.toLowerCase() === 'image/jpeg')
        var pixelData = this.gd.getScreenshot(true, 0, 0, this.width, this.height);
        if (pixelData)
        {
            return "data:image/jpeg;base64," + pixelData.toBase64();
        }

        return null;
    },

    toBlob : function toBlobFn(fileCallback, type)
    {
        if (fileCallback)
        {
            //if (type.toLowerCase() === 'image/jpeg')
            var pixelData = this.gd.getScreenshot(true, 0, 0, this.width, this.height);
            fileCallback(pixelData);
        }
    },

    setAttribute : function setAttributeFn(attr, value)
    {
        if (value.substr(-2, 2) === "px")
        {
            value = value.substr(0, value.lengh - 2);
        }
        value = parseInt(value, 10);

        if (attr === "width")
        {
            this.width = value;
        }
        else if (attr === "height")
        {
            this.height = value;
        }
        else
        {
            throw 'UNSUPPORTED ATTRIBUTE!';
        }
    },

    // Turbulenz API
    setFontManager : function setFontManagerFn(fm)
    {
        this.context.setFontManager(fm);
    }
};

// Constructor function
Canvas.create = function canvasCreateFn(gd, md)
{
    var width = 320;
    var height = 480;

    var c = new Canvas();

    c.context = CanvasContext.create(c, gd, md, width, height);

    if (Object.defineProperty)
    {
        Object.defineProperty(c, "width", {
                get : function getWidth() {
                    return width;
                },
                set : function setWidth(newValue) {
                    width = newValue;

                    this.context.setWidth(newValue);
                },
                enumerable : true,
                configurable : false
            });

        Object.defineProperty(c, "height", {
                get : function getHeight() {
                    return height;
                },
                set : function setHeight(newValue) {
                    height = newValue;

                    this.context.setHeight(newValue);
                },
                enumerable : true,
                configurable : false
            });
    }
    else
    {
        c.width = width;
        c.height = height;
    }

    return c;
};



// Copyright (c) 2010-2011 Turbulenz Limited

//
//  SceneLoader
//  ===========
//
//  Helper class to load() a scene and wait for its dependencies before complete() is true
//

/*global TurbulenzEngine: false*/
/*global ResourceLoader: false*/

function SceneLoader() {}

SceneLoader.prototype =
{
    complete : function sceneLoaderCompleteFn()
    {
        if (!this.dependenciesLoaded)
        {
            if (this.sceneAssetsRequested &&
                0 === this.textureManager.getNumPendingTextures() &&
                (!this.shaderManager || 0 === this.shaderManager.getNumPendingShaders()))
            {
                this.dependenciesLoaded = true;
            }
        }
        return this.dependenciesLoaded;
    },
    load : function sceneLoaderLoadFn(parameters)
    {
        var sceneLoader = this; // required for context in nested functions

        this.sceneAssetsRequested = false;

        this.scene = parameters.scene;
        this.assetPath = parameters.assetPath;
        this.textureManager = parameters.textureManager;
        this.shaderManager = parameters.shaderManager;
        this.effectManager = parameters.effectManager;
        this.animationManager = parameters.animationManager;
        this.requestHandler = parameters.requestHandler;

        if (parameters.keepLights !== undefined)
        {
            this.keepLights = parameters.keepLights;
        }
        if (parameters.keepCameras !== undefined)
        {
            this.keepCameras = parameters.keepCameras;
        }
        this.preSceneLoadFn = parameters.preSceneLoadFn;
        this.postSceneLoadFn = parameters.postSceneLoadFn;
        this.dependenciesLoaded = false;
        this.sceneLoaded = false;

        if (!parameters.append)
        {
            this.scene.clear();
        }

        var pathRemapping = this.pathRemapping;
        var requestHandler = this.requestHandler;
        function requestFn(url, onload)
        {
            requestHandler.request({
                    src: (pathRemapping && pathRemapping[url]) || (this.pathPrefix + url),
                    onload: onload
                });
        }

        if (parameters.request)
        {
            this.request = parameters.request;
        }
        else
        {
            this.request = requestFn;
        }

        // Create a callback for post scene load
        function loadSceneFinishedFn()
        {
            if (sceneLoader.postSceneLoadFn)
            {
                //Add custom logic
                sceneLoader.postSceneLoadFn(sceneLoader.scene);
            }
            sceneLoader.sceneAssetsRequested = true;
        }

        // Callback function to pass to the below request()
        function sceneReceivedFn(text, status)
        {
            var sceneData = JSON.parse(text);

            if (!sceneData)
            {
                // Doesn't exist, create an empty data object to preload into the scene
                sceneData = {};
            }

            if (parameters.preSceneLoadFn)
            {
                //Add custom nodes
                parameters.preSceneLoadFn(sceneData);
            }

            // Set a yield callback for loading, for the sample don't do anything special
            function sceneLoadYieldFn(callback)
            {
                TurbulenzEngine.setTimeout(callback, 0);
            }

            function begetFn(o)
            {
                var F = function () { };
                F.prototype = o;
                return new F();
            }

            var loadParameters = begetFn(parameters);

            // Set a sceneLoad callback to load the resource into the scene
            function sceneLoadFn(resolvedData)
            {
                // If we were supplied an animation manager, let that load any animations from the resolved data
                if (sceneLoader.animationManager)
                {
                    sceneLoader.animationManager.loadData(resolvedData);
                }

                loadParameters.data = resolvedData;
                loadParameters.yieldFn = sceneLoadYieldFn;
                loadParameters.onload = loadSceneFinishedFn;

                sceneLoader.scene.load(loadParameters);
            }

            // Create a resource loader to resolve any references in the scene data
            var resourceLoader = ResourceLoader.create();
            resourceLoader.resolve({
                data : sceneData,
                request : this.request,
                onload : sceneLoadFn,
                requestHandler : requestHandler
            });
        }

        this.request(parameters.assetPath, sceneReceivedFn);
    },

    setPathRemapping : function setPathRemappingFn(prm, assetUrl)
    {
        this.pathRemapping = prm;
        this.pathPrefix = assetUrl;
    }
};

SceneLoader.create = function sceneLoaderCreateFn()
{
    var sceneLoader = new SceneLoader();

    sceneLoader.scene = null;
    sceneLoader.assetPath = null;
    sceneLoader.textureManager = null;
    sceneLoader.shaderManager = null;
    sceneLoader.effectManager = null;
    sceneLoader.animationManager = null;
    sceneLoader.preSceneLoadFn = null;
    sceneLoader.postSceneLoadFn = null;
    sceneLoader.dependenciesLoaded = false;
    sceneLoader.sceneAssetsRequested = false;

    sceneLoader.pathPrefix = "";

    return sceneLoader;
};




var CLASS_NO_COLLISION = 0;
var CLASS_PLAYER = 1;
var CLASS_BUBBLE = 2;

var CREATURE_UNKNOWN = 0;
var CREATURE_FISH = 1;
var CREATURE_BEE = 2;

function Sprite() {}
Sprite.prototype =
{
	/**
	 * Type of this Sprite (like class).
	 */
	type : CLASS_NO_COLLISION,

	/**
	 * Sprite animation frames.  null indicates this is not an animated sprite.
	 */
	animFrames:null,
  directionChanged : false,
  facing : 'right',
  setDirection : function(direction) {
    if (direction != this.facing) {
      this.facing = direction;
      this.directionChanged = true;
    }
  },

	creature : CREATURE_BEE,

	/**
	 * Which frame currently showing.
	 */
	frameNum:0,

    update: function(){},

    setImage: function(img)
    {
        this.img = img;
    },

	debugDraw: function debugDraw(ctx)
	{
        // Debug rendering by drawing boxes
        ctx.beginPath();
        ctx.rect(this.x - 2, this.y - 2, 36, 36);
        // ctx.fillStyle = "#8ED6FF";
	    // ctx.fill();
	    ctx.lineWidth = 4;
	    ctx.strokeStyle = "black";
	    ctx.stroke();
	},

    setAnimFrames: function(frames)
    {
    	this.animFrames = frames;
    	this.numFrames = frames.length;
    	this.draw = function animate(ctx)
    	{
    		// this.debugDraw(ctx);
    		var frameNum = this.frameNum;
    		if (++frameNum >= this.numFrames) {
    			frameNum = 0;
    		}
    		var img = this.animFrames[frameNum];
    		ctx.drawImage(img, this.x, this.y);
    		this.frameNum = frameNum;
    	};
    },

    draw : function(ctx)
    {
    	// this.debugDraw(ctx);
      ctx.drawImage(this.img, this.x, this.y);

    }

};

/**
 * @param imageName The image filename.  If contains a number, this is an animated sprite and the number represents the last frame number.
 */
Sprite.create = function spriteCreateFn(type, x, y, imageName, app, updateFunction)
{
    var c = new Sprite();
    c.type = type;
    c.x = x;
    c.y = y;

    c.app = app;
    c.img = new Image();
    c.imageName = imageName ? imageName: 'textures/cratebubble_up_1.png';

    // c.console = app.console;

    c.update = updateFunction;

    return c;
};

var FISH_FILENAME = "textures/fish anim/fish anim00012.png";
var BEE_FILENAME = "textures/bee anim/bee anim00012.png";

//
// Watair:
//
function Watair() {}
Watair.prototype =
{
	mvX: true,
	mvY: true,
  bubbleUpFn : function(){},
  bubbleDownFn : function(){},
  waterLevelChanged : function(){},

	/**
	 * All of the player sprites.
	 */
	playerSprites : [],

	/**
	 * The sprite that the player controls.
	 */
	playerSprite: null,

	/**
	 * The water.
	 */
	waterSprite: null,

	createBubble : function createBubble()
	{
		var randomX = Math.floor((Math.random()*240)+1);
        var randomY = Math.floor((Math.random()*320)+1);
        var newBubble = Sprite.create(CLASS_BUBBLE, randomX, randomY, 'textures/down bubble float/down bubble float.png', this.app, function(){});
        newBubble.bubbleValue = (Math.random() >= 0.5) ? -20 : 20;
        if (newBubble.bubbleValue > 0) {
        	newBubble.imageName = 'textures/up bubble float/up bubble float0001.png';
        }
        this.sprites.push(newBubble);

	},

    init: function initFn()
    {
        var that = this;

		// Water must be sprite 0
        var waterSprite = Sprite.create(CLASS_NO_COLLISION, 0, 150, 'textures/water.jpg', this.app, function()
	    {
	    	var pixelHeight = this.app.pixelHeight;
	    	if (0 === this.change) {
	    		// stationary
	    		return;
	    	} else if (this.change > 0) {
	    		this.y++;
	    		this.change--;
	    	} else {
	    		this.y--;
	    		this.change++;
	    	}

	        if (this.y > pixelHeight)
	        {
	        	this.y = 100;
	        }
	    });
	    waterSprite.change = 0;
	    waterSprite.addChange = function addChange(change) {
	    	this.change -= change;
	    };
	    this.sprites.push(this.waterSprite = waterSprite);


		function buildPlayer(x, y, filename, allSprites) {
			var sprite = Sprite.create(CLASS_PLAYER, x, y, filename, this.app, function()
				{
					if (this.mvX && Math.abs(this.x - this.destX) > 9)
					{
						this.x += this.dx;
					} else {
						this.mvX = false;
					}
					if (this.mvY && Math.abs(this.y - this.destY) > 9)
					{
						this.y += this.dy;
					} else {
						this.mvY = false;
					}

				});

			sprite.speed = 5;
			sprite.destX = 150;
			sprite.destY = 150;
			sprite.dx = 0;
			sprite.dy = 0;

		    sprite.setDestination = function(x, y)
		    {
		    	this.destX = x;
		    	this.destY = y;
		    	var w = x - this.x;
		    	var h = y - this.y;
		    	var theta = Math.atan2(h, w);
		    	this.dx = this.speed * Math.cos(theta);
		    	this.dy = this.speed * Math.sin(theta);
          if (h < 0) {
            sprite.setDirection('left');
          } else {
            sprite.setDirection('right');
          }
		    	this.mvX = this.mvY = true;
		    };

			allSprites.push(sprite);
			return sprite;
		}

		this.playerSprites.push(buildPlayer(100, 100, BEE_FILENAME, this.sprites));
		this.playerSprites.push(buildPlayer(120, 200, FISH_FILENAME, this.sprites));
		this.playerSprite = this.playerSprites[0];
		this.opponentSprite = this.playerSprites[1];

        // bubble placement
        for (var j = 0; j < 10; j++)
        {
        	this.createBubble();
        }

    },

    movePlayerTo : function moveTo(x, y) {
      this.playerSprite.setDestination(x, y);
    },
    moveOpponentTo : function moveTo(x, y) {
      this.opponentSprite.setDestination(x, y);
    },
    setPlayer : function setPlayer(num) {
      if (num == 1) {
        this.playerSprite = this.playerSprites[0];
        this.playerSprite.creature = CREATURE_BEE;
        this.opponentSprite = this.playerSprites[1];
      } else {
        this.playerSprite = this.playerSprites[1];
        this.playerSprite.creature = CREATURE_FISH;
        this.opponentSprite = this.playerSprites[0];
      }
    },

    update: function updateFn()
    {
/*
        var console = window.console;
        if (console)
        {
            console.log('Updating '); // + this.sprites.length);
        }
*/
		var sprites = this.sprites;
        for (var i = sprites.length - 1; i >= 0; i--)
        {
            sprites[i].update();
        }

        this.collisionDetect();
    },

    draw: function drawFn(ctx)
    {
    	var sprites = this.sprites;

    	var water = sprites[0];
		water.draw(ctx);

        for (var i = sprites.length - 1; i >= 1; i--)
        {
            sprites[i].draw(ctx);
        }
    },

    collisionDetect: function detectCollision()
    {
    	// collision detection
		for (var i = this.sprites.length - 1; i >= 0; i--)
        {
			var objRadius = 17; //image size is 35px at the moment of writing this code
			var charRadius = 16; //image size is 32px at the moment of writing this code
			var collisionDistance = 30 * 30; //(adding up radii, approximately)

			var theSprite = this.sprites[i];
			// Using distance calculation equation
			var actualDistance =
					(theSprite.x - this.playerSprite.x)*(theSprite.x - this.playerSprite.x)
					 + (theSprite.y - this.playerSprite.y)*(theSprite.y - this.playerSprite.y);

			if (theSprite.type == CLASS_BUBBLE)
			{

				if (actualDistance <= collisionDistance)
				{
					// Collision
					// console.log("pop");

					// bubble disappear
					this.sprites.splice(i--, 1); // i-- sets position to redo this bubble

					// TODO: Animate bubble disappearance

					// bubble reappear
					this.createBubble(); // TODO: Bubble appear on correct side

					// water moves up/down
					this.waterSprite.addChange(theSprite.bubbleValue, true);
          
          if (theSprite.bubbleValue > 0) {
            this.bubbleDownFn();
          } else {
            this.bubbleUpFn();
          }
				}

			}


			// FIXME: Switch to using background height check for water level.
			var waterSprite = this.waterSprite;
			if (this.playerSprite.creature == CREATURE_FISH && waterSprite.y >= this.playerSprite.y) {
				// TODO: FISH DIED
				window.console.log("fish died");
			} else if (this.playerSprite.creature == CREATURE_BEE && waterSprite.y <= this.playerSprite.y) {
				// TODO: BEE DIED = FISH WIN
				window.console.log("bee died");
				// sprites
			}

        }

    }
};

Watair.create = function watairCreateFn(gameSettings, app)
{
    var watair = new Watair();

    watair.app = app;
    watair.sprites = [];

    watair.console = app.console;

    return watair;
};




// Copyright (c) 2011-2012 Turbulenz Limited

/*global TurbulenzEngine: false*/
/*global SimpleRendering: false*/
/*global Camera: false*/
/*global Scene: false*/
/*global SceneNode: false*/
/*global SceneLoader: false*/
/*global window: false*/

//
// AppScene - creates and stores the application scene
//
function AppScene() {}
AppScene.prototype =
{
    // Error callback - uses window alert
    errorCallback : function errorCallbackFunctionFn(msg)
    {
        window.alert(msg);
    },

    // Tests whether there are things being loaded
    hasLoaded : function hasLoadedFn()
    {
        return true;
    
        var sceneLoader = this.sceneLoader;
        if (sceneLoader)
        {
            /*if (sceneLoader.complete())
            {
                this.sceneLoader = null;

                //this.renderer.updateShader(this.managers.shaderManager);

                //this.createMaterials();

                return true;
            }
            else
            {
                return false;
            }*/
        }
        else
        {
            //return true;
        }
    },

    // Loads the cube asset
    loadCube : function loadCubeFunction()
    {
        var devices = this.devices;
        var managers = this.managers;
        var mappingTable = this.mappingTable;

        var request = function requestFn(assetName, onload)
        {
            return TurbulenzEngine.request(mappingTable.getURL(assetName), onload);
        };

        var cubeLoadingParameters =
        {
            scene : this.scene,
            append : true,
            assetPath : "models/cube.dae",
            keepLights : false,
            keepCameras : false,
            graphicsDevice : devices.graphicsDevice,
            mathDevice : devices.mathDevice,
            textureManager : managers.textureManager,
            shaderManager : managers.shaderManager,
            effectManager : managers.effectManager,
            requestHandler : this.requestHandler,
            request : request
        };

        this.sceneLoader.load(cubeLoadingParameters);
    },

    createMaterials : function createMaterialsFn()
    {
        var scene = this.scene;
        var devices = this.devices;
        var graphicsDevice = devices.graphicsDevice;
        var mathDevice = devices.mathDevice;
        var v4Build = mathDevice.v4Build;
        var managers = this.managers;
        var materials;
        var materialName;
        var material;

        // The materials we will use
        this.materials =
        {
            blueMaterial :
            {
                effect : "constant",
                meta :
                {
                    materialcolor : true
                },
                parameters :
                {
                    materialColor : v4Build.call(mathDevice, 0.0, 0.0, 1.0, 1.0)
                }
            },
            greenMaterial :
            {
                effect : "constant",
                meta :
                {
                    materialcolor : true
                },
                parameters :
                {
                    materialColor : v4Build.call(mathDevice, 0.0, 1.0, 0.0, 1.0)
                }
            },
            redMaterial :
            {
                effect : "constant",
                meta :
                {
                    materialcolor : true
                },
                parameters :
                {
                    materialColor : v4Build.call(mathDevice, 1.0, 0.0, 0.0, 1.0)
                }
            },
            grayMaterial :
            {
                effect : "constant",
                meta :
                {
                    materialcolor : true
                },
                parameters :
                {
                    materialColor : v4Build.call(mathDevice, 0.5, 0.5, 0.5, 1.0)
                }
            }
        };

        materials = this.materials;

        // Load the materials
        for (materialName in materials)
        {
            if (materials.hasOwnProperty(materialName))
            {
                material = materials[materialName];

                if (scene.loadMaterial(graphicsDevice,
                                       managers.textureManager,
                                       managers.effectManager,
                                       materialName,
                                       material))
                {
                    material.loaded = true;
                    scene.getMaterial(materialName).reference.add();
                }
                else
                {
                    this.errorCallback("Failed to load material: " + materialName);
                }
            }
        }
    },

    // Populates the scene with board and worm
    setupScene : function setupSceneFn()
    {
        // Cached vars
        var scene = this.scene;
        var gameSettings = this.game.gameSettings;
        var mathDevice = this.devices.mathDevice;
        var v3Build = mathDevice.v3Build;

        // Board dimensions
        var boardCenter = v3Build.call(mathDevice, 0, 0, 0);
        var boardSpacing = gameSettings.boardSpacing;
        var horizontalCubes = gameSettings.width;
        var verticalCubes = gameSettings.height;
        var maxPlayers = gameSettings.maxPlayers;

        this.setupCamera();

        // Create our reference cubeNode for board, worm and food
        //this.createCubeNodes(maxPlayers);

        // Setup root node and children for use in game
        //this.createNodeStructure(maxPlayers);

        //this.createBoard(boardCenter, boardSpacing, horizontalCubes, verticalCubes);

        //scene.update();
    },

    // Setup the camera
    setupCamera : function setupCamera()
    {
        var mathDevice = this.devices.mathDevice;
        var v3Build = mathDevice.v3Build;

        // Camera looks along -ive z direction towards origin - has 60 degree FOV
        var cameraPosition = v3Build.call(mathDevice, -0.5, -25.0, 25.0);
        var cameraTarget = v3Build.call(mathDevice, -0.5, 0.0, 0.0);
        var worldUp = v3Build.call(mathDevice, 0.0, 1.0, 0.0);
        var halfFov = Math.tan(30 * (Math.PI / 180));
        var camera = Camera.create(mathDevice);

        camera.recipViewWindowX = (1.0 / halfFov);
        camera.recipViewWindowY = (1.0 / halfFov);
        camera.updateProjectionMatrix();
        camera.lookAt(cameraTarget, worldUp, cameraPosition);
        camera.updateViewMatrix();

        this.camera = camera;
    },

    // Resets the worm to starting state
    resetWorm : function resetWormFn(wormIndex)
    {
        return;
        var wormNode = this.wormNodes[wormIndex];
        var wormPartsNodes = this.wormPartsNodes[wormIndex];

        var n = wormPartsNodes.length;
        while (n)
        {
            n -= 1;
            var wormPartsNode = wormPartsNodes[n];
            wormNode.removeChild(wormPartsNode);
            wormPartsNode.destroy();
        }

        wormPartsNodes.length = 0;
    },

    // Creates our reference cube node to be duplicated
    createCubeNodes : function createCubeNodeFn(maxPlayers)
    {
        // Find and get renderable out of loaded node
        var loadedCubeNode = this.scene.findNode("cube");
        var boardCubeRenderable = loadedCubeNode.renderables[0].clone();
        var wormCubeRenderable = boardCubeRenderable.clone();
        var otherWormCubeRenderable = boardCubeRenderable.clone();
        var foodCubeRenderable = boardCubeRenderable.clone();

        // Set the materials
        this.setMaterial(boardCubeRenderable, "blueMaterial");
        this.setMaterial(wormCubeRenderable, "greenMaterial");
        this.setMaterial(otherWormCubeRenderable, "grayMaterial");
        this.setMaterial(foodCubeRenderable, "redMaterial");

        var boardCubeNodeParameters =
        {
            name: "boardCube",
            dynamic: false,
            disabled: false
        };
        var wormCubeNodeParameters =
        {
            name: "wormCube",
            dynamic: true,
            disabled: false
        };
        var foodCubeNodeParameters =
        {
            name: "foodCube",
            dynamic: true,
            disabled: false
        };

        // Nodes to be used as template for board, worm, and food cubes
        var boardCubeNode = SceneNode.create(boardCubeNodeParameters);
        boardCubeNode.addRenderable(boardCubeRenderable);
        this.boardCubeNode = boardCubeNode;

        this.wormCubeRenderable = wormCubeRenderable;
        this.otherWormCubeRenderable = otherWormCubeRenderable;

        var wormCubeNode = SceneNode.create(wormCubeNodeParameters);
        this.wormCubeNode = wormCubeNode;

        var foodCubeNodes = this.foodCubeNodes;
        for (var n = 0; n < maxPlayers; n += 1)
        {
            var foodCubeNode = SceneNode.create(foodCubeNodeParameters);
            foodCubeNode.addRenderable(n === 0 ? foodCubeRenderable : foodCubeRenderable.clone());
            foodCubeNodes[n] = foodCubeNode;
        }
    },

    // Sets up the root node and children for the game
    createNodeStructure : function createNodeStructureFn(maxPlayers)
    {
        // Structure is game as root node, with board and worm as children

        var scene = this.scene;
        var gameNode;
        var boardNode;
        var wormNode;
        var loadedCubeNode;
        var gameNodeParameters =
        {
            name: "game",
            dynamic: false,
            disabled: false
        };
        var boardNodeParameters =
        {
            name: "board",
            dynamic: false,
            disabled: false
        };
        var wormNodeParameters =
        {
            name: "worm",
            dynamic: false,
            disabled: false
        };

        // Create the game, board and worm nodes
        gameNode = SceneNode.create(gameNodeParameters);
        this.gameNode = gameNode;

        boardNode = SceneNode.create(boardNodeParameters);
        this.boardNode = boardNode;
        gameNode.addChild(boardNode);

        var n;
        for (n = 0; n < maxPlayers; n += 1)
        {
            wormNode = SceneNode.create(wormNodeParameters);
            this.wormNodes[n] = wormNode;
            this.wormPartsNodes[n] = [];
            gameNode.addChild(wormNode);
        }

        var foodCubeNodes = this.foodCubeNodes;
        for (n = 0; n < maxPlayers; n += 1)
        {
            gameNode.addChild(foodCubeNodes[n]);
        }

        // Remove loaded node
        loadedCubeNode = this.scene.findNode("cube");
        scene.removeRootNode(loadedCubeNode);

        // Add game as root node
        scene.addRootNode(gameNode);
    },

    // Create the back grid to play on
    createBoard : function createBoardFn(boardCenter, boardSpacing, horizontalCubes, verticalCubes)
    {
        // Cached vars
        var mathDevice = this.devices.mathDevice;
        var m43BuildTranslation = mathDevice.m43BuildTranslation;

        var boardNode = this.boardNode;
        var boardCubeNode = this.boardCubeNode;
        var boardWidth = (horizontalCubes * boardSpacing);
        var boardHeight = (verticalCubes * boardSpacing);
        var minX = (boardCenter[0] - (boardWidth / 2));
        var minY = (boardCenter[1] - (boardHeight / 2));
        var z = boardCenter[2];

        var i, j;
        var x, y;
        var newCubeNode, local;

        x = minX;
        for (i = 0; i < horizontalCubes; i += 1)
        {
            y = minY;
            for (j = 0; j < verticalCubes; j += 1)
            {
                // Create new node, position it, and add to scene
                newCubeNode = boardCubeNode.clone();
                boardNode.addChild(newCubeNode);

                // Reset node transform
                local = newCubeNode.getLocalTransform();

                m43BuildTranslation.call(mathDevice, x, y, z, local);

                newCubeNode.setLocalTransform(local);

                y += boardSpacing;
            }

            x += boardSpacing;
        }
    },

    // Update function - called every frame
    update : function updateFn()
    {
        //this.updateGameScene();
        //this.updateCamera();
    },

    // Updates the camera
    updateCamera : function updateCameraFn()
    {
        var camera = this.camera;
        var graphicsDevice = this.devices.graphicsDevice;
        var deviceWidth = graphicsDevice.width;
        var deviceHeight = graphicsDevice.height;
        var aspectRatio = (deviceWidth / deviceHeight);

        // Adjust camera if aspect ratio has changed
        if (aspectRatio !== camera.aspectRatio)
        {
            camera.aspectRatio = aspectRatio;
            camera.updateProjectionMatrix();
        }
        camera.updateViewProjectionMatrix();
    },

    // Updates the worm node
    updateGameScene : function updateGameSceneFn()
    {
        var game = this.game;
        var state = game.state;
        var currentState = game.currentState;

        if (currentState === state.DEAD)
        {
            if (this.previousGameState !== currentState)
            {
                this.clearColor = this.devices.mathDevice.v4Build(1, 0, 0, 1, this.clearColor);
            }
            else
            {
                return;
            }
        }
        else if (currentState === state.PLAY)
        {
            if (this.previousGameState !== currentState)
            {
                this.resetWorm(game.myWormIndex);

                this.scene.update();

                this.clearColor = this.devices.mathDevice.v4Build(0, 0, 0, 1, this.clearColor);
            }
        }

        this.previousGameState = currentState;

        this.updateTransforms();
    },

    // Updates the local transforms of the worm part nodes
    moveWormNodes : function moveWormNodesFn(wormIndex)
    {
        var mathDevice = this.devices.mathDevice;
        var m43BuildTranslation = mathDevice.m43BuildTranslation;
        var game = this.game;
        var gameSettings = game.gameSettings;
        var boardSpacing = gameSettings.boardSpacing;
        var offsetX = (gameSettings.width  / 2);
        var offsetY = (gameSettings.height / 2);

        var worm = game.getWorm(wormIndex);
        var partsPositionX = worm.partsPositionX;
        var partsPositionY = worm.partsPositionY;
        var numParts = partsPositionX.length;

        var wormPartNodes = this.wormPartsNodes[wormIndex];
        var numWormPartNodes = wormPartNodes.length;
        var i;

        if (numParts < numWormPartNodes)
        {
            this.resetWorm(wormIndex);
            numWormPartNodes = 0;
        }

        if (numWormPartNodes < numParts)
        {
            var isOther = (wormIndex !== game.myWormIndex);
            var wormNode = this.wormNodes[wormIndex];
            var wormCubeNode = this.wormCubeNode;
            for (i = numWormPartNodes; i < numParts; i += 1)
            {
                var newWormCubeNode = wormCubeNode.clone();
                if (isOther)
                {
                    newWormCubeNode.addRenderable(this.otherWormCubeRenderable.clone());
                }
                else
                {
                    newWormCubeNode.addRenderable(this.wormCubeRenderable.clone());
                }
                wormNode.addChild(newWormCubeNode);
                wormPartNodes.push(newWormCubeNode);
            }
        }

        for (i = 0; i < numParts; i += 1)
        {
            var wormPartNode = wormPartNodes[i];

            var local = wormPartNode.getLocalTransform();

            m43BuildTranslation.call(mathDevice, (partsPositionX[i] - offsetX) * boardSpacing,
                                                 (partsPositionY[i] - offsetY) * boardSpacing,
                                                 1,
                                                 local);

            wormPartNode.setLocalTransform(local);
        }
    },

    // Update scene from game
    updateTransforms : function updateTransformsFn()
    {
        var mathDevice = this.devices.mathDevice;
        var game = this.game;
        var gameSettings = game.gameSettings;
        var boardSpacing = gameSettings.boardSpacing;
        var offsetX = (gameSettings.width  / 2);
        var offsetY = (gameSettings.height / 2);
        var maxPlayers = gameSettings.maxPlayers;
        var foodCubeNodes = this.foodCubeNodes;
        var local;

        for (var n = 0; n < maxPlayers; n += 1)
        {
            // Food
            var food = game.getFood(n);

            var foodCubeNode = foodCubeNodes[n];

            local = foodCubeNode.getLocalTransform();

            mathDevice.m43BuildTranslation((food.x - offsetX) * boardSpacing,
                                           (food.y - offsetY) * boardSpacing,
                                           1,
                                           local);

            foodCubeNode.setLocalTransform(local);

            // Worm
            this.moveWormNodes(n);
        }

        this.scene.update();
    },

    // Sets node renderable with material specified
    setMaterial : function setMaterial(renderable, materialName)
    {
        var material;

        if (renderable)
        {
            material = this.materials[materialName];
            if (material && material.loaded)
            {
                renderable.setMaterial(this.scene.getMaterial(materialName));
            }
        }
    }
};

// AppScene constructor function
AppScene.create = function appSceneCreateFn(devices, managers, requestHandler, mappingTable, game)
{
    var mathDevice = devices.mathDevice;

    var appScene = new AppScene();

    appScene.renderer = null;
    appScene.materials = {};
    appScene.devices = devices;
    appScene.requestHandler = requestHandler;
    appScene.managers = managers;
    appScene.mappingTable = mappingTable;
    appScene.game = game;
    appScene.previousGameState = null;
    appScene.gameNode = {};
    appScene.boardNode = {};
    appScene.wormNodes = [];
    appScene.boardCubeNode = {};
    appScene.wormCubeNode = {};
    appScene.foodCubeNodes = [];
    appScene.camera = {};
    appScene.scene = Scene.create(devices.mathDevice);
    appScene.sceneLoader = SceneLoader.create();
    appScene.clearColor = mathDevice.v4Build(0, 0, 0, 1);

    // Stores references to worm parts for setting local transforms quickly
    appScene.wormPartsNodes = [];

    // Load the scene
    var v3Build = mathDevice.v3Build;
    var globalLightPosition = v3Build.call(mathDevice, 20.0, 0.0, 100.0);
    var ambientColor = v3Build.call(mathDevice, 0.3, 0.3, 0.4);

    /*var renderer = SimpleRendering.create(devices.graphicsDevice,
                                          mathDevice,
                                          managers.shaderManager,
                                          managers.effectManager);

    appScene.renderer = renderer;

    renderer.setGlobalLightPosition(globalLightPosition);
    renderer.setAmbientColor(ambientColor);*/

    //appScene.loadCube();

    return appScene;
};

// Copyright (c) 2011-2012 Turbulenz Limited

//
// Badge: Holds the current progress for the badge
//
function Badge() {}
Badge.prototype =
{
    // Update the status of the badge before updateuserbadgeprogress is called
    onBeforeSet : function onBeforeSetFn()
    {
        this.isUpdating = true;
    },

    // After progress has been successfully set
    onSuccessfulSet : function onSuccessfulSetFn(currentProgress)
    {
        this.isUpdating = false;
        if (currentProgress >= this.currentProgress)
        {
            this.hasProgressed = false;
        }
    },

    // After progress failed to be set
    onUnsuccessfulSet : function onUnsuccessfulSet()
    {
        this.isUpdating = false;
    },

    // Adds to the progress of the badge
    addProgress : function addProgress()
    {
        this.currentProgress += 1;
        this.currentProgress = Math.min(this.totalRequired, this.currentProgress);
        this.hasProgressed = true;
    },

    // Updates the status of the badge before awardbadge is called
    award : function awardFn()
    {
        this.isUpdating = true;
    },

    // Tests if badge has been achieved
    isAchieved : function isAchievedFn()
    {
        return this.currentProgress >= this.totalRequired;
    }
};

Badge.create = function badgeCreateFn(totalRequired, description, title)
{
    var badge = new Badge();

    // If it is a progress badge
    if (!totalRequired)
    {
        badge.isNonProgress = true;
    }

    badge.currentProgress = 0;
    badge.totalRequired = totalRequired;
    badge.hasProgressed = false;

    badge.description = description;
    badge.title = title;
    badge.isUpdating = false;

    return badge;
};

// Copyright (c) 2011-2012 Turbulenz Limited

/*global TurbulenzEngine: false*/
/*global Worm: false*/

//
// Game: Contains game logic for worm game
//
function Game() {}
Game.prototype =
{
    // Enums for states
    state :
    {
        PLAY : 0,
        DEAD : 1
    },

    // Update game
    update : function updateFn(isHost, moveWorms)
    {
        (this.gameStates[this.currentState]).call(this, isHost, moveWorms);
    },

    // Check collisions between worms and foods
    checkCollisions : function checkCollisionsFn()
    {
        var maxPlayers = this.gameSettings.maxPlayers;
        var myWormIndex = this.myWormIndex;
        var worms = this.worms;
        var i, j, worm;

        // Reset dead worms
        for (i = 0; i < maxPlayers; i += 1)
        {
            worm = worms[i];

            if (worm.killedBy !== null)
            {
                worm.killedBy = null;

                this.placeWorm(i);
            }
        }

        // Check worm collisions
        for (i = 0; i < maxPlayers; i += 1)
        {
            worm = worms[i];

            if (worm.isIntersectingSelf())
            {
                worm.die(i);

                if (i === myWormIndex)
                {
                    this.died(i);
                }
            }
            else
            {
                for (j = 0; j < maxPlayers; j += 1)
                {
                    if (i !== j)
                    {
                        if (worm.isIntersecting(worms[j]))
                        {
                            worm.die(j);

                            if (i === myWormIndex)
                            {
                                this.died(j);
                            }
                            else if (j === myWormIndex)
                            {
                                this.kill();
                            }

                            break;
                        }
                    }
                }
            }
        }

        // Check foods
        var foods = this.foods;
        for (i = 0; i < maxPlayers; i += 1)
        {
            var food = foods[i];
            var foodX = food.x;
            var foodY = food.y;

            food.eatenBy = null;

            for (j = 0; j < maxPlayers; j += 1)
            {
                worm = worms[j];
                if (worm.containsPosition(foodX, foodY))
                {
                    food.eatenBy = j;

                    if (j === myWormIndex)
                    {
                        worm.addToTail();
                        this.scored();
                    }

                    this.placeFood(i);

                    break;
                }
            }
        }
    },

    // Update loop whilst playing
    play : function playFn(isHost, moveWorms)
    {
        var myWormIndex = this.myWormIndex;
        if (myWormIndex < 0)
        {
            return;
        }

        this.badges.addBadge("played");

        if (moveWorms)
        {
            var worm = this.worms[myWormIndex];

            var newWormDirection = this.newWormDirection;
            if (newWormDirection !== null)
            {
                worm.changeDirection(newWormDirection);
                this.newWormDirection = null;
            }

            worm.update();
            if (worm.hasLooped)
            {
                this.badges.addBadge("driven_over_the_edge");
            }
        }

        if (isHost)
        {
            this.checkCollisions();
        }
    },

    // Update loop whilst dead
    dead : function deadFn(isHost, moveWorms)
    {
        if (isHost)
        {
            this.checkCollisions();
        }
    },

    // My worm eat food
    scored : function scoredFn()
    {
        this.score += this.scoreIncrement;
        this.gameSession.setStatus('Playing score ' + this.score);
        this.hasChangedScore = true;
        this.badges.addBadge("abstract_cube_devourer");
    },

    // Someone collided against me
    kill : function killFn()
    {
        this.kills += 1;
        this.hasChangedScore = true;
        this.badges.addBadge("abstract_killer");
    },

    // My worm died
    died : function diedFn(killedBy)
    {
        this.currentState = this.state.DEAD;
        this.gameSession.setStatus('Died with score ' + this.score);
        var badges = this.badges;
        var leaderboards = this.leaderboards;

        badges.addBadge("addicted");

        if (this.myWormIndex === killedBy)
        {
            badges.addBadge("suicidal_worm");
        }

        leaderboards.setScore("best-score", this.score);
        leaderboards.setScore("most-kills", this.kills);
    },

    // Randomly places food into a free space
    placeFood : function placeFoodFn(foodIndex)
    {
        var gameSettings = this.gameSettings;
        var xScaler = gameSettings.width;
        var yScaler = gameSettings.height;
        var maxPlayers = gameSettings.maxPlayers;

        var worms = this.worms;
        var foods = this.foods;

        var floor = Math.floor;
        var random = Math.random;
        var randomX;
        var randomY;
        var n, food;
        do
        {
            randomX = floor(random() * xScaler);
            randomY = floor(random() * yScaler);

            for (n = 0; n < maxPlayers; n += 1)
            {
                // Check worms
                if (worms[n].containsPosition(randomX, randomY))
                {
                    break;
                }

                // Check other foods
                if (n !== foodIndex)
                {
                    food = foods[n];
                    if (food.x === randomX && food.y === randomY)
                    {
                        break;
                    }
                }
            }
        }
        while (n < maxPlayers);

        food = foods[foodIndex];
        food.x = randomX;
        food.y = randomY;
        food.updated = true;
    },

    // Randomly places worm into a free space
    placeWorm : function placeWormFn(wormIndex)
    {
        var gameSettings = this.gameSettings;
        var xScaler = gameSettings.width;
        var yScaler = gameSettings.height;
        var maxPlayers = gameSettings.maxPlayers;

        var worms = this.worms;
        var foods = this.foods;

        var floor = Math.floor;
        var random = Math.random;
        var randomX;
        var randomY;
        var n, food;
        do
        {
            randomX = floor(random() * xScaler);
            randomY = floor(random() * yScaler);

            for (n = 0; n < maxPlayers; n += 1)
            {
                // Check other worms
                if (n !== wormIndex)
                {
                    if (worms[n].containsPosition(randomX, randomY))
                    {
                        break;
                    }
                }

                // Check foods
                food = foods[n];
                if (food.x === randomX && food.y === randomY)
                {
                    break;
                }
            }
        }
        while (n < maxPlayers);

        worms[wormIndex].reset(randomX, randomY);
    },

    // serialize the whole game
    serialize : function serializeFn(data)
    {
        var gameSettings = this.gameSettings;
        var maxPlayers = gameSettings.maxPlayers;

        var worms = this.worms;
        var foods = this.foods;

        var wormsState = [];
        var foodsState = [];

        var n;
        for (n = 0; n < maxPlayers; n += 1)
        {
            wormsState[n] = worms[n].serialize();

            var food = foods[n];

            foodsState[n] = {
                x: food.x,
                y: food.y
            };

            var eatenBy = food.eatenBy;
            if (eatenBy !== null)
            {
                foodsState[n].eatenBy = eatenBy;
            }
        }

        data.worms = wormsState;
        data.foods = foodsState;
    },

    // serialize delta information
    serializeDelta : function serializeDeltaFn(isHost, delta)
    {
        var gameSettings = this.gameSettings;
        var maxPlayers = gameSettings.maxPlayers;

        var updated = false;

        var myWormIndex = this.myWormIndex;
        var worms = this.worms;
        var wormsState = [];
        var worm;

        if (isHost)
        {
            var foods = this.foods;
            var foodsState = [];

            var n;
            for (n = 0; n < maxPlayers; n += 1)
            {
                worm = worms[n];
                if (worm.updated)
                {
                    worm.updated = false;
                    wormsState[n] = worm.serialize();
                }

                var food = foods[n];
                if (food.updated)
                {
                    food.updated = false;

                    foodsState[n] = {
                        x: food.x,
                        y: food.y
                    };

                    var eatenBy = food.eatenBy;
                    if (eatenBy !== null)
                    {
                        foodsState[n].eatenBy = eatenBy;
                    }
                }
            }

            if (0 < foodsState.length)
            {
                delta.foods = foodsState;
                updated = true;
            }
        }
        else
        {
            worm = worms[myWormIndex];
            if (worm.updated)
            {
                worm.updated = false;
                wormsState[myWormIndex] = worm.serialize();
            }
        }

        if (0 < wormsState.length)
        {
            delta.worms = wormsState;
            updated = true;
        }

        return updated;
    },

    // Deserialize game
    deserialize : function deserializeFn(isHost, data)
    {
        var myWormIndex = this.myWormIndex;
        var worms = this.worms;
        var foods = this.foods;

        var updated = false;
        var numStates, n;

        var wormsState = data.worms;
        if (wormsState !== undefined)
        {
            numStates = wormsState.length;
            for (n = 0; n < numStates; n += 1)
            {
                var wormState = wormsState[n];
                if (wormState)
                {
                    updated = true;

                    var worm = worms[n];

                    worm.deserialize(isHost, wormState);

                    if (!isHost)
                    {
                        var killedBy = worm.killedBy;
                        if (killedBy !== null)
                        {
                            worm.killedBy = null;

                            if (n === myWormIndex)
                            {
                                this.died(killedBy);
                            }
                            else if (killedBy === myWormIndex)
                            {
                                this.kill();
                            }
                        }
                    }
                }
            }
        }

        if (!isHost)
        {
            var foodsState = data.foods;
            if (foodsState !== undefined)
            {
                numStates = foodsState.length;
                for (n = 0; n < numStates; n += 1)
                {
                    var foodState = foodsState[n];
                    if (foodState)
                    {
                        updated = true;

                        var x = foodState.x;
                        var y = foodState.y;

                        var food = foods[n];

                        food.x = x;
                        food.y = y;

                        if (foodState.eatenBy === myWormIndex)
                        {
                            worms[myWormIndex].addToTail();
                            this.scored();
                        }
                    }
                }
            }
        }

        return updated;
    },

    // Returns the requested food
    getFood : function getFoodFn(foodIndex)
    {
        return this.foods[foodIndex];
    },

    // Returns the requested worm
    getWorm : function getWormFn(wormIndex)
    {
        return this.worms[wormIndex];
    },

    // Resets the worm, and food
    reset : function resetFn()
    {
        this.currentState = this.state.PLAY;
        this.gameSession.setStatus('Playing');
        this.score = 0;
        this.kills = 0;
        this.hasChangedScore = true;
        this.startTime = TurbulenzEngine.time;
    },

    // Start the game
    start : function startFn()
    {
        var maxPlayers = this.gameSettings.maxPlayers;
        var n;

        this.myWormIndex = 0;

        for (n = 0; n < maxPlayers; n += 1)
        {
            this.placeWorm(n);
        }

        for (n = 0; n < maxPlayers; n += 1)
        {
            this.placeFood(n);
        }
    },

    // Handles input
    onKeyDown : function onKeyDownFn(keynum)
    {
        var myWormIndex = this.myWormIndex;
        if (myWormIndex < 0)
        {
            return;
        }

        var worm = this.worms[myWormIndex];
        var direction = worm.direction;

        var keyCodes = this.keyCodes;

        switch (keynum)
        {
        case keyCodes.A:
        case keyCodes.LEFT:
        case keyCodes.NUMPAD_4:
            this.newWormDirection = direction.LEFT;
            break;

        case keyCodes.D:
        case keyCodes.RIGHT:
        case keyCodes.NUMPAD_6:
            this.newWormDirection = direction.RIGHT;
            break;

        case keyCodes.W:
        case keyCodes.UP:
        case keyCodes.NUMPAD_8:
            this.newWormDirection = direction.UP;
            break;

        case keyCodes.S:
        case keyCodes.DOWN:
        case keyCodes.NUMPAD_2:
            this.newWormDirection = direction.DOWN;
            break;

        case keyCodes.SPACE:
            if (this.currentState === this.state.DEAD)
            {
                this.reset();
            }
            break;

        case keyCodes.RETURN:
            this.graphicsDevice.fullscreen = !this.graphicsDevice.fullscreen;
            break;
        }
    },

    // Handles mouse input
    onMouseDown : function onMouseDownFn(button)
    {
        var myWormIndex = this.myWormIndex;
        if (myWormIndex < 0)
        {
            return;
        }

        var worm = this.worms[myWormIndex];
        var directionVector = worm.directionVector;
        var direction = worm.direction;

        var mouseCodes = this.mouseCodes;

        // If left mouse button
        if (mouseCodes.BUTTON_0 === button)
        {
            switch (directionVector)
            {
            case worm.upVector:
                this.newWormDirection = direction.LEFT;
                break;
            case worm.downVector:
                this.newWormDirection = direction.RIGHT;
                break;
            case worm.leftVector:
                this.newWormDirection = direction.DOWN;
                break;
            case worm.rightVector:
                this.newWormDirection = direction.UP;
                break;
            case worm.zeroVector:
                this.newWormDirection = direction.LEFT;
                break;
            }
        }
        // If right mouse button
        else if (mouseCodes.BUTTON_1 === button)
        {
            switch (directionVector)
            {
            case worm.upVector:
                this.newWormDirection = direction.RIGHT;
                break;
            case worm.downVector:
                this.newWormDirection = direction.LEFT;
                break;
            case worm.leftVector:
                this.newWormDirection = direction.UP;
                break;
            case worm.rightVector:
                this.newWormDirection = direction.DOWN;
                break;
            case worm.zeroVector:
                this.newWormDirection = direction.RIGHT;
                break;
            }
        }
    }
};

Game.create = function gameCreateFn(gameSettings, graphicsDevice,
                                    gameSession, leaderboards, badges,
                                    keyCodes, mouseCodes)
{
    var game = new Game();

    var state = game.state;

    game.currentState = state.PLAY;
    game.gameSession = gameSession;
    game.gameSession.setStatus('Playing');

    game.hasChangedScore = true;
    game.score = 0;
    game.kills = 0;

    game.myWormIndex = -1;

    game.gameStates = [];
    game.gameStates[state.PLAY] = game.play;
    game.gameStates[state.DEAD] = game.dead;

    game.graphicsDevice = graphicsDevice;
    game.scoreIncrement = 17;

    game.gameSettings = gameSettings;

    // Set default game settings if no value provided
    if (!gameSettings.width)
    {
        gameSettings.width = 10;
    }
    if (!gameSettings.height)
    {
        gameSettings.height = 10;
    }
    if (!gameSettings.boardSpacing)
    {
        gameSettings.boardSpacing = 1.2;
    }
    if (!gameSettings.maxPlayers)
    {
        gameSettings.maxPlayers = 1;
    }

    game.leaderboards = leaderboards;
    game.badges = badges;

    game.keyCodes = keyCodes;
    game.mouseCodes = mouseCodes;

    var maxPlayers = gameSettings.maxPlayers;
    var foods = [];
    var worms = [];

    var n;
    for (n = 0; n < maxPlayers; n += 1)
    {
        foods[n] = {
            x : -1,
            y : -1,
            updated : false,
            eatenBy : null
        };

        worms[n] = Worm.create(gameSettings);
    }

    game.foods = foods;
    game.worms = worms;

    game.newWormDirection = null;

    game.startTime = TurbulenzEngine.time;

    return game;
};

// Copyright (c) 2011-2012 Turbulenz Limited

/*global TurbulenzEngine: false*/
/*global Badge: false*/

//
// GameBadges: Class to manage game badges, and their html elements
//
function GameBadges() {}
GameBadges.prototype =
{
    // Adds the badges structure into the element div
    init : function initFn()
    {
        var that = this;

        function localInitialiseBadges(badges)
        {
            that.initialiseBadges(badges);
        }

        function localErrorCallback(msg, status)
        {
            that.initialiseBadgesErrorCallback(msg, status);
        }

        // Store and categorise badges
        this.badgesManager.listBadges(localInitialiseBadges, localErrorCallback);
    },

    // Error function when we fail to list & initialise badges
    initialiseBadgesErrorCallback : function initialiseBadgesErrorCallbackFn(msg, status)
    {
        this.isActive = false;
        this.onInitialization();
    },

    // Add all badges to unachieved badge dictionary
    initialiseBadges : function initialiseBadgesFn(badges)
    {
        var that = this;
        var unachievedBadges = this.unachievedBadges;

        function localInitialiseUserBadges(badges)
        {
            that.initialiseUserBadges(badges);
        }

        function localErrorCallback(msg, status)
        {
            that.initialiseBadgesErrorCallback(msg, status);
        }

        var i;
        var name;
        var badge;

        var length = badges.length;
        for (i = 0; i < length; i += 1)
        {
            badge = badges[i];
            name = badge.key;

            // Create an unachieved badge
            unachievedBadges[name] = Badge.create(badge.total, badge.description, badge.title);
        }

        // Add user badges to badges dictionary
        this.badgesManager.listUserBadges(localInitialiseUserBadges, localErrorCallback);
    },

    // Add user badges to unachieved and achieved badge dictionaries
    initialiseUserBadges : function initialiseUserBadges(badges)
    {
        var achievedBadges = this.achievedBadges;
        var unachievedBadges = this.unachievedBadges;

        var i;
        var name;
        var badge;
        var unachievedBadge;

        var length = badges.length;
        for (i = 0; i < length; i += 1)
        {
            badge = badges[i];
            name = badge.badge_key;
            unachievedBadge = unachievedBadges[name];
            if (unachievedBadge !== undefined)
            {
                // If already achieved then store as such
                if (!badge.current ||
                    badge.current >= unachievedBadge.totalRequired)
                {
                    achievedBadges[name] = unachievedBadge;
                    delete unachievedBadges[name];
                }
                else
                {
                    // Create an unachieved badge
                    unachievedBadge.currentProgress = badge.current;
                }
            }
        }

        this.isActive = true;
        this.onInitialization();
    },

    // Adds a user badge (with how much they have achieved towards it)
    addBadge : function addBadgeFn(badgeName)
    {
        var unachievedBadge;

        // If badge has not been achieved then update
        if (this.isActive &&
            !this.achievedBadges[badgeName])
        {
            unachievedBadge = this.unachievedBadges[badgeName];

            // If badge is non-progress then award it
            if (unachievedBadge.isNonProgress)
            {
                this.awardBadge(badgeName);
            }
            // Else update current badge progress
            else
            {
                unachievedBadge.addProgress();
                this.hasChanged = true;
            }
        }
    },

    // Awards a user badge no matter what the current progress
    awardBadge : function awardBadgeFn(badgeName)
    {
        if (this.isActive &&
            !this.achievedBadges[badgeName])
        {
            this.awardedBadges[badgeName] = true;
            this.hasChanged = true;
        }
    },

    // Updates the state of all badges
    refresh : function refreshFn()
    {
        var that = this;
        var unachievedBadges = this.unachievedBadges;
        var awardedBadges = this.awardedBadges;
        var badgesManager = this.badgesManager;

        var badge;
        var unachievedBadge;

        function localUpdateUserBadgeProgressCallback(badge)
        {
            that.updateUserBadgeProgressCallback(badge);
        }

        function localAwardUserBadgeCallback(badge)
        {
            that.awardUserBadgeCallback(badge);
        }

        function localUpdateUserBadgeErrorCallback(msg, status, badge)
        {
            that.updateUserBadgeErrorCallback(msg, status, badge);
        }

        function localAwardUserBadgeErrorCallback(msg, status, badge)
        {
            that.awardUserBadgeErrorCallback(msg, status, badge);
        }

        // Set awarded badges first
        for (badge in awardedBadges)
        {
            if (awardedBadges.hasOwnProperty(badge) &&
                !unachievedBadges[badge].isUpdating)
            {
                unachievedBadges[badge].award();
                badgesManager.awardUserBadge(badge, localAwardUserBadgeCallback, localAwardUserBadgeErrorCallback);
            }
        }

        // Update badges which have been incremented
        for (badge in unachievedBadges)
        {
            if (unachievedBadges.hasOwnProperty(badge))
            {
                unachievedBadge = unachievedBadges[badge];

                if (!unachievedBadge.isUpdating &&
                    unachievedBadge.hasProgressed)
                {
                    unachievedBadge.onBeforeSet();

                    badgesManager.updateUserBadgeProgress(badge, unachievedBadge.currentProgress,
                                               localUpdateUserBadgeProgressCallback, localUpdateUserBadgeErrorCallback);
                }
            }
        }
    },

    // Callback when user badge has been added
    updateUserBadgeProgressCallback : function updateUserBadgeProgressCallbackFn(badge)
    {
        var unachievedBadges = this.unachievedBadges;
        var badgeName = badge.badge_key;
        var unachievedBadge = unachievedBadges[badgeName];

        this.hasConnection = true;

        unachievedBadge.onSuccessfulSet(badge.current);

        // Used for writing html output on local
        this.hasChangedData = true;

        // If badge is now achieved
        if (unachievedBadge.isAchieved())
        {
            delete unachievedBadges[badgeName];
            this.achievedBadges[badgeName] = true;
        }
    },

    // Error callback when user badge failed to add
    updateUserBadgeErrorCallback : function updateUserBadgeErrorCallback(msg, status, badgeData)
    {
        var badgeName = badgeData[0];
        var unachievedBadge = this.unachievedBadges[badgeName];

        this.hasConnection = false;
        this.hasChanged = true;

        unachievedBadge.onUnsuccessfulSet();
    },

    // Callback when user badge has been awarded
    awardUserBadgeCallback : function awardUserBadgeCallback(badge)
    {
        var badgeName = badge.badge_key;

        delete this.unachievedBadges[badgeName];
        delete this.awardedBadges[badgeName];
        this.achievedBadges[badgeName] = true;

        this.hasConnection = true;
        this.hasChangedData = true;
    },

    // Callback when user badge has been awarded
    awardUserBadgeErrorCallback : function awardUserBadgeCallback(msg, status, badgeData)
    {
        var badgeName = badgeData[0];

        this.hasConnection = false;
        this.hasChanged = true;

        this.unachievedBadges[badgeName].onUnsuccessfulSet();
    },

    // Update function called in main loop
    update : function updateFn(currentTime)
    {
        var updateInterval = this.updateInterval;

        if (this.isActive &&
            this.hasChanged)
        {
            if (!this.hasConnection)
            {
                if (currentTime - this.lastUpdateTime > updateInterval)
                {
                    this.updateInterval = Math.min((updateInterval * 2), this.maxInterval);
                    this.lastUpdateTime = currentTime;
                    this.refresh();
                }
            }
            else
            {
                this.lastUpdateTime = currentTime;
                this.hasChanged = false;
                this.refresh();
            }
        }
    }
};

GameBadges.create = function createGameBadgesFn(badgesManager, onInitialization)
{
    var gameBadges = new GameBadges();

    gameBadges.badgesManager = badgesManager;
    gameBadges.onInitialization = onInitialization;

    gameBadges.unachievedBadges = {};
    gameBadges.achievedBadges = {};

    // Stores badges that will be awarded irrespective of current progress
    gameBadges.awardedBadges = {};

    gameBadges.hasChanged = true;

    // Used to know when to write html output
    gameBadges.hasChangedData = true;

    // True only if we have a leaderboard manager, and we are initialised
    gameBadges.isActive = false;

    // Vars to manage situation where connection to badges server is lost
    gameBadges.hasConnection = true;
    gameBadges.updateInterval = 1;
    gameBadges.maxInterval = 120;
    gameBadges.lastUpdateTime = TurbulenzEngine.time;

    if (badgesManager)
    {
        gameBadges.init();
    }
    else
    {
        onInitialization();
    }

    return gameBadges;
};

// Copyright (c) 2011-2012 Turbulenz Limited

/*global Leaderboard: false*/

//
// Leaderboard: Hold the html elements to write the leaderboard to and writes to them
//
function GameLeaderboards() {}
GameLeaderboards.prototype =
{
    // Adds the leadboard structure into the element div
    init : function initFn()
    {
        var that = this;
        var meta = this.leaderboardManager.meta;
        var leaderboards = this.leaderboards;
        var leaderboard;
        var spec =
        {
            friendsOnly: true
        };

        function initialiseLeaderboards(leaderboardArray)
        {
            that.initialiseLeaderboards(leaderboardArray);
        }

        function localErrorCallback(msg, status)
        {
            that.initialiseLeaderboardsErrorCallback(msg, status);
        }

        // Store leaderboards from meta
        for (leaderboard in meta)
        {
            if (meta.hasOwnProperty(leaderboard))
            {
                leaderboards[leaderboard] = Leaderboard.create(meta[leaderboard].sortBy, meta[leaderboard].title);
            }
        }

        // Add leaderboards to leaderboards dictionary
        this.leaderboardManager.getOverview(spec, initialiseLeaderboards, localErrorCallback);
    },

    // Error function when we fail to list & initialise badges
    initialiseLeaderboardsErrorCallback : function initialiseLeaderboardsErrorCallbackFn(msg, status)
    {
        this.isActive = false;
        this.onInitialization();
    },

    // Setup the dictionary to current leaderboard states
    initialiseLeaderboards : function initialiseLeaderboardsFn(leaderboardArray)
    {
        var length = leaderboardArray.length;
        var leaderboards = this.leaderboards;
        var score;
        var leaderboard;
        var currentLeaderboard;
        var leaderboardName;

        var i;

        for (i = 0; i < length; i += 1)
        {
            leaderboard = leaderboardArray[i];
            score = leaderboard.score;
            leaderboardName = leaderboard.key;
            currentLeaderboard = leaderboards[leaderboardName];

            currentLeaderboard.currentScore = score;
            currentLeaderboard.newScore = score;
        }

        this.isActive = true;
        this.onInitialization();
    },

    // Updates the specified leaderboard with the new score provided
    setScore : function updateScoreFn(leaderboardName, score)
    {
        if (this.isActive)
        {
            var leaderboard = this.leaderboards[leaderboardName];
            leaderboard.setScore(score);
            this.hasChanged = true;
        }
    },

    // Sends all new leaderboard data
    refresh : function refreshFn()
    {
        var leaderboards = this.leaderboards;

        var leaderboardName;
        var leaderboard;

        // Refresh each leaderboard if there is a newscore
        for (leaderboardName in leaderboards)
        {
            if (leaderboards.hasOwnProperty(leaderboardName))
            {
                leaderboard = leaderboards[leaderboardName];

                if (!leaderboard.isUpdating &&
                    leaderboard.hasImprovedScore())
                {
                    leaderboard.onBeforeSet();
                    this.refreshLeaderboard(leaderboardName, leaderboard.newScore);
                }
            }
        }
    },

    // Sends the data for the specified leaderboard
    refreshLeaderboard : function refreshLeaderboardFn(leaderboardName, score)
    {
        var that = this;

        function localSetLeaderboardCallback(key, score, newBest, bestScore)
        {
            that.setLeaderboardCallback(key, score, newBest, bestScore);
        }

        function localSetErrorCallback(msg, status, setFunction, leaderboard)
        {
            that.setErrorCallback(msg, status, setFunction, leaderboard);
        }

        this.leaderboardManager.set(leaderboardName, score, localSetLeaderboardCallback, localSetErrorCallback);
    },

    // Update function called in main loop
    update : function updateFn(currentTime)
    {
        var updateInterval = this.updateInterval;

        if (this.isActive &&
            this.hasChanged)
        {
            if (!this.hasConnection)
            {
                if (currentTime - this.lastUpdateTime > updateInterval)
                {
                    this.updateInterval = Math.min((updateInterval * 2), this.maxInterval);
                    this.lastUpdateTime = currentTime;
                    this.refresh();
                }
            }
            else
            {
                this.hasChanged = false;
                this.lastUpdateTime = currentTime;
                this.refresh();
            }
        }
    },

    // After successful leaderboard set
    setLeaderboardCallback : function setLeaderboardCallback(key, score, newBest, bestScore)
    {
        var leaderboard = this.leaderboards[key];
        leaderboard.onSuccessfulSet(bestScore);

        // Used for writing html output on local
        this.hasChangedData = true;

        this.hasConnection = true;
    },

    // Error callback - uses window alert
    setErrorCallback : function setErrorCallbackFn(msg, status, setFunction, leaderboardData)
    {
        var leaderboardName = leaderboardData[0];
        var leaderboard = this.leaderboards[leaderboardName];

        leaderboard.onUnsuccessfulSet();

        this.hasConnection = false;
        this.hasChanged = true;
    }
};

GameLeaderboards.create = function leaderboardCreateFn(leaderboardManager, onInitialization)
{
    var gameLeaderboards = new GameLeaderboards();

    gameLeaderboards.leaderboardManager = leaderboardManager;
    gameLeaderboards.onInitialization = onInitialization;

    gameLeaderboards.leaderboards = {};
    gameLeaderboards.hasChanged = true;

    // Used to know when to write html output
    gameLeaderboards.hasChangedData = true;

    // True only if we have a leaderboard manager, and we are initialised
    gameLeaderboards.isActive = false;

    // Vars to manage situation where connection to badges server is lost
    gameLeaderboards.hasConnection = true;
    gameLeaderboards.updateInterval = 1;
    gameLeaderboards.maxInterval = 120;
    gameLeaderboards.lastUpdateTime = TurbulenzEngine.time;

    // Test if we were passed a valid leaderboard manager
    if (leaderboardManager)
    {
        gameLeaderboards.init();
    }
    else
    {
        onInitialization();
    }

    return gameLeaderboards;
};

// Copyright (c) 2011-2012 Turbulenz Limited

//
// HtmlWriter: Class to format and write badge and leaderboard data to page
//
function HtmlWriter() {}
HtmlWriter.prototype =
{
    init : function initFn(scoreDivID, killsDivID, leaderboardDivId, badgesDivId)
    {
        var unachievedBadges = this.badges.unachievedBadges;
        var achievedBadges = this.badges.achievedBadges;
        var unachievedBadge;
        var achievedBadge;
        var leaderboards = this.leaderboards.leaderboards;
        var leaderboardDivs = this.leaderboardDivs;
        var badgeDivs = this.badgeDivs;

        var leaderboardDiv;
        var badgeDiv;
        var leaderboard;
        var badge;

        this.scoreDiv = document.getElementById(scoreDivID);
        this.killsDiv = document.getElementById(killsDivID);
        this.leaderboardsDiv = document.getElementById(leaderboardDivId);
        this.badgesDiv = document.getElementById(badgesDivId);

        if (!this.scoreDiv ||
            !this.killsDiv ||
            !this.leaderboardsDiv ||
            !this.badgesDiv)
        {
            this.runAsTzjs = true;
            return;
        }

        // Add each leaderboard
        for (leaderboard in leaderboards)
        {
            if (leaderboards.hasOwnProperty(leaderboard))
            {
                leaderboardDiv =
                {
                    name : leaderboard,
                    title : leaderboards[leaderboard].title,
                    dataDiv : null
                };

                leaderboardDivs[leaderboard] = leaderboardDiv;

                this.addLeaderboardHtml(leaderboardDiv);
            }
        }

        // Add each achieved badge
        for (badge in achievedBadges)
        {
            if (achievedBadges.hasOwnProperty(badge))
            {
                achievedBadge = achievedBadges[badge];

                badgeDiv =
                {
                    name : badge,
                    description : achievedBadge.description,
                    title: achievedBadge.title,
                    dataDiv : null
                };
                badgeDivs[badge] = badgeDiv;

                this.addBadgeHtml(badgeDiv);
            }
        }

        // Add each unachieved badge
        for (badge in unachievedBadges)
        {
            if (unachievedBadges.hasOwnProperty(badge))
            {
                unachievedBadge = unachievedBadges[badge];

                badgeDiv =
                {
                    name : badge,
                    description : unachievedBadge.description,
                    title: unachievedBadge.title,
                    dataDiv : null
                };
                badgeDivs[badge] = badgeDiv;

                this.addBadgeHtml(badgeDiv);
            }
        }
    },

    // Creates html structure for a leaderboard
    addLeaderboardHtml : function addLeaderboardHtmlFn(leaderboard)
    {
        var leaderboardName = leaderboard.name;
        var leaderboardTitle = leaderboard.title;
        var leaderboardNameDiv;
        var leaderboardDiv;
        var leaderboardDataDiv;
        var leaderboardsDiv = this.leaderboardsDiv;

        // Adds the div
        leaderboardDiv = document.createElement("div");
        leaderboardDiv.id = leaderboardName;
        leaderboardDiv.className = "leaderboard-block";
        leaderboardsDiv.appendChild(leaderboardDiv);

        // Adds the title div
        leaderboardNameDiv = document.createElement("div");
        leaderboardNameDiv.className = "leaderboard-block-title";
        this.writeTextContent(leaderboardNameDiv, leaderboardTitle);
        leaderboardDiv.appendChild(leaderboardNameDiv);

        // Adds the leaderboard content div
        leaderboardDataDiv = document.createElement("span");
        leaderboard.dataDiv = leaderboardDataDiv;
        leaderboardDataDiv.id = (leaderboardName + "_data");
        leaderboardDataDiv.className = "leaderboard-block-score";
        leaderboardDiv.appendChild(leaderboardDataDiv);
    },

    // Creates html structure for a badge
    addBadgeHtml : function addBadgeHtmlFn(badge)
    {
        var badgeName = badge.name;
        var badgeTitle = badge.title;
        var badgeDiv;
        var badgeWrapperDiv;
        var badgeNameDiv;
        var badgeDescriptionDiv;
        var badgeDataDiv;
        var badgesDiv = this.badgesDiv;

        // Adds the div
        badgeDiv = document.createElement("div");
        badgeDiv.id = badgeName;
        badgeDiv.className = "badge-block";
        badgesDiv.appendChild(badgeDiv);

        // Add the title + description wrapper
        badgeWrapperDiv = document.createElement("div");
        badgeWrapperDiv.className = "badge-block-wrapper";
        badgeDiv.appendChild(badgeWrapperDiv);

        // Add the title div
        badgeNameDiv = document.createElement("div");
        badgeNameDiv.className = "badge-block-title";
        this.writeTextContent(badgeNameDiv, badgeTitle);
        badgeWrapperDiv.appendChild(badgeNameDiv);

        // Add the description div
        badgeDescriptionDiv = document.createElement("div");
        badgeDescriptionDiv.className = "badge-block-description";
        this.writeTextContent(badgeDescriptionDiv, badge.description);
        badgeWrapperDiv.appendChild(badgeDescriptionDiv);

        // Adds the badge content div
        badgeDataDiv = document.createElement("div");
        badge.dataDiv = badgeDataDiv;
        badgeDataDiv.id = badgeName + "_data";
        badgeDataDiv.className = "badge-block-progress";
        badgeDiv.appendChild(badgeDataDiv);
    },

    // (Re)Writes the current score html
    writeScore : function writeScoreFn()
    {
        this.writeTextContent(this.scoreDiv, this.game.score);
        this.writeTextContent(this.killsDiv, this.game.kills);
    },

    // (Re)Writes all leaderboards html
    writeLeaderboards : function writeLeaderboardsFn()
    {
        var leaderboards = this.leaderboards.leaderboards;

        var leaderboard;

        for (leaderboard in leaderboards)
        {
            if (leaderboards.hasOwnProperty(leaderboard))
            {
                this.writeLeaderboard(leaderboard);
            }
        }
    },

    // (Re)Writes all badges html
    writeBadges : function writeBadgesFn()
    {
        var achievedBadges = this.badges.achievedBadges;
        var unachievedBadges = this.badges.unachievedBadges;

        var badge;

        for (badge in achievedBadges)
        {
            if (achievedBadges.hasOwnProperty(badge))
            {
                this.writeAchievedBadge(badge);
            }
        }

        for (badge in unachievedBadges)
        {
            if (unachievedBadges.hasOwnProperty(badge))
            {
                this.writeUnachievedBadge(badge);
            }
        }
    },

    // (Re)Write leaderboard html content
    writeLeaderboard : function writeLeaderboardFn(leaderboardName)
    {
        var leaderboard = this.leaderboards.leaderboards[leaderboardName];
        var leaderboardString = "";

        // Create leaderboard data string
        if (leaderboard.currentScore)
        {
            leaderboardString += leaderboard.currentScore.toFixed(0).toString(10);
        }
        else
        {
            leaderboardString += "None set";
        }

        this.writeTextContent(this.leaderboardDivs[leaderboardName].dataDiv, leaderboardString);
    },

    // (Re)Write achieved badge html content
    writeAchievedBadge : function writeBadgeFn(badgeName)
    {
        var badgeString = "";
        var badgeDataDiv = this.badgeDivs[badgeName].dataDiv;

        badgeString += "Got this!";

        this.writeTextContent(badgeDataDiv, badgeString);
    },

    // (Re)Write unachieved badge html content
    writeUnachievedBadge : function writeBadgeFn(badgeName)
    {
        var badge = this.badges.unachievedBadges[badgeName];
        var badgeDataDiv = this.badgeDivs[badgeName].dataDiv;
        var badgeProgress = badge.currentProgress ? badge.currentProgress.toString(10) : "0";
        var badgeString = "";

        // Create badge data string
        if (badge.totalRequired)
        {
            badgeString += badgeProgress;
            badgeString += "/";
            badgeString += badge.totalRequired.toString(10);
        }
        else
        {
            badgeString += "Unachieved";
        }

        this.writeTextContent(badgeDataDiv, badgeString);
    },

    // Writes text to element specified
    writeTextContent : function writeTextContentFn(element, value)
    {
        var content;

        if (!element)
        {
            return;
        }

        content = element.textContent;

        if (value !== undefined)
        {
            // Check if text content is defined (not in ie)
            if (content !== undefined)
            {
                element.textContent = value;
            }
            else
            {
                element.innerText = value;
            }
        }
    },

    // Refreshed the score/leaderboards/badges html content if necessary
    update : function updateFn()
    {
        if (this.runAsTzjs)
        {
            return;
        }

        var leaderboards = this.leaderboards;
        var badges = this.badges;
        var game = this.game;

        if (leaderboards.hasChangedData)
        {
            leaderboards.hasChangedData = false;
            this.writeLeaderboards();
        }

        if (badges.hasChangedData)
        {
            badges.hasChangedData = false;
            this.writeBadges();
        }

        if (game.hasChangedScore)
        {
            game.hasChangedScore = false;
            this.writeScore();
        }
    }
};

HtmlWriter.create = function htmlWriterCreateFn(leaderboards, badges, game)
{
    var htmlWriter = new HtmlWriter();

    htmlWriter.leaderboards = leaderboards;
    htmlWriter.badges = badges;
    htmlWriter.game = game;

    htmlWriter.leaderboardsDiv = {};
    htmlWriter.badgesDiv = {};
    htmlWriter.scoreDiv = {};
    htmlWriter.killsDiv = {};

    htmlWriter.leaderboardDivs = {};
    htmlWriter.badgeDivs = {};

    // To avoid writing to the page if run as tzjs
    htmlWriter.runAsTzjs = false;

    htmlWriter.init("scores", "kills", "leaderboards", "badges");

    return htmlWriter;
};

// Copyright (c) 2011-2012 Turbulenz Limited

//
// Leaderboard: Holds the current score, new score and set score logic for a leaderboard
//
function Leaderboard() {}
Leaderboard.prototype =
{
    // Before the leaderboard set call is made
    onBeforeSet : function onBeforeSetFn()
    {
        this.isUpdating = true;
    },

    // When leaderboard set callback is made
    onSuccessfulSet : function onSuccessfulSetFn(bestScore)
    {
        this.currentScore = bestScore;
        this.isUpdating = false;
    },

    // When leaderboard set failed
    onUnsuccessfulSet : function onUnsuccessfulSetFn()
    {
        this.isUpdating = false;
    }
};

Leaderboard.create = function leaderboardCreateFn(sortBy, title)
{
    var leaderboard = new Leaderboard();

    leaderboard.sortBy = sortBy;
    leaderboard.title = title;
    leaderboard.isUpdating = false;

    function setHighScore(score)
    {
        if (score > this.newScore)
        {
            this.newScore = score;
        }
    }

    function setLowScore(score)
    {
        if (score < this.newScore ||
            !this.newScore)
        {
            this.newScore = score;
        }
    }

    function hasImprovedHighScore()
    {
        if (this.newScore > this.currentScore)
        {
            return true;
        }

        return false;
    }

    function hasImprovedLowScore()
    {
        if (this.newScore < this.currentScore ||
            this.newScore && !this.currentScore)
        {
            return true;
        }

        return false;
    }

    if (sortBy > 0)
    {
        leaderboard.currentScore = 0;
        leaderboard.newScore = 0;
        leaderboard.setScore = setHighScore;
        leaderboard.hasImprovedScore = hasImprovedHighScore;
    }
    else
    {
        leaderboard.currentScore = null;
        leaderboard.newScore = null;
        leaderboard.setScore = setLowScore;
        leaderboard.hasImprovedScore = hasImprovedLowScore;
    }

    return leaderboard;
};

// Copyright (c) 2011-2012 Turbulenz Limited

//
// Worm: Worm class
//
function Worm() {}
Worm.prototype =
{
    // Enums for worm direction
    direction :
    {
        NONE : -1,
        UP : 0,
        DOWN : 1,
        RIGHT : 2,
        LEFT : 3
    },

    upVector    : [ 0,  1],
    downVector  : [ 0, -1],
    rightVector : [ 1,  0],
    leftVector  : [-1,  0],
    zeroVector  : [ 0,  0],

    // Changes the worm's direction
    changeDirection : function changeDirectionFn(newDirection)
    {
        var direction = this.direction;
        var directionVector = this.directionVector;
        var newDirectionVector;

        switch (newDirection)
        {
        case direction.UP:
            if (directionVector !== this.downVector)
            {
                newDirectionVector = this.upVector;
            }
            break;
        case direction.DOWN:
            if (directionVector !== this.upVector)
            {
                newDirectionVector = this.downVector;
            }
            break;
        case direction.RIGHT:
            if (directionVector !== this.leftVector)
            {
                newDirectionVector = this.rightVector;
            }
            break;
        case direction.LEFT:
            if (directionVector !== this.rightVector)
            {
                newDirectionVector = this.leftVector;
            }
            break;
        default:
            newDirectionVector = this.zeroVector;
            break;
        }

        if (newDirectionVector !== undefined)
        {
            if (directionVector !== newDirectionVector)
            {
                this.directionVector = newDirectionVector;
                this.updated = true;
            }
        }
    },

    // Update called every frame
    update : function updateFn()
    {
        if (this.directionVector !== this.zeroVector)
        {
            this.moveBody();
            this.moveHead();
            this.updated = true;
        }

        this.killedBy = null;
    },

    // Collided with something
    die : function dieFn(killedBy)
    {
        this.directionVector = this.zeroVector;
        this.killedBy = killedBy;
        this.updated = true;
    },

    // Serialize worm information
    serialize : function serializeFn()
    {
        var directionVector = this.directionVector;
        var direction = this.direction;

        var dir;
        if (directionVector === this.downVector)
        {
            dir = direction.DOWN;
        }
        else if (directionVector === this.upVector)
        {
            dir = direction.UP;
        }
        else if (directionVector === this.leftVector)
        {
            dir = direction.LEFT;
        }
        else if (directionVector === this.rightVector)
        {
            dir = direction.RIGHT;
        }
        else //if (directionVector === this.zeroVector)
        {
            dir = direction.NONE;
        }

        var data = {
            dir: dir,
            x: this.partsPositionX.slice(),
            y: this.partsPositionY.slice()
        };

        var killedBy = this.killedBy;
        if (killedBy !== null)
        {
            data.killedBy = killedBy;
        }

        return data;
    },

    // Deserialize from external data
    deserialize : function deserializeFn(isHost, data)
    {
        var partsPositionX = this.partsPositionX;
        var partsPositionY = this.partsPositionY;
        var numParts = partsPositionX.length;

        if (!isHost)
        {
            var killedBy = data.killedBy;
            if (killedBy !== undefined)
            {
                this.killedBy = killedBy;
            }
            else
            {
                this.killedBy = null;
            }
        }

        var direction = this.direction;
        switch (data.dir)
        {
        case direction.UP:
            this.directionVector = this.upVector;
            break;
        case direction.DOWN:
            this.directionVector = this.downVector;
            break;
        case direction.RIGHT:
            this.directionVector = this.rightVector;
            break;
        case direction.LEFT:
            this.directionVector = this.leftVector;
            break;
        default:
            this.directionVector = this.zeroVector;
            break;
        }

        var newPartsPositionX = data.x;
        var newPartsPositionY = data.y;
        var newNumParts = newPartsPositionX.length;

        if (numParts !== newNumParts)
        {
            partsPositionX.length = newNumParts;
            partsPositionY.length = newNumParts;
        }

        for (var n = 0; n < newNumParts; n += 1)
        {
            partsPositionX[n] = newPartsPositionX[n];
            partsPositionY[n] = newPartsPositionY[n];
        }
    },

    // Moves all of worm parts as required
    moveBody : function moveBodyFn()
    {
        var partsPositionX = this.partsPositionX;
        var partsPositionY = this.partsPositionY;
        var length = partsPositionX.length;
        var tailIndex = (length - 1);

        var i;

        // Update the previous tail position
        this.previousTailX = partsPositionX[tailIndex];
        this.previousTailY = partsPositionY[tailIndex];

        // Copy positions from back to front
        for (i = tailIndex; i > 0; i -= 1)
        {
            partsPositionX[i] = partsPositionX[i - 1];
            partsPositionY[i] = partsPositionY[i - 1];
        }
    },

    // Moves head and loops over board edge if necessary
    moveHead : function moveHeadFn()
    {
        var boardWidth = this.boardWidth;
        var boardHeight = this.boardHeight;
        var partsPositionX = this.partsPositionX;
        var partsPositionY = this.partsPositionY;
        var directionVector = this.directionVector;
        var headPositionX = partsPositionX[0];
        var headPositionY = partsPositionY[0];

        // Update head of snake
        headPositionX += directionVector[0];
        headPositionY += directionVector[1];

        this.hasLooped = true;

        // Adjust if it has gone off edge
        if (headPositionX === boardWidth)
        {
            headPositionX = 0;
        }
        else if (headPositionX === -1)
        {
            headPositionX = boardWidth - 1;
        }
        else if (headPositionY === boardHeight)
        {
            headPositionY = 0;
        }
        else if (headPositionY === -1)
        {
            headPositionY = boardHeight - 1;
        }
        else
        {
            this.hasLooped = false;
        }

        partsPositionX[0] = headPositionX;
        partsPositionY[0] = headPositionY;
    },

    // Increases worm length by 1
    addToTail : function addToTailFn()
    {
        var partsPositionX = this.partsPositionX;
        var partsPositionY = this.partsPositionY;
        var length = partsPositionX.length;

        partsPositionX[length] = this.previousTailX;
        partsPositionY[length] = this.previousTailY;

        this.updated = true;
    },

    // Tests for self intersection
    isIntersectingSelf : function isIntersectingSelfFn()
    {
        var partsPositionX = this.partsPositionX;
        var partsPositionY = this.partsPositionY;
        var length = partsPositionX.length;
        var headX = partsPositionX[0];
        var headY = partsPositionY[0];

        var i;

        for (i = 1; i < length; i += 1)
        {
            if (partsPositionX[i] === headX &&
                partsPositionY[i] === headY)
            {
                return true;
            }
        }

        return false;
    },

    // Tests for intersection with other worms
    isIntersecting : function isIntersectingFn(otherWorm)
    {
        var otherPartsPositionX = otherWorm.partsPositionX;
        var otherPartsPositionY = otherWorm.partsPositionY;
        var otherLength = otherPartsPositionX.length;

        var headX = this.partsPositionX[0];
        var headY = this.partsPositionY[0];

        var i;

        for (i = 0; i < otherLength; i += 1)
        {
            if (otherPartsPositionX[i] === headX &&
                otherPartsPositionY[i] === headY)
            {
                return true;
            }
        }

        return false;
    },

    // Tests if position x,y is covered by worm
    containsPosition : function containsPosition(x, y)
    {
        var partsPositionX = this.partsPositionX;
        var partsPositionY = this.partsPositionY;
        var length = partsPositionX.length;

        var i;

        for (i = 0; i < length; i += 1)
        {
            if (partsPositionX[i] === x &&
                partsPositionY[i] === y)
            {
                return true;
            }
        }

        return false;
    },

    // Test if position x,y is covered by worm head
    isOnHead : function isOnHeadFn(x, y)
    {
        if (this.partsPositionX[0] === x &&
            this.partsPositionY[0] === y)
        {
            return true;
        }

        return false;
    },

    // Resets worm to original state
    reset : function reset(x, y)
    {
        this.hasLooped = false;

        var partsPositionX = this.partsPositionX;
        var partsPositionY = this.partsPositionY;

        this.directionVector = this.zeroVector;

        partsPositionX.length = 1;
        partsPositionY.length = 1;

        partsPositionX[0] = x;
        partsPositionY[0] = y;

        this.previousTailX = x;
        this.previousTailY = y;

        this.updated = true;
    }
};

Worm.create = function wormCreateFn(gameSettings)
{
    var worm = new Worm();

    worm.boardSpacing = gameSettings.boardSpacing;
    worm.boardWidth = gameSettings.width;
    worm.boardHeight = gameSettings.height;
    worm.maxPlayers = gameSettings.maxPlayers;

    worm.directionVector = worm.zeroVector;

    worm.partsPositionX = [];
    worm.partsPositionY = [];
    worm.previousTailX = 0;
    worm.previousTailY = 0;

    worm.killedBy = null;
    worm.updated = false;

    return worm;
};

// Copyright (c) 2011-2012 Turbulenz Limited

/*global TurbulenzEngine: false*/
/*global Loader: false*/
/*global Game: false*/
/*global TurbulenzServices: false*/
/*global RequestHandler: false*/
/*global TextureManager: false*/
/*global ShaderManager: false*/
/*global EffectManager: false*/
/*global FontManager: false*/
/*global GameBadges: false*/
/*global GameLeaderboards: false*/
/*global AppScene: false*/
/*global Utilities: false*/
/*global HtmlWriter: false*/
/*global window: false*/

//
// Application: The global for the whole application (singleton)
//
function Application() {}
Application.prototype =
{
  soundBubbleUp : false,
  soundBubbleDown : false,
  soundTitleMusic : false,
  soundMainMusic : false,
  soundScoreScreen : false,
  soundWinner : false,
  soundLoser : false,

    gameSettings : {
        width : 30,  // Must be a multiple of 2
        height : 16, // Must be a multiple of 2
        boardSpacing : 1.1,
        maxPlayers : 3
    },

    gameTimeStep : 0.05,

    networkIds : {
        joining : 0,
        update : 1,
        leaving : 2
    },

    staleTime : 1.5,

    // Error callback - uses window alert
    errorCallback : function errorCallbackFn(msg)
    {
        window.alert(msg);
    },

    // Initialise the application
    init : function initFn()
    {
        // Test for minimum engine version, device creation, and shader support
        if (!this.createDevices())
        {
            return;
        }

        this.watair.init();

        this.pixelWidth = 240;
        this.pixelHeight = 320;
        this.ratio = this.pixelWidth / this.pixelHeight;
        this.wInnerWidth = 0;
        this.wInnerHeight = 0;

        this.canvasResize();

        var creationFunctions =
        [
            {func : this.createGameSession, isDependent : false},
            {func : this.createMappingTable, isDependent : true},
            {func : this.createGameSounds, isDependent : false, noCallback : true },
            {func : this.createGame, isDependent : true, noCallback : true},
            {func : this.createHTMLWriter, isDependent : true, noCallback : true},
            {func : this.enterLoadingLoop, isDependent : true}
        ];
        
        this.enterCallbackChain(this, creationFunctions);

        var endpoint = 'http://10.10.2.44:8083';
        var socket = io.connect(endpoint);
        var app = this;
        this.socket = socket;

        // Socket events
        socket.on('connect', function(){
//          app.console.log("Connected to server!");
        });

        socket.on('disconnect', function(s){
//          app.console.log("Disconnected from server!");
        });

        socket.on('msg', function(data) {
          if (typeof data.type != 'undefined') {
            if (data.type == 'move') {
              app.watair.moveOpponentTo(data.player.coordinates.x, data.player.coordinates.y);
            }
            if (data.type == 'setPlayer') {
              app.watair.setPlayer(data.num);
            }
          }
        });
        
        socket.on('waterLevelChanged', function(change){
          app.watair.waterSprite.addChange(change);
        });
        
        app.watair.waterLevelChanged = function(change) {
          socket.emit('waterLevelChanged', change);
        }

    },

    // Update function called in main loop
    update : function updateFn(currentTime)
    {
        var devices = this.devices;

        devices.inputDevice.update();

        //devices.networkDevice.update();

        var heartbeat = false;

        if ((currentTime - this.previousGameUpdateTime) > this.gameTimeStep)
        {
            this.previousGameUpdateTime = currentTime;

            //this.checkOthers();

            heartbeat = true;
        }

        if (this.updateGame(heartbeat))
        {
            this.watair.update();

            //this.leaderboards.update(currentTime);

            //this.badges.update(currentTime);

            //this.htmlWriter.update();

            return true;
        }

        return false;
    },

    loadImages : function loadImagesFn(mappingTable)
    {
        var app = this;
    	this.images = [];

		var backgroundImageName = 'textures/bg.jpg';
		this.backgroundImage = new Image();
        var bgImgURL = mappingTable[backgroundImageName];
        if (bgImgURL)
        {

            this.backgroundImage.src = bgImgURL;
        }
        else
        {
            app.console.error('Image missing: ', backgroundImageName);

        }

		function loadImage(sprite, imageName, images)
		{
			imageURL = mappingTable[imageName];
            if (imageURL)
            {
                image = images[imageName];
                if (!image)
                {
                    image = new Image();
                }
                image.src = imageURL;
                images[imageName] = image;
                return image;
            } else {
            	app.console.error('Image for sprite ' + sprite + ' missing: ', sprite.imageName);
                return null;
            }
		}

		function pad(number, length)
		{
		    var str = '' + number;
		    while (str.length < length)
		    {
		        str = '0' + str;
		    }

		    return str;
		}

		function getAnimatedFilenames(filename)
		{
			var matches = filename.match(/([a-z \/]+)(\d+)\.([a-z]+)/);
			if (null === matches) {
				return null;
			}

			var max = matches[2], paddedNum, animFilenames = [];
			for (var i = 1; i <= max; i++) {
				paddedNum = pad(i, 4);
				frameName = matches[1] + paddedNum + "." + matches[3];
				animFilenames.push(frameName);
			}
			return animFilenames;
		}

		function loadAnimFrames(sprite, images, animFilenames, aFrames) {
        	var animFrames = [];
        	for (var i = 0; i < animFilenames.length; i++)
        	{
        		image = loadImage(sprite, animFilenames[i], images);
        		animFrames.push(image);
        	}
        	sprite.setAnimFrames(animFrames);
		}

		function loadSprites(sprites, images) {
	        var sprite, image, imageName, animFilenames;

	        for (var i = sprites.length - 1; i >= 0; i--)
	        {
	            sprite = sprites[i];
	            imageName = sprite.imageName;
	            animFilenames = getAnimatedFilenames(imageName);
	            if (animFilenames)
	            {
	            	loadAnimFrames(sprite, images, animFilenames, animFilenames);
	            } else {
		            image = loadImage(sprite, imageName, images);
		            sprite.setImage(image);
	            }
	        }
		}
		loadSprites(this.watair.sprites, this.images);
    },

    // Update game state
    updateGame : function updateGameFn(heartbeat)
    {
        var isHost = this.isHost;
        var game = this.game;

        game.update(isHost, heartbeat);

        var multiplayerSession = this.multiplayerSession;
        if (multiplayerSession)
        {
            var updateData = {
                frame: this.frameCounter
            };

            var needToSend = game.serializeDelta(isHost, updateData);
            if (needToSend)
            {
                if (isHost)
                {
                    updateData.host = true;
                }

                multiplayerSession.sendToAll(this.networkIds.update, JSON.stringify(updateData));
            }
            else if (heartbeat)
            {
                multiplayerSession.sendToAll(this.networkIds.update);
            }
        }

        if (heartbeat)
        {
            this.frameCounter += 1;
            this.needToRender = true;
        }

        return this.needToRender;
    },

    // Render function called in main loop
    render : function renderFn(currentTime)
    {
        this.renderCanvas();

        this.needToRender = false;
    },

    canvasResize : function canvasResizeFn()
    {
        var canvas = this.canvas;
        var canvas2dContext = this.canvas2dContext;

        this.wInnerHeight = window.innerHeight;
        this.wInnerWidth = window.innerWidth;

        canvas.width = (window.innerHeight * this.ratio);
        canvas.height = window.innerHeight;

        this.scaleX = window.innerHeight / this.pixelHeight;
        this.scaleY = canvas.width / this.pixelWidth;


        //canvas2dContext.translate(
         //                       -(((canvas2dContext.canvas.width * scale) - canvas2dContext.canvas.width) >> 1),
         //                       -(((canvas2dContext.canvas.height * scale) - canvas2dContext.canvas.height) >> 1));
        canvas2dContext.scale(this.scaleX, this.scaleY);

        this.width = canvas.width;
        this.height = canvas.height;
    },

    renderCanvas : function renderCanvasFn()
    {
        var canvas = this.canvas;
        var canvas2dContext = this.canvas2dContext;

        var innerHeight = window.innerHeight;
        var innerWidth = window.innerWidth;

        if (innerHeight != this.wInnerHeight || innerWidth != this.wInnerWidth)
        {
            this.canvasResize();
        }

        canvas2dContext.clearRect(0 , 0, this.width, this.height);

        canvas2dContext.drawImage(this.backgroundImage , 0, 0);
        this.watair.draw(canvas2dContext);




        // Focus
        //if (this.isFocused)
        //{
        //    this.drawFocusBorder();
        //}
        //
        //// Lock button
        //this.drawLockButton();
        //
        //// Draw text event output
        //this.drawEventText();
        //
        //if (this.logPadMoveInput)
        //{
        //    this.drawPadMove();
        //}
        //
        //this.drawCursor();
    },

    // Load UI
    loadUI : function loadUI()
    {
        //var managers = this.managers;
        //managers.fontManager.load('fonts/hero.fnt');
        //managers.shaderManager.load('shaders/font.cgfx');
    },

    hasUILoaded : function hasUILoadedFn()
    {
        return true;
        var managers = this.managers;
        var fontManager = managers.fontManager;
        var shaderManager = managers.shaderManager;
        if (fontManager.getNumPendingFonts() === 0 &&
            shaderManager.getNumPendingShaders() === 0)
        {
            if (!this.technique2D)
            {
                /*var devices = this.devices;

                var font = fontManager.load('fonts/hero.fnt');
                this.font = font;

                var shader = shaderManager.get('shaders/font.cgfx');
                this.technique2D = shader.getTechnique('font');
                this.technique2Dparameters = devices.graphicsDevice.createTechniqueParameters({
                    clipSpace: devices.mathDevice.v4BuildZero(),
                    alphaRef: 0.01,
                    color: devices.mathDevice.v4BuildOne()
                });*/
            }

            return true;
        }

        return false;
    },

    // Draw UI
    drawUI : function drawUIFn()
    {
        var game = this.game;
        var devices = this.devices;
        var graphicsDevice = devices.graphicsDevice;
        var mathDevice = devices.mathDevice;

        var width = graphicsDevice.width;
        var height = graphicsDevice.height;

        var font = this.font;
        var technique2Dparameters = this.technique2Dparameters;

        graphicsDevice.setTechnique(this.technique2D);

        technique2Dparameters.clipSpace = mathDevice.v4Build(2.0 / width, -2.0 / height, -1.0, 1.0,
                                                             technique2Dparameters.clipSpace);
        graphicsDevice.setTechniqueParameters(technique2Dparameters);

        // Draw score
        font.drawTextRect('Score: ' + game.score, {
                rect : [10, 10, (width * 0.5) - 10, 32],
                scale : 1.0,
                spacing : 0,
                alignment : 0
            });

        font.drawTextRect('Kills: ' + game.kills, {
                rect : [(width * 0.5), 10, (width * 0.5) - 10, 32],
                scale : 1.0,
                spacing : 0,
                alignment : 2
            });

        // Draw dead info
        if (game.currentState === game.state.DEAD)
        {
            font.drawTextRect('DEAD', {
                    rect : [0, 20, (width - 10), 32],
                    scale : 1.5,
                    spacing : 0,
                    alignment : 1
                });

            font.drawTextRect('Press SPACE to continue', {
                    rect : [0, 84, (width - 10), 32],
                    scale : 1.0,
                    spacing : 0,
                    alignment : 1
                });
        }

        // Draw connection and host status flags
        if (!this.multiplayerSession)
        {
            font.drawTextRect('No multiplayer servers. Playing solo!', {
                    rect : [0, (height - 32), (width - 10), 32],
                    scale : 0.5,
                    spacing : 0,
                    alignment : 1
                });
        }
        else
        {
            if (this.isHost)
            {
                graphicsDevice.setScissor((width - 6), 2, 4, 4);
                graphicsDevice.clear([1, 0, 0, 1]);
                graphicsDevice.setScissor(0, 0, width, height);
            }

            if (!this.multiplayerSession.connected())
            {
                font.drawTextRect('Connection lost!', {
                        rect : [0, (height - 32), (width - 10), 32],
                        scale : 0.5,
                        spacing : 0,
                        alignment : 1
                    });
            }
        }
    },

    // Checks for shading language support
    hasShaderSupport : function hasShaderSupportFn()
    {
        //var graphicsDevice = this.devices.graphicsDevice;

        //if (!graphicsDevice.shadingLanguageVersion)
        //{
        //    this.errorCallback("No shading language support detected.\nPlease check your graphics drivers are up

//to date.");
        //    graphicsDevice = null;
        //    return false;
        //}
        return true;
    },

    // Create the device interfaces required
    createDevices : function createDevicesFn()
    {
        var devices = this.devices;
        var managers = this.managers;
        var errorCallback = this.errorCallback;

        //var graphicsDeviceParameters = { multisample: 4 };
        //var graphicsDevice = TurbulenzEngine.createGraphicsDevice(graphicsDeviceParameters);

        var mathDeviceParameters = {};
        var mathDevice = TurbulenzEngine.createMathDevice(mathDeviceParameters);

        var inputDeviceParameters = {};
        var inputDevice = TurbulenzEngine.createInputDevice(inputDeviceParameters);

        var networkDeviceParameters = {};
        var networkDevice = TurbulenzEngine.createNetworkDevice(networkDeviceParameters);

        var soundDeviceParameters = {linearDistance : false};
        var soundDevice = TurbulenzEngine.createSoundDevice(soundDeviceParameters);

        //devices.graphicsDevice = graphicsDevice;
        devices.mathDevice = mathDevice;
        devices.inputDevice = inputDevice;
        devices.networkDevice = networkDevice;
        devices.soundDevice = soundDevice;

        var requestHandlerParameters = {};
        var requestHandler = RequestHandler.create(requestHandlerParameters);
        this.requestHandler = requestHandler;

        //managers.textureManager = TextureManager.create(graphicsDevice, requestHandler, null, errorCallback);
        //managers.shaderManager = ShaderManager.create(graphicsDevice, requestHandler, null, errorCallback);
        //managers.effectManager = EffectManager.create(graphicsDevice, mathDevice, managers.shaderManager, null,

//errorCallback);
        //managers.fontManager = FontManager.create(graphicsDevice, requestHandler, null, errorCallback);


        this.canvas = TurbulenzEngine.canvas;
        this.canvas2dContext = this.canvas.getContext('2d');




        return true;
    },

    // Calls functions in order
    enterCallbackChain : function enterCallbackChainFn(context, functions)
    {
        var length = functions.length;
        var localCallback;
        var callNextFunction;

        // Invariant: currentFunction always refers to the last uncalled function
        var currentFunction = -1;

        // Invariant: activeCallbacks refers to the number of functions whose callbacks have not yet been received
        var activeCallbacks = 0;

        callNextFunction = function callNextFunctionFn()
        {
            currentFunction += 1;

            if (!functions[currentFunction].noCallback)
            {
                activeCallbacks += 1;
            }

            functions[currentFunction].func.call(context, localCallback, arguments);
        };

        localCallback = function localCallbackFn()
        {
            activeCallbacks -= 1;

            // If no callbacks are left then call functions consecutively until dependent (or blocker) function is seen
            if (activeCallbacks === 0 &&
                currentFunction < (length - 1))
            {
                // No active callbacks so immediately call next function
                callNextFunction();

                // Call functions until we hit a dependent (blocking) function
                while (currentFunction < (length - 1) &&
                       ((0 === activeCallbacks) || (!functions[currentFunction].isDependent)))
                {
                    callNextFunction();
                }
            }
        };

        // Start the async callback chain
        callNextFunction();
    },

    createGameSounds : function createGameSoundsFn()
    {
      var devices = this.devices;
      var soundDevice = devices.soundDevice;
      var app = this;

      // Create a sound source for each object (different pitch)
      this.backgroundSoundSource = soundDevice.createSource({
          position : [0,0,0],
          relative : false,
          pitch : 1.0
      });
      var backgroundSoundSource = this.backgroundSoundSource;

      this.playerOneSoundSource = soundDevice.createSource({
          position : [0,0,0],
          relative : false,
          pitch : 1.0
      });
      this.playerTwoSoundSource = soundDevice.createSource({
          position : [0,0,0],
          relative : false,
          pitch : 1.0
      });
      var playerOneSoundSource = this.playerOneSoundSource;


      // Create the sound for the source to emit

      soundDevice.createSound({
        src: this.mappingTable.getURL("sounds/TitleMusic.mp3"),
        onload : function (sound)
        {
          if (sound)
          {
            app.soundTitleMusic = sound;
//            backgroundSoundSource.play(app.soundTitleMusic);
          } else {
            app.console.log('Failed to load sounds');
          }
        }
      });

      soundDevice.createSound({
        src: this.mappingTable.getURL("sounds/MainGameMusic.mp3"),
        onload : function (sound)
        {
          if (sound)
          {
            backgroundSoundSource.play(sound);
            app.soundMainMusic = sound;
          } else {
            app.console.log('Failed to load sounds');
          }
        }
      });

      soundDevice.createSound({
        src: this.mappingTable.getURL("sounds/BubbleDown.mp3"),
        onload : function (sound)
        {
          if (sound)
          {
            app.soundBubbleDown = sound;
            app.watair.bubbleDownFn = function() {
              playerOneSoundSource.play(sound);
            }
          } else {
            app.console.log('Failed to load sounds');
          }
        }
      });

      soundDevice.createSound({
        src: this.mappingTable.getURL("sounds/BubbleUp.mp3"),
        onload : function (sound)
        {
          if (sound)
          {
            app.soundBubbleUp = sound;
            app.watair.bubbleUpFn = function() {
              playerOneSoundSource.play(sound);
            }
          } else {
            app.console.log('Failed to load sounds');
          }
        }
      });

      soundDevice.createSound({
        src: this.mappingTable.getURL("sounds/Loser.mp3"),
        onload : function (sound)
        {
          if (sound)
          {
            app.soundLooser = sound;
          } else {
            app.console.log('Failed to load sounds');
          }
        }
      });

      soundDevice.createSound({
        src: this.mappingTable.getURL("sounds/Winner.mp3"),
        onload : function (sound)
        {
          if (sound)
          {
            app.soundWinner = sound;
          } else {
            app.console.log('Failed to load sounds');
          }
        }
      });

      soundDevice.createSound({
        src: this.mappingTable.getURL("sounds/ScoreScreen.mp3"),
        onload : function (sound)
        {
          if (sound)
          {
            app.soundScoreScreen = sound;
          } else {
            app.console.log('Failed to load sounds');
          }
        }
      });


    },


    // Creates the game with the settings provided
    createGame : function createGameFn()
    {
        var devices = this.devices;
        var inputDevice = devices.inputDevice;

        this.game = Game.create(this.gameSettings,
                                devices.graphicsDevice,
                                this.gameSession,
                                this.leaderboards,
                                this.badges,
                                inputDevice.keyCodes,
                                inputDevice.mouseCodes);

        this.createInputDeviceCallbacks();
    },

    // Adds onKeyDown functions to inputDevice
    createInputDeviceCallbacks : function createInputDeviceCallbacksFn()
    {
        var game = this.game;
        var socket = this.socket;
        var inputDevice = this.devices.inputDevice;
        var app = this;

        // Closure for keyDown callback
        function onKeyDown(keynum)
        {
            //game.onKeyDown(keynum);
            switch (keynum) {
              case 200: // Left
                var coordinates = { x: 1, y: 1 };
                socket.emit('move', coordinates);
                break;
              case 201: // Right
                var coordinates = { x: 2, y: 2 };
                socket.emit('move', coordinates);
                break;
              case 202: // Up
                if (app.playerOneSoundSource)
                  app.playerOneSoundSource.play(app.soundBubbleUp);
                var coordinates = { x: 3, y: 3 };
                socket.emit('move', coordinates);
                break;
              case 203: // Down
                if (app.playerTwoSoundSource)
                  app.playerTwoSoundSource.play(app.soundBubbleDown);
                var coordinates = { x: 4, y: 4 };
                socket.emit('move', coordinates);
                break;
              default:
                break;
            }
        }

        function onMouseDown(keynum)
        {
        	app.console.log("onMouseDown");
          //game.onMouseDown(keynum);
        }

        inputDevice.addEventListener('keydown', onKeyDown);
        inputDevice.addEventListener('mousedown', this.onPlayerTouch.bind(this));
    },

    // Create GameLeaderboards
    createGameLeaderboards : function createGameLeaderboardsFn(callback)
    {
        this.leaderboards = GameLeaderboards.create(this.leaderboardManager, callback);
    },

    // Create GameBadges
    createGameBadges : function createGameBadgesFn(callback)
    {
        this.badges = GameBadges.create(this.badgeManager, callback);
    },

    // Create HTML Writer
    createHTMLWriter : function createHTMLWriterFn()
    {
        // Must be created after badges, leaderboards, and game have been initialised
        this.htmlWriter = HtmlWriter.create(this.leaderboards, this.badges, this.game);
    },

    // Create multiplayer session
    createMultiplayerSession : function createMultiplayerSessionFn()
    {
        var that = this;

        function onMultiplayerMessage(senderID, messageType, messageData)
        {
            that.onMessage(senderID, messageType, messageData);
        }

        function onMultiplayerClose()
        {
            that.errorCallback("Connection lost!");
        }

        function createMultiplayerSessionSuccess(multiplayerSession, numplayers)
        {
            if (1 === numplayers)
            {
                that.isHost = true;
                that.game.start();
            }

            that.multiplayerSession = multiplayerSession;

            multiplayerSession.onmessage = onMultiplayerMessage;

            multiplayerSession.onclose = onMultiplayerClose;

            multiplayerSession.sendToAll(that.networkIds.joining);

            that.connectionTime = TurbulenzEngine.time;
        }

        function createMultiplayerSessionError()
        {
            that.multiplayerSession = null;
            that.isHost = true;
            that.game.badges = that.badges;
            that.game.leaderboards = that.leaderboards;
            that.game.start();
        }

        TurbulenzServices.createMultiplayerSession(this.gameSettings.maxPlayers,
                                                   this.requestHandler,
                                                   createMultiplayerSessionSuccess,
                                                   createMultiplayerSessionError);
    },

    // Create game session
    createGameSession : function createGameSessionFn(callback)
    {
        this.gameSession = TurbulenzServices.createGameSession(this.requestHandler, callback);
    },

    // Create mapping table
    createMappingTable : function createMappingTableFn(callback)
    {
        this.mappingTable = TurbulenzServices.createMappingTable(this.requestHandler, this.gameSession, callback);
    },

    // Create leaderboard manager
    createLeaderboardManager : function createLeaderboardManagerFn(callback)
    {
        var that = this;

        function createLeaderboardManagerError()
        {
            that.leaderboardManager = null;
            callback();
        }

        this.leaderboardManager = TurbulenzServices.createLeaderboardManager(this.requestHandler,
                                                                             this.gameSession,
                                                                             callback,
                                                                             createLeaderboardManagerError);
    },

    // Create badge manager
    createBadgeManager : function createBadgeManagerFn()
    {
        // Only create badge manager if leaderboardManager has been initialised successfully
        if (this.leaderboardManager)
        {
            this.badgeManager = TurbulenzServices.createBadgeManager(this.requestHandler, this.gameSession);
        }
    },

    // Starts loading scene and creates an interval to check loading progress
    enterLoadingLoop : function enterLoadingLoopFn()
    {

        var that = this;
        var managers = this.managers;
        var mappingTable = this.mappingTable;
        var urlMapping = mappingTable.urlMapping;
        var assetPrefix = mappingTable.assetPrefix;

        this.loadImages(urlMapping);
        // loadSounds

        //managers.textureManager.setPathRemapping(urlMapping, assetPrefix);
        //managers.shaderManager.setPathRemapping(urlMapping, assetPrefix);
        //managers.fontManager.setPathRemapping(urlMapping, assetPrefix);
        // sound set asset path

        this.appScene = AppScene.create(this.devices, this.managers,
                                        this.requestHandler, this.mappingTable,
                                        this.game);
        this.loadUI();

        // Enter loading state
        function localLoadingStateLoop()
        {
            return that.loadingStateLoop();
        }
        this.intervalID = TurbulenzEngine.setInterval(localLoadingStateLoop, (1000 / 10));
    },

    // Called until assets have been loaded at which point the connecting loop is entered
    loadingStateLoop : function loadingStateLoopFn()
    {
        var that = this;

        function localConnectingStateLoop()
        {
            return that.connectingStateLoop();
        }

        // If everything has finished loading/initialising
        if (this.appScene.hasLoaded() &&
            this.hasUILoaded() /* && sound manager loaded, wait till sounds loaded is zero */ )
        {
            TurbulenzEngine.clearInterval(this.intervalID);

            //this.createMultiplayerSession();

            this.intervalID = TurbulenzEngine.setInterval(localConnectingStateLoop, (1000 / 10));
        }
    },

    // Called until connected to the multiplayer session at which point the main loop is entered
    connectingStateLoop : function connectingStateLoopFn()
    {
        var that = this;

        function localMainStateLoop()
        {
            return that.mainStateLoop();
        }

        //this.devices.networkDevice.update();
        
        TurbulenzEngine.clearInterval(this.intervalID);

            this.appScene.setupScene();

            this.intervalID = TurbulenzEngine.setInterval(localMainStateLoop, (1000 / 60));

        //// If joined game
        //if (this.game.myWormIndex >= 0)
        //{
        //    
        //}
        //else
        //{
        //    // If connected to session
        //    if (this.multiplayerSession)
        //    {
        //        var currentTime = TurbulenzEngine.time;
        //        var connectionTime = this.connectionTime;
        //        var staleTime = this.staleTime;
        //        if ((connectionTime + staleTime) < currentTime)
        //        {
        //            this.isHost = true;
        //            this.game.start();
        //        }
        //        else if ((connectionTime + (staleTime * 0.5)) < currentTime)
        //        {
        //            // Keep requesting to join to avoid problems when starting in the middle of a host transition
        //            this.multiplayerSession.sendToAll(this.networkIds.joining);
        //        }
        //    }
        //}
    },

    mainStateLoop : function mainStateLoopFn()
    {
        var currentTime = TurbulenzEngine.time;
        if (this.update(currentTime))
        {
            this.render(currentTime);
        }
    },

    onMessage : function onMessageFn(senderID, messageType, messageData)
    {
        //Utilities.log(senderID, messageType, messageData);
        var networkIds = this.networkIds;

        switch (messageType)
        {
        case networkIds.joining:
            this.onJoiningMessage(senderID);
            break;

        case networkIds.update:
            this.onUpdateMessage(senderID, messageData);
            break;

        case networkIds.leaving:
            this.onLeavingMessage(senderID);
            break;
        }
    },

    onJoiningMessage : function onJoiningMessageFn(senderID)
    {
        var multiplayerSession = this.multiplayerSession;
        var myID = multiplayerSession.playerId;
        var networkIds = this.networkIds;
        var theOthers = this.others;
        var other = theOthers[senderID];
        var game = this.game;
        var updateData, others, n, otherID, wormIndex;

        var time = TurbulenzEngine.time;

        if (other === undefined)
        {
            if (!this.isHost)
            {
                return;
            }

            var maxPlayers = this.gameSettings.maxPlayers;

            wormIndex = game.myWormIndex;

            var usedWormIndex = {};
            usedWormIndex[wormIndex] = true;

            others = {};
            others[myID] = wormIndex;
            for (otherID in theOthers)
            {
                if (theOthers.hasOwnProperty(otherID))
                {
                    var another = theOthers[otherID];
                    wormIndex = another.wormIndex;
                    usedWormIndex[wormIndex] = true;
                    others[otherID] = wormIndex;
                }
            }

            for (n = 0; n < maxPlayers; n += 1)
            {
                if (!usedWormIndex[n])
                {
                    theOthers[senderID] = {
                        wormIndex: n,
                        heartbeat: time
                    };

                    others[senderID] = n;

                    //Utilities.log('New player wormIndex: ' + n);

                    break;
                }
            }

            updateData = {
                frame: this.frameCounter,
                others: others,
                host: true
            };

            game.serialize(updateData);

            multiplayerSession.sendTo(senderID, networkIds.update, JSON.stringify(updateData));
        }
    },

    onUpdateMessage : function onUpdateMessageFn(senderID, messageData)
    {
        var multiplayerSession = this.multiplayerSession;
        var myID = multiplayerSession.playerId;
        var networkIds = this.networkIds;
        var theOthers = this.others;
        var other = theOthers[senderID];
        var game = this.game;
        var updateData, others, otherID, wormIndex;

        var time = TurbulenzEngine.time;

        if (other !== undefined)
        {
            other.heartbeat = time;
        }

        if (messageData)
        {
            updateData = JSON.parse(messageData);
            if (updateData)
            {
                others = updateData.others;
                if (others !== undefined)
                {
                    for (otherID in others)
                    {
                        if (others.hasOwnProperty(otherID))
                        {
                            wormIndex = others[otherID];

                            if (otherID === myID)
                            {
                                if (game.myWormIndex < 0)
                                {
                                    this.frameCounter = updateData.frame;
                                }
                                game.myWormIndex = wormIndex;
                            }
                            else
                            {
                                var another = theOthers[otherID];
                                if (another === undefined)
                                {
                                    theOthers[otherID] = another = {};
                                }
                                another.wormIndex = wormIndex;
                                another.heartbeat = time;
                            }
                        }
                    }
                }

                if (updateData.host)
                {
                    // Check for host conflict
                    if (this.isHost)
                    {
                        if (myID > senderID)
                        {
                            // This instance should not be the host
                            this.isHost = false;
                            game.myWormIndex = -1;
                            multiplayerSession.sendTo(senderID, networkIds.leaving);
                            multiplayerSession.sendTo(senderID, networkIds.joining);
                        }
                        return;
                    }

                    if (other !== undefined)
                    {
                        other.host = true;
                    }

                    this.hostFrameCounter = updateData.frame;
                }

                if (game.deserialize(this.isHost, updateData))
                {
                    this.needToRender = true;
                }
            }
        }
    },

    onLeavingMessage : function onLeavingMessageFn(senderID)
    {
        var theOthers = this.others;
        var other = theOthers[senderID];
        var game = this.game;

        if (other !== undefined)
        {
            if (this.isHost)
            {
                delete theOthers[senderID];
                game.placeWorm(other.wormIndex);
            }
            else if (other.host)
            {
                // it would be cleared out later by checkOthers
                other.host = false;
                other.heartbeat = 0;
            }
        }
    },



    // Migrate host to player with lower index
    migrateHost : function migrateHostFn()
    {
        var myWormIndex = this.game.myWormIndex;

        var others = this.others;
        for (var otherID in others)
        {
            if (others.hasOwnProperty(otherID))
            {
                var wormIndex = others[otherID].wormIndex;
                if (wormIndex < myWormIndex)
                {
                    return;
                }
            }
        }

        // If we reach this code we should be the host
        this.isHost = true;

        //window.alert("You have become the host of the game!");
    },

    // Check state of others
    checkOthers : function checkOthersFn()
    {
        var staleTime = (TurbulenzEngine.time - this.staleTime);
        var others = this.others;
        var needToMigrate = (!this.isHost);
        var staleWorms = [];
        var numStale = 0;
        var other;

        for (var otherID in others)
        {
            if (others.hasOwnProperty(otherID))
            {
                other = others[otherID];
                if (other.heartbeat < staleTime)
                {
                    staleWorms[numStale] = other.wormIndex;
                    numStale += 1;

                    delete others[otherID];
                }
                else if (other.host)
                {
                    needToMigrate = false;
                }
            }
        }

        if (needToMigrate)
        {
            this.migrateHost();
        }

        if (0 < numStale)
        {
            if (this.isHost)
            {
                var game = this.game;
                var n = 0;
                do
                {
                    game.placeWorm(staleWorms[n]);
                    n += 1;
                }
                while (n < numStale);
            }
        }
    },

    // Attempts to free memory - called from onbeforeunload and/or TurbulenzEngine.onUnload
    shutdown : function shutdownFn()
    {
        if (!this.hasShutdown)
        {
            this.hasShutdown = true;

            TurbulenzEngine.clearInterval(this.intervalID);

            // Leave the multiplayer session
            var multiplayerSession = this.multiplayerSession;
            if (multiplayerSession)
            {
                multiplayerSession.sendToAll(this.networkIds.leaving);

                multiplayerSession.destroy();
            }

            // Tell the Turbulenz Services that the game session is over
            this.gameSession.destroy();

            // Destroy vars in reverse order from creation
            this.technique2Dparameters = null;
            this.technique2D = null;
            this.font = null;
            this.others = null;
            this.managers = null;
            this.devices = null;
            this.game = null;
            this.appScene = null;
            this.htmlWriter = null;
            this.multiplayerSession = null;
            this.badges = null;
            this.leaderboards = null;
            this.badgeManager = null;
            this.leaderBoardManager = null;
            this.gameSession = null;
            this.previousGameUpdateTime = null;
            this.runInEngine = null;

            // Attempt to force clearing of the garbage collector
            TurbulenzEngine.flush();

            // Clear native engine references
            this.devices = null;
        }
    },

    onPlayerTouch : function onPlayerTouch(ignored, x, y) {
    	x = (x - 16) / this.scaleX;
    	y = (y - 16) / this.scaleY;

      this.watair.movePlayerTo(x, y);
      this.socket.emit('move', { x: x, y: y });
    }

};

// Application constructor function
Application.create = function applicationCreateFn(runInEngine)
{
    var application = new Application();
    
    var console = window.console;
    if (console)
    {
        application.console = console;
    }
    else
    {
        application.console = {
            log: function () {},
            warn: function () {},
            error: function () {}
        };
    }

    // Ensures shutdown function is only called once
    application.hasShutDown = false;
    application.runInEngine = runInEngine;

    application.previousGameUpdateTime = 0;
    application.gameSession = {};
    application.multiplayerSession = null;
    application.leaderboardManager = null;
    application.badgeManager = null;
    application.leaderboards = {};
    application.badges = {};
    application.htmlWriter = {};
    application.appScene = {};
    application.game = {};
    application.devices = {};
    application.managers = {};
    application.others = {};
    application.isHost = false;
    application.connectionTime = 0;
    application.frameCounter = 0;
    application.hostFrameCounter = 0;
    application.needToRender = true;

    // UI
    application.font = null;
    application.technique2D = null;
    application.technique2Dparameters = null;

    application.watair = Watair.create({}, application);

    // Disable dragging on ios
    document.ontouchmove = function(event){
        event.preventDefault();
    };

    return application;
};



/*global Application: false */

TurbulenzEngine.onload = function onloadFn()
{
    var application = Application.create(TurbulenzEngine.canvas);

    TurbulenzEngine.onunload = function onUnloadFn()
    {
        application.shutdown();
    };

    application.init();
};

    if (!TurbulenzEngine.onload)
    {
        window.alert("Entry point 'TurbulenzEngine.onload' must be defined for Engine 0.19.0 onwards.");
        return;
    }
    TurbulenzEngine.onload.call(this);
}());